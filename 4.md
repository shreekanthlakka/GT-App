I'm continuing development of a textile business accounting system (Turborepo monorepo).

COMPLETED SERVICES:

- Auth Service ✓
- Notification Service ✓
- Accounts Service:
    - Customer ✓
    - Party ✓
    - Invoice ✓
    - Invoice Payment ✓
    - Sale ✓
    - Sale Receipt ✓
    - Inventory ✓ (just completed)

NEXT TO BUILD:
[Choose one: OCR Service / Order Management / E-commerce Service / Payment Gateway / Analytics]

PROJECT STRUCTURE:

- Turborepo monorepo
- PostgreSQL with Prisma
- Event-driven architecture with Kafka
- Express.js microservices

Here's my Prisma schema:

```prisma
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}


// ========================================
// USER MANAGEMENT
// ========================================

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String
  phone     String?
  password  String
  role      UserRole @default(OWNER)
  isActive  Boolean  @default(true)

  // Security fields
  twoFactorSecret     String?
  twoFactorEnabled    Boolean   @default(false)
  ipWhitelist         Json?     // Array of allowed IP addresses
  failedLoginAttempts Int       @default(0)
  lockedUntil         DateTime?
  lastLoginAt         DateTime?
  lastLoginIP         String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  parties          Party[]
  customers        Customer[]
  invoices         Invoice[]
  invoicePayments  InvoicePayment[]
  saleReceipts     SaleReceipt[]
  sales            Sale[]
  ledgerEntries    LedgerEntry[]
  ocrData          OCRData[]
  reminders        Reminder[]
  notifications    Notification[]
  inventoryItems   InventoryItem[]
  orders           Order[]
  userSessions     UserSession[]
  backups          Backup[]
  restores         Restore[]
  backupSchedule   BackupSchedule?
  auditLogs        AuditLog[]
  stockMovements   StockMovement[]

  @@map("users")
}

model UserSession {
  id           String   @id @default(cuid())
  userId       String
  sessionToken String   @unique
  refreshToken String   @unique
  expiresAt    DateTime
  deviceInfo   Json?    // Device information
  ipAddress    String?
  userAgent    String?
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_sessions")
}

// ========================================
// ECOMMERCE USERS (Public App Users)
// ========================================

model EcommerceUser {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String
  phone     String?
  password  String?  // Nullable for social login users

  // Profile information
  dateOfBirth DateTime?
  gender      String?  // MALE, FEMALE, OTHER
  avatar      String?  // Profile picture URL

  // Address information
  addresses   Json     @default("[]") // [{type: 'home|office', name, phone, address, city, state, pincode, isDefault}]

  // Authentication & Security
  emailVerified     Boolean   @default(false)
  phoneVerified     Boolean   @default(false)
  emailVerificationToken String?
  phoneVerificationToken String?
  passwordResetToken     String?
  passwordResetExpiry    DateTime?

  // Social login
  googleId          String?
  facebookId        String?

  // Account status
  isActive          Boolean   @default(true)
  isBlocked         Boolean   @default(false)
  blockedReason     String?
  blockedAt         DateTime?

  // Preferences
  preferences       Json      @default("{}") // {newsletter: true, sms: true, whatsapp: true, language: 'en'}

  // Marketing
  referralCode      String?   @unique
  referredBy        String?

  // Metadata
  lastLoginAt       DateTime?
  lastLoginIP       String?
  signupSource      String?   // WEBSITE, MOBILE_APP, SOCIAL, REFERRAL

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  orders            Order[]
  ecommerceUserSessions EcommerceUserSession[]
  reviews           Review[]
  wishlistItems     WishlistItem[]
  cartItems         CartItem[]

  @@index([email])
  @@index([phone])
  @@index([referralCode])
  @@index([isActive])
  @@map("ecommerce_users")
}

model EcommerceUserSession {
  id           String   @id @default(cuid())
  userId       String
  sessionToken String   @unique
  refreshToken String   @unique
  expiresAt    DateTime
  deviceInfo   Json?    // {type: 'mobile|desktop', os, browser, version}
  ipAddress    String?
  userAgent    String?
  isActive     Boolean  @default(true)

  ecommerceUser EcommerceUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([userId])
  @@index([sessionToken])
  @@map("ecommerce_user_sessions")
}

// ========================================
// BUSINESS ENTITIES
// ========================================

model Customer {
  id          String  @id @default(cuid())
  name        String
  phone       String?
  email       String?
  address     String?
  city        String?
  state       String?
  pincode     String?
  gstNumber   String?
  creditLimit Decimal @default(0) @db.Decimal(12, 2)

  // Additional fields
  dateOfBirth      DateTime?
  anniversary      DateTime?
  preferredContact String?    // email, phone, whatsapp
  tags             String[]   // VIP, Regular, New, etc.
  notes            String?
  isActive         Boolean    @default(true)

  userId      String
  user        User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  sales         Sale[]
  saleReceipts  SaleReceipt[]
  ledger        LedgerEntry[]
  reminders     Reminder[]
  notifications Notification[]
  orders        Order[]

  @@index([userId])
  @@index([name])
  @@index([phone])
  @@index([email])
  @@map("customers")
}

model Party {
  id            String  @id @default(cuid())
  name          String
  gstNo         String?
  panNo         String?
  phone         String?
  email         String?
  address       String?
  city          String?
  state         String?
  pincode       String?
  contactPerson String?
  bankDetails   Json?   // {bankName, accountNo, ifsc, branch}

  // Additional fields
  category      String?  // Manufacturer, Distributor, Wholesaler
  paymentTerms  Int?     // Payment terms in days
  creditLimit   Decimal  @default(0) @db.Decimal(12, 2)
  taxId         String?
  website       String?
  notes         String?
  isActive      Boolean  @default(true)

  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  invoices         Invoice[]
  invoicePayments  InvoicePayment[]
  ledger           LedgerEntry[]
  notifications    Notification[]

  @@unique([gstNo, userId], name: "unique_gst_per_user")
  @@index([userId])
  @@index([name])
  @@index([gstNo])
  @@map("parties")
}

// ========================================
// INVENTORY MANAGEMENT
// ========================================

model InventoryItem {
  id          String   @id @default(cuid())
  name        String
  description String?
  sku         String?  @unique
  barcode     String?  @unique
  category    String
  subCategory String?
  brand       String?

  // Pricing
  sellingPrice Decimal  @db.Decimal(10, 2)
  costPrice    Decimal? @db.Decimal(10, 2)
  mrp          Decimal? @db.Decimal(10, 2)

  // Stock management
  currentStock    Int      @default(0)
  minimumStock    Int      @default(0)
  maximumStock    Int?
  reorderLevel    Int?
  unit            String   @default("PCS") // PCS, MTR, KG, etc.

  // Textile specific fields
  fabric          String?  // Cotton, Silk, Polyester, etc.
  gsm             Int?     // Grams per square meter
  width           Decimal? @db.Decimal(8, 2) // Width in inches/cm
  color           String?
  design          String?
  pattern         String?
  weaveType       String?  // Plain, Twill, Satin, etc.

  // Product details
  images          Json     @default("[]")
  attributes      Json     @default("{}")

  // Tax and compliance
  hsnCode         String?
  taxRate         Decimal? @db.Decimal(5, 2)

  // Storage and supplier info
  location        String?  // Storage location in shop
  supplier        String?
  leadTime        Int?     // Days
  lastPurchaseDate DateTime?
  lastPurchasePrice Decimal? @db.Decimal(10, 2)

  isActive        Boolean  @default(true)

  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  orderItems      OrderItem[]
  stockMovements  StockMovement[]
  reviews         Review[]
  wishlistItems   WishlistItem[]
  cartItems       CartItem[]

  @@index([userId])
  @@index([category])
  @@index([isActive])
  @@index([sku])
  @@index([barcode])
  @@index([currentStock])
  @@map("inventory_items")
}

model StockMovement {
  id            String       @id @default(cuid())
  inventoryItemId String
  inventoryItem   InventoryItem @relation(fields: [inventoryItemId], references: [id], onDelete: Cascade)

  type          MovementType // IN, OUT, ADJUSTMENT, TRANSFER
  quantity      Int
  previousStock Int
  newStock      Int
  reason        String?
  reference     String?      // Sale ID, Purchase ID, etc.
  batchNumber   String?      // For textile rolls/batches

  // Additional details
  unitPrice     Decimal?     @db.Decimal(10, 2)
  totalValue    Decimal?     @db.Decimal(12, 2)
  notes         String?

  userId        String
  user          User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt     DateTime     @default(now())

  @@index([inventoryItemId])
  @@index([userId])
  @@index([type])
  @@index([createdAt])
  @@map("stock_movements")
}

// ========================================
// SALES TRANSACTIONS
// ========================================

model Sale {
  id              String     @id @default(cuid())
  voucherId       String     @unique
  saleNo          String
  date            DateTime
  amount          Decimal    @db.Decimal(12, 2)
  paidAmount      Decimal    @default(0) @db.Decimal(12, 2)
  remainingAmount Decimal    @db.Decimal(12, 2)
  status          SaleStatus @default(PENDING)

  // Sale items - storing as JSON for flexibility in textile business
  items           Json       // [{itemName, itemType, design, color, price, quantity, total, hsnCode, unit}]

  // Financial details
  taxAmount       Decimal?   @db.Decimal(12, 2)
  discountAmount  Decimal?   @default(0) @db.Decimal(12, 2)
  roundOffAmount  Decimal?   @default(0) @db.Decimal(12, 2)

  // Additional sale details
  salesPerson     String?
  deliveryDate    DateTime?
  deliveryAddress String?
  transportation  String?
  vehicleNo       String?
  reference       String?    // Customer's reference
  terms           String?    // Payment terms
  notes           String?

  customerId      String
  customer        Customer   @relation(fields: [customerId], references: [id], onDelete: Cascade)

  userId          String
  user            User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt

  // Relations
  saleReceipts    SaleReceipt[]
  ledger          LedgerEntry[]
  notifications   Notification[]

  @@unique([saleNo, customerId, userId], name: "unique_sale_per_customer")
  @@index([userId])
  @@index([customerId])
  @@index([status])
  @@index([date])
  @@map("sales")
}

// ========================================
// PURCHASE TRANSACTIONS
// ========================================

model Invoice {
  id              String        @id @default(cuid())
  voucherId       String        @unique
  invoiceNo       String
  date            DateTime
  dueDate         DateTime?
  amount          Decimal       @db.Decimal(12, 2)
  paidAmount      Decimal       @default(0) @db.Decimal(12, 2)
  remainingAmount Decimal       @db.Decimal(12, 2)
  status          InvoiceStatus @default(PENDING)

  // Invoice line items - flexible JSON structure for textile purchases
  items           Json?         // [{description, quantity, rate, amount, hsnCode, taxRate}]

  description     String?
  taxAmount       Decimal?      @db.Decimal(12, 2)
  discountAmount  Decimal?      @default(0) @db.Decimal(12, 2)
  roundOffAmount  Decimal?      @default(0) @db.Decimal(12, 2)
  notes           String?

  // Additional invoice fields
  poNumber        String?       // Purchase Order Number
  transportMode   String?
  vehicleNo       String?
  deliveryNote    String?
  supplierRef     String?
  otherRef        String?
  buyersOrderNo   String?
  dispatchedThrough String?
  destination     String?

  partyId         String
  party           Party         @relation(fields: [partyId], references: [id], onDelete: Cascade)

  userId          String
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // Relations
  invoicePayments InvoicePayment[]
  ledger          LedgerEntry[]
  ocrData         OCRData?
  notifications   Notification[]

  @@unique([invoiceNo, partyId, userId], name: "unique_invoice_per_party")
  @@index([userId])
  @@index([partyId])
  @@index([status])
  @@index([date])
  @@index([dueDate])
  @@map("invoices")
}

// ========================================
// PAYMENT TRANSACTIONS
// ========================================

model InvoicePayment {
  id          String        @id @default(cuid())
  voucherId   String        @unique
  amount      Decimal       @db.Decimal(12, 2)
  date        DateTime
  method      PaymentMethod
  reference   String?       // Bank ref, cheque no, UPI transaction ID
  description String?
  status      PaymentStatus @default(COMPLETED)

  // Gateway fields for online payments
  gatewayOrderId   String?
  gatewayPaymentId String?
  transactionId    String?
  failureReason    String?

  // Banking details
  bankName        String?
  chequeNo        String?
  chequeDate      DateTime?
  clearanceDate   DateTime?
  charges         Decimal? @db.Decimal(8, 2)

  // Relations
  partyId     String
  party       Party        @relation(fields: [partyId], references: [id], onDelete: Cascade)

  invoiceId   String?
  invoice     Invoice?     @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  userId      String
  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  // Relations
  ledger        LedgerEntry[]
  ocrData       OCRData?
  notifications Notification[]

  @@index([userId])
  @@index([method])
  @@index([date])
  @@index([partyId])
  @@index([invoiceId])
  @@map("invoice_payments")
}

model SaleReceipt {
  id          String   @id @default(cuid())
  voucherId   String   @unique
  receiptNo   String
  date        DateTime
  amount      Decimal  @db.Decimal(12, 2)
  method      PaymentMethod
  description String?
  reference   String?  // Transaction reference
  imageUrl    String?  // Photo of physical receipt

  // Banking details
  bankName        String?
  chequeNo        String?
  chequeDate      DateTime?
  clearanceDate   DateTime?
  charges         Decimal? @db.Decimal(8, 2)

  // Relations
  customerId  String
  customer    Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  saleId      String?
  sale        Sale?    @relation(fields: [saleId], references: [id], onDelete: Cascade)

  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  ledger        LedgerEntry[]
  ocrData       OCRData?
  notifications Notification[]

  @@unique([receiptNo, customerId, userId], name: "unique_receipt_per_customer")
  @@index([userId])
  @@index([customerId])
  @@index([date])
  @@index([method])
  @@map("sale_receipts")
}

// ========================================
// E-COMMERCE FEATURES
// ========================================

model Review {
  id        String   @id @default(cuid())
  rating    Int      // 1-5 stars
  title     String?
  comment   String?
  images    Json     @default("[]") // Array of image URLs

  // Status
  isVerified Boolean @default(false) // Verified purchase review
  isApproved Boolean @default(false) // Admin approved

  // Relations
  inventoryItemId String
  inventoryItem   InventoryItem @relation(fields: [inventoryItemId], references: [id], onDelete: Cascade)

  ecommerceUserId String
  ecommerceUser   EcommerceUser @relation(fields: [ecommerceUserId], references: [id], onDelete: Cascade)

  orderId     String? // Link to purchase for verified reviews
  order       Order?  @relation(fields: [orderId], references: [id], onDelete: SetNull)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([inventoryItemId])
  @@index([ecommerceUserId])
  @@index([rating])
  @@index([isApproved])
  @@map("reviews")
}

model WishlistItem {
  id        String   @id @default(cuid())

  inventoryItemId String
  inventoryItem   InventoryItem @relation(fields: [inventoryItemId], references: [id], onDelete: Cascade)

  ecommerceUserId String
  ecommerceUser   EcommerceUser @relation(fields: [ecommerceUserId], references: [id], onDelete: Cascade)

  createdAt   DateTime @default(now())

  @@unique([inventoryItemId, ecommerceUserId])
  @@index([ecommerceUserId])
  @@map("wishlist_items")
}

model CartItem {
  id        String   @id @default(cuid())
  quantity  Int      @default(1)

  inventoryItemId String
  inventoryItem   InventoryItem @relation(fields: [inventoryItemId], references: [id], onDelete: Cascade)

  ecommerceUserId String
  ecommerceUser   EcommerceUser @relation(fields: [ecommerceUserId], references: [id], onDelete: Cascade)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([inventoryItemId, ecommerceUserId])
  @@index([ecommerceUserId])
  @@map("cart_items")
}

model Order {
  id             String      @id @default(cuid())
  orderNo        String      @unique
  date           DateTime    @default(now())
  status         OrderStatus @default(PENDING)
  totalAmount    Decimal     @db.Decimal(12, 2)
  paidAmount     Decimal     @default(0) @db.Decimal(12, 2)
  shippingAmount Decimal     @default(0) @db.Decimal(12, 2)
  taxAmount      Decimal     @default(0) @db.Decimal(12, 2)
  discountAmount Decimal     @default(0) @db.Decimal(12, 2)

  shippingAddress Json?      // {name, phone, address, city, state, pincode}
  billingAddress  Json?
  notes          String?

  // Additional fields
  source         String?     // ONLINE, PHONE, WALK_IN, ECOMMERCE
  priority       String?     // HIGH, NORMAL, LOW
  expectedDelivery DateTime?
  actualDelivery   DateTime?
  trackingNumber   String?

  // Relations - Can be either internal customer or ecommerce user
  customerId      String?
  customer        Customer?     @relation(fields: [customerId], references: [id], onDelete: Cascade)

  ecommerceUserId String?
  ecommerceUser   EcommerceUser? @relation(fields: [ecommerceUserId], references: [id], onDelete: Cascade)

  userId         String
  user           User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt

  // Relations
  items          OrderItem[]
  payments       OrderPayment[]
  notifications  Notification[]
  reviews        Review[]

  @@index([userId])
  @@index([customerId])
  @@index([ecommerceUserId])
  @@index([status])
  @@index([date])
  @@map("orders")
}

model OrderItem {
  id        String  @id @default(cuid())
  quantity  Int
  price     Decimal @db.Decimal(10, 2)
  total     Decimal @db.Decimal(12, 2)
  discount  Decimal @default(0) @db.Decimal(8, 2)

  inventoryItemId String
  inventoryItem   InventoryItem @relation(fields: [inventoryItemId], references: [id], onDelete: Cascade)

  orderId   String
  order     Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([orderId])
  @@index([inventoryItemId])
  @@map("order_items")
}

model OrderPayment {
  id               String        @id @default(cuid())
  amount           Decimal       @db.Decimal(12, 2)
  method           PaymentMethod
  status           String        // pending, completed, failed, refunded
  gatewayOrderId   String?       // Razorpay/Stripe order ID
  gatewayPaymentId String?       // Razorpay/Stripe payment ID
  transactionId    String?
  failureReason    String?

  orderId          String
  order            Order         @relation(fields: [orderId], references: [id], onDelete: Cascade)

  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt

  @@index([orderId])
  @@index([status])
  @@map("order_payments")
}

// ========================================
// LEDGER & ACCOUNTING
// ========================================

model LedgerEntry {
  id          String     @id @default(cuid())
  date        DateTime
  description String
  debit       Decimal    @default(0) @db.Decimal(12, 2)
  credit      Decimal    @default(0) @db.Decimal(12, 2)
  balance     Decimal    @db.Decimal(12, 2)
  type        LedgerType
  reference   String?    // Reference to source document

  // Relations (nullable for flexibility)
  partyId     String?
  party       Party?     @relation(fields: [partyId], references: [id], onDelete: Cascade)

  customerId  String?
  customer    Customer?  @relation(fields: [customerId], references: [id], onDelete: Cascade)

  invoiceId   String?
  invoice     Invoice?   @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  saleId      String?
  sale        Sale?      @relation(fields: [saleId], references: [id], onDelete: Cascade)

  invoicePaymentId String?
  invoicePayment   InvoicePayment? @relation(fields: [invoicePaymentId], references: [id], onDelete: Cascade)

  saleReceiptId    String?
  saleReceipt      SaleReceipt?    @relation(fields: [saleReceiptId], references: [id], onDelete: Cascade)

  userId      String
  user        User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  @@index([userId])
  @@index([partyId])
  @@index([customerId])
  @@index([date])
  @@index([type])
  @@map("ledger_entries")
}

// ========================================
// COMMUNICATION & NOTIFICATIONS
// ========================================

model Notification {
  id        String             @id @default(cuid())
  title     String
  message   String
  type      NotificationType
  channel   NotificationChannel
  status    NotificationStatus @default(PENDING)

  // Recipient details
  recipientType String           // CUSTOMER, PARTY, USER
  recipientId   String
  recipientName String
  recipientContact String?

  // Message details
  templateName String?
  templateData Json?

  // Delivery details
  sentAt       DateTime?
  deliveredAt  DateTime?
  readAt       DateTime?
  failureReason String?
  retryCount   Int              @default(0)
  maxRetries   Int              @default(3)

  // External service details
  externalId   String?
  externalData Json?

  // Relations (nullable - notification can be related to any entity)
  partyId    String?
  party      Party?    @relation(fields: [partyId], references: [id], onDelete: Cascade)

  customerId String?
  customer   Customer? @relation(fields: [customerId], references: [id], onDelete: Cascade)

  invoiceId  String?
  invoice    Invoice?  @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  saleId     String?
  sale       Sale?     @relation(fields: [saleId], references: [id], onDelete: Cascade)

  invoicePaymentId String?
  invoicePayment   InvoicePayment? @relation(fields: [invoicePaymentId], references: [id], onDelete: Cascade)

  saleReceiptId    String?
  saleReceipt      SaleReceipt?    @relation(fields: [saleReceiptId], references: [id], onDelete: Cascade)

  orderId    String?
  order      Order?    @relation(fields: [orderId], references: [id], onDelete: Cascade)

  userId     String
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  @@index([userId])
  @@index([status])
  @@index([type])
  @@index([channel])
  @@index([recipientType, recipientId])
  @@index([createdAt])
  @@index([sentAt])
  @@map("notifications")
}


model NotificationTemplate {
  id          String   @id @default(cuid())
  name        String   @unique
  channel     NotificationChannel
  type        NotificationType
  subject     String?  // For email templates
  content     String   // Template content with placeholders
  variables   Json     // Expected variables and their types
  metadata    Json?    // Additional template metadata
  isActive    Boolean  @default(true)
  category    String?
  description String?

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([channel, type])
  @@index([isActive])
  @@map("notification_templates")
}

model Reminder {
  id          String         @id @default(cuid())
  message     String
  type        ReminderType
  status      ReminderStatus @default(PENDING)
  scheduledAt DateTime
  sentAt      DateTime?
  channel     String         // whatsapp, sms, email
  metadata    Json?          // Additional data like template variables

  customerId  String
  customer    Customer       @relation(fields: [customerId], references: [id], onDelete: Cascade)

  userId      String
  user        User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  @@index([userId])
  @@index([customerId])
  @@index([status])
  @@index([scheduledAt])
  @@map("reminders")
}

// ========================================
// OCR & DOCUMENT PROCESSING
// ========================================

model OCRData {
  id            String    @id @default(cuid())
  imageUrl      String
  originalName  String?   // Original filename
  fileSize      Int?      // File size in bytes
  extractedData Json      @default("{}") // Raw extracted data from OCR
  processedData Json?     // Cleaned and structured data
  confidence    Float?
  status        OCRStatus @default(PROCESSING)
  errorMessage  String?   // Error details if failed

  // Relations (nullable - one OCR can be linked to any document)
  invoiceId     String?   @unique
  invoice       Invoice?  @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  invoicePaymentId String? @unique
  invoicePayment   InvoicePayment? @relation(fields: [invoicePaymentId], references: [id], onDelete: Cascade)

  saleReceiptId    String? @unique
  saleReceipt      SaleReceipt? @relation(fields: [saleReceiptId], references: [id], onDelete: Cascade)

  userId        String
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@index([userId])
  @@index([status])
  @@map("ocr_data")
}

// ========================================
// BACKUP & SYSTEM MANAGEMENT
// ========================================

model Backup {
  id          String    @id @default(cuid())
  type        String    // FULL, INCREMENTAL, SCHEMA
  description String?
  status      String    // IN_PROGRESS, COMPLETED, FAILED
  filePath    String?
  cloudPath   String?
  fileSize    BigInt?
  startedAt   DateTime
  completedAt DateTime?
  errorMessage String?

  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([userId])
  @@index([status])
  @@map("backups")
}

model Restore {
  id          String    @id @default(cuid())
  backupId    String
  status      String    // IN_PROGRESS, COMPLETED, FAILED
  startedAt   DateTime
  completedAt DateTime?
  errorMessage String?

  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([userId])
  @@index([status])
  @@map("restores")
}

model BackupSchedule {
  id        String   @id @default(cuid())
  frequency String   // DAILY, WEEKLY, MONTHLY
  time      String   // HH:MM format
  type      String   // FULL, INCREMENTAL
  enabled   Boolean  @default(true)

  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("backup_schedules")
}

// ========================================
// AUDIT & COMPLIANCE
// ========================================

model AuditLog {
  id        String   @id @default(cuid())
  userId    String?
  user      User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  action    String   // CREATE, UPDATE, DELETE, LOGIN, etc.
  entity    String   // Table name or resource
  entityId  String   // Record ID
  oldData   Json?    // Previous data
  newData   Json?    // New data
  metadata  Json?    // Additional context
  ipAddress String?
  userAgent String?

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([entity])
  @@index([action])
  @@index([createdAt])
  @@map("audit_logs")
}

model SystemConfig {
  id    String @id @default(cuid())
  key   String @unique
  value Json

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("system_config")
}

// ========================================
// ENUMS
// ========================================

enum UserRole {
  OWNER
  MANAGER
  STAFF
  VIEWER
  ACCOUNTANT
}

enum InvoiceStatus {
  PENDING
  PARTIALLY_PAID
  PAID
  OVERDUE
  CANCELLED
}

enum SaleStatus {
  PENDING
  PARTIALLY_PAID
  PAID
  OVERDUE
  CANCELLED
  RETURNED
}

enum PaymentMethod {
  CASH
  BANK_TRANSFER
  CHEQUE
  UPI
  CARD
  ONLINE
  OTHER
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  CANCELLED
  REFUNDED
}

enum LedgerType {
  // Document creation entries
  INVOICE_CREATED           // When invoice is received from supplier
  SALE_CREATED             // When sale is made to customer

  // Payment entries
  INVOICE_PAYMENT          // Payment made to supplier
  SALE_RECEIPT             // Receipt from customer
  EXPENSE_PAYMENT          // General business expenses
  ADVANCE_PAYMENT_MADE     // Advance paid to supplier
  ADVANCE_PAYMENT_RECEIVED // Advance received from customer

  // Adjustments
  ADJUSTMENT
  OPENING_BALANCE
  CLOSING_BALANCE

  // Additional specific types
  DISCOUNT_ALLOWED         // Discount given to customer
  DISCOUNT_RECEIVED        // Discount from supplier
  BAD_DEBT_WRITEOFF       // Uncollectable customer debt
  BANK_CHARGES            // Bank transaction charges
  INTEREST_EARNED         // Interest income
  INTEREST_PAID           // Interest expense
  CREDIT_LIMIT_CHANGE
}

enum ReminderType {
  PAYMENT_DUE
  OVERDUE_PAYMENT
  FOLLOW_UP
  CUSTOM
  BIRTHDAY
  ANNIVERSARY
  STOCK_REORDER
  TAX_FILING
}

enum ReminderStatus {
  PENDING
  SENT
  DELIVERED
  FAILED
  CANCELLED
}

enum OCRStatus {
  PROCESSING
  COMPLETED
  FAILED
  MANUAL_REVIEW
  CANCELLED
}

enum OrderStatus {
  PENDING
  CONFIRMED
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
  RETURNED
  REFUNDED
}

enum NotificationType {
  PAYMENT_REMINDER
  PAYMENT_CONFIRMATION
  INVOICE_CREATED
  INVOICE_OVERDUE
  SALE_CREATED
  ORDER_CONFIRMATION
  ORDER_STATUS_UPDATE
  STOCK_ALERT
  LOW_STOCK_ALERT
  REORDER_ALERT
  CUSTOM
  WELCOME
  BIRTHDAY
  ANNIVERSARY
  PROMOTIONAL
  SYSTEM_ALERT
  BACKUP_COMPLETED
  BACKUP_FAILED
}

enum NotificationChannel {
  WHATSAPP
  SMS
  EMAIL
  PUSH
  IN_APP
}

enum NotificationStatus {
  PENDING
  SENT
  DELIVERED
  READ
  FAILED
  CANCELLED
}

enum MovementType {
  IN          // Stock received
  OUT         // Stock sold/dispatched
  ADJUSTMENT  // Manual stock correction
  TRANSFER    // Transfer between locations
  RETURN      // Customer/supplier returns
  DAMAGE      // Damaged goods writeoff
  SAMPLE      // Sample given to customer
  WASTAGE     // Production wastage
}

```

Please help me build the [SERVICE NAME] with:

- Controllers
- Routes
- Event Publishers
- Validation middleware
- Service layer (if needed)

```typescript
import { prisma } from "@repo/db/prisma";
import {
    asyncHandler,
    CustomError,
    CustomResponse,
} from "@repo/common-backend/utils";
import { logger, LogCategory } from "@repo/common-backend/logger";
import {
    CustomerCreatedPublisher,
    CustomerUpdatedPublisher,
    CustomerDeletedPublisher,
} from "../events/publishers/customerPublishers";
import { kafkaWrapper } from "@repo/common-backend/kafka";
import { LedgerService } from "../services/ledgerService";

export const createCustomer = asyncHandler(async (req, res) => {
    const userId = req.user?.userId;
    if (!userId) {
        return;
    }
    const {
        name,
        phone,
        email,
        address,
        city,
        state,
        pincode,
        gstNumber,
        creditLimit = 0,
        dateOfBirth,
        anniversary,
        preferredContact,
        tags = [],
        notes,
    } = req.body;

    logger.info("Creating customer", LogCategory.ACCOUNTS, {
        userId,
        customerName: name,
        phone,
        email,
    });

    // Check for duplicate phone/email for this user
    const whereClause: any[] = [{ userId }];
    if (phone) {
        whereClause.push({ phone });
    }
    if (email) {
        whereClause.push({ email });
    }

    if (phone || email) {
        const existingCustomer = await prisma.customer.findFirst({
            where: {
                AND: [
                    { userId },
                    {
                        OR: whereClause.slice(1), // Exclude userId from OR clause
                    },
                ],
                isActive: true,
            },
        });

        if (existingCustomer) {
            throw new CustomError(
                409,
                "Customer with this phone/email already exists"
            );
        }
    }

    // Create customer
    const customer = await prisma.customer.create({
        data: {
            name,
            phone,
            email,
            address,
            city,
            state,
            pincode,
            gstNumber,
            creditLimit,
            dateOfBirth: dateOfBirth ? new Date(dateOfBirth) : null,
            anniversary: anniversary ? new Date(anniversary) : null,
            preferredContact,
            tags,
            notes,
            userId,
        },
    });

    // Create opening balance if creditLimit is provided
    if (creditLimit > 0) {
        await LedgerService.createOpeningBalance({
            customerId: customer.id,
            amount: 0, // Starting with zero balance
            creditLimit,
            userId,
            description: `Opening balance for ${customer.name}`,
        });
    }

    // Audit log
    logger.audit("CREATE", "Customer", customer.id, userId, null, customer, {
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"],
    });

    // Publish customer created event
    const customerCreatedPublisher = new CustomerCreatedPublisher(
        kafkaWrapper.producer
    );
    await customerCreatedPublisher.publish({
        id: customer.id,
        userId,
        name: customer.name,
        phone: customer.phone,
        email: customer.email,
        address: customer.address,
        city: customer.city,
        state: customer.state,
        pincode: customer.pincode,
        gstNumber: customer.gstNumber,
        creditLimit: Number(customer.creditLimit),
        dateOfBirth: customer.dateOfBirth?.toISOString(),
        anniversary: customer.anniversary?.toISOString(),
        preferredContact: customer.preferredContact,
        tags: customer.tags,
        notes: customer.notes,
        createdBy: userId,
        createdAt: customer.createdAt.toISOString(),
    });

    logger.info("Customer created successfully", LogCategory.ACCOUNTS, {
        customerId: customer.id,
        customerName: customer.name,
        userId,
    });

    const response = new CustomResponse(201, "Customer created successfully", {
        customer,
    });
    res.status(response.statusCode).json(response);
});

export const getCustomers = asyncHandler(async (req, res) => {
    const userId = req.user?.userId;
    const {
        page = 1,
        limit = 10,
        search,
        city,
        state,
        tags,
        isActive = true,
        sortBy = "name",
        sortOrder = "asc",
        hasOutstanding = false,
    } = req.query;

    const skip = (Number(page) - 1) * Number(limit);
    const take = Number(limit);

    // Build where clause
    const whereClause: any = {
        userId,
        isActive: isActive === "true",
    };

    if (search) {
        whereClause.OR = [
            { name: { contains: search as string, mode: "insensitive" } },
            { phone: { contains: search as string, mode: "insensitive" } },
            { email: { contains: search as string, mode: "insensitive" } },
            { gstNumber: { contains: search as string, mode: "insensitive" } },
        ];
    }

    if (city) {
        whereClause.city = { contains: city as string, mode: "insensitive" };
    }

    if (state) {
        whereClause.state = { contains: state as string, mode: "insensitive" };
    }

    if (tags) {
        whereClause.tags = {
            hasSome: Array.isArray(tags) ? tags : [tags],
        };
    }

    const [customers, total] = await Promise.all([
        prisma.customer.findMany({
            where: whereClause,
            skip,
            take,
            orderBy: {
                [sortBy as string]: sortOrder as "asc" | "desc",
            },
            include: {
                _count: {
                    select: {
                        sales: { where: { status: { not: "CANCELLED" } } },
                        saleReceipts: true,
                    },
                },
            },
        }),
        prisma.customer.count({ where: whereClause }),
    ]);

    // Get balances for each customer
    const customersWithBalances = await Promise.all(
        customers.map(async (customer) => {
            const balance = await LedgerService.getCustomerBalance(customer.id);
            return {
                ...customer,
                balance: balance.balance,
                totalSales: balance.totalSales,
                totalPayments: balance.totalPayments,
                lastTransactionDate: balance.lastEntryDate,
                hasOutstanding: balance.balance > 0,
            };
        })
    );

    // Filter by outstanding if requested
    const filteredCustomers =
        hasOutstanding === "true"
            ? customersWithBalances.filter((c) => c.hasOutstanding)
            : customersWithBalances;

    const response = new CustomResponse(
        200,
        "Customers retrieved successfully",
        {
            customers: filteredCustomers,
            pagination: {
                total:
                    hasOutstanding === "true"
                        ? filteredCustomers.length
                        : total,
                page: Number(page),
                limit: Number(limit),
                pages: Math.ceil(
                    (hasOutstanding === "true"
                        ? filteredCustomers.length
                        : total) / Number(limit)
                ),
            },
        }
    );
    res.status(response.statusCode).json(response);
});

export const getCustomerById = asyncHandler(async (req, res) => {
    const userId = req.user?.userId;
    const { id } = req.params;

    const customer = await prisma.customer.findFirst({
        where: {
            id,
            userId,
        },
        include: {
            sales: {
                take: 10,
                orderBy: { createdAt: "desc" },
                select: {
                    id: true,
                    saleNo: true,
                    voucherId: true,
                    date: true,
                    amount: true,
                    remainingAmount: true,
                    status: true,
                },
            },
            saleReceipts: {
                take: 10,
                orderBy: { createdAt: "desc" },
                select: {
                    id: true,
                    receiptNo: true,
                    voucherId: true,
                    amount: true,
                    date: true,
                    method: true,
                },
            },
            _count: {
                select: {
                    sales: { where: { status: { not: "CANCELLED" } } },
                    saleReceipts: true,
                },
            },
        },
    });

    if (!customer) {
        throw new CustomError(404, "Customer not found");
    }

    // Get ledger balance
    const balance = await LedgerService.getCustomerBalance(customer.id);

    const response = new CustomResponse(
        200,
        "Customer retrieved successfully",
        {
            customer: {
                ...customer,
                balance: balance.balance,
                totalSales: balance.totalSales,
                totalPayments: balance.totalPayments,
                lastTransactionDate: balance.lastEntryDate,
            },
        }
    );
    res.status(response.statusCode).json(response);
});

export const updateCustomer = asyncHandler(async (req, res) => {
    const userId = req.user?.userId;
    const { id } = req.params;
    const updateData = req.body;

    if (!userId) return;
    // Get existing customer
    const existingCustomer = await prisma.customer.findFirst({
        where: { id, userId },
    });

    if (!existingCustomer) {
        throw new CustomError(404, "Customer not found");
    }

    // Check for duplicate phone/email if being updated
    if (updateData.phone || updateData.email) {
        const duplicateConditions: any[] = [];

        if (updateData.phone && updateData.phone !== existingCustomer.phone) {
            duplicateConditions.push({ phone: updateData.phone });
        }

        if (updateData.email && updateData.email !== existingCustomer.email) {
            duplicateConditions.push({ email: updateData.email });
        }

        if (duplicateConditions.length > 0) {
            const duplicate = await prisma.customer.findFirst({
                where: {
                    userId,
                    id: { not: id },
                    OR: duplicateConditions,
                    isActive: true,
                },
            });

            if (duplicate) {
                throw new CustomError(
                    409,
                    "Customer with this phone/email already exists"
                );
            }
        }
    }

    // Convert date strings to Date objects
    if (updateData.dateOfBirth) {
        updateData.dateOfBirth = new Date(updateData.dateOfBirth);
    }
    if (updateData.anniversary) {
        updateData.anniversary = new Date(updateData.anniversary);
    }

    // Update customer
    const updatedCustomer = await prisma.customer.update({
        where: { id },
        data: {
            ...updateData,
            updatedAt: new Date(),
        },
    });

    // Log credit limit change if changed
    if (
        updateData.creditLimit &&
        updateData.creditLimit !== existingCustomer.creditLimit
    ) {
        await LedgerService.logCreditLimitChange({
            customerId: id,
            oldLimit: Number(existingCustomer.creditLimit),
            newLimit: Number(updateData.creditLimit),
            userId,
            reason: "Manual update via customer management",
        });
    }

    // Calculate changes for event
    const changes: Record<string, { oldValue: any; newValue: any }> = {};
    Object.keys(updateData).forEach((key) => {
        if (updateData[key] !== (existingCustomer as any)[key]) {
            changes[key] = {
                oldValue: (existingCustomer as any)[key],
                newValue: updateData[key],
            };
        }
    });

    // Audit log
    logger.audit(
        "UPDATE",
        "Customer",
        id,
        userId,
        existingCustomer,
        updatedCustomer,
        {
            ipAddress: req.ip,
            userAgent: req.headers["user-agent"],
        }
    );

    // Publish customer updated event
    const customerUpdatedPublisher = new CustomerUpdatedPublisher(
        kafkaWrapper.producer
    );
    await customerUpdatedPublisher.publish({
        id: updatedCustomer.id,
        updatedAt: updatedCustomer.updatedAt.toISOString(),
        changes,
        updatedBy: userId,
        contactChanged: !!(changes.phone || changes.email || changes.address),
        creditLimitChanged: !!changes.creditLimit,
        tagsChanged: !!changes.tags,
        preferencesChanged: !!changes.preferredContact,
    });

    logger.info("Customer updated successfully", LogCategory.ACCOUNTS, {
        customerId: id,
        customerName: updatedCustomer.name,
        userId,
        changesCount: Object.keys(changes).length,
    });

    const response = new CustomResponse(200, "Customer updated successfully", {
        customer: updatedCustomer,
    });
    res.status(response.statusCode).json(response);
});

export const deleteCustomer = asyncHandler(async (req, res) => {
    const userId = req.user?.userId;
    const { id } = req.params;

    if (!userId && !id) return;

    const customer = await prisma.customer.findFirst({
        where: { id, userId },
        include: {
            _count: {
                select: {
                    sales: { where: { status: { not: "CANCELLED" } } },
                    saleReceipts: true,
                },
            },
        },
    });

    if (!customer) {
        throw new CustomError(404, "Customer not found");
    }

    // Check if customer has transactions
    const hasTransactions =
        customer._count.sales > 0 || customer._count.saleReceipts > 0;

    if (hasTransactions) {
        // Soft delete - deactivate instead of hard delete
        const updatedCustomer = await prisma.customer.update({
            where: { id },
            data: {
                isActive: false,
                updatedAt: new Date(),
            },
        });

        logger.info(
            "Customer deactivated (has transactions)",
            LogCategory.ACCOUNTS,
            {
                customerId: id,
                customerName: customer.name,
                userId,
                salesCount: customer._count.sales,
                receiptsCount: customer._count.saleReceipts,
            }
        );

        const response = new CustomResponse(
            200,
            "Customer deactivated successfully (has existing transactions)",
            {
                customer: updatedCustomer,
            }
        );
        return res.status(response.statusCode).json(response);
    }

    // Hard delete if no transactions
    await prisma.customer.delete({
        where: { id },
    });

    // Audit log
    logger.audit("DELETE", "Customer", id, userId, customer, null, {
        ipAddress: req.ip,
        userAgent: req.headers["user-agent"],
    });

    // Publish customer deleted event
    const customerDeletedPublisher = new CustomerDeletedPublisher(
        kafkaWrapper.producer
    );
    await customerDeletedPublisher.publish({
        id: customer.id,
        name: customer.name,
        phone: customer.phone,
        email: customer.email,
        deletedAt: new Date().toISOString(),
        deletedBy: userId,
        hasOutstandingSales: false,
        finalBalance: 0,
        reason: "Manual deletion via customer management",
    });

    logger.info("Customer deleted successfully", LogCategory.ACCOUNTS, {
        customerId: id,
        customerName: customer.name,
        userId,
    });

    const response = new CustomResponse(200, "Customer deleted successfully");
    res.status(response.statusCode).json(response);
});

export const getCustomerLedger = asyncHandler(async (req, res) => {
    const userId = req.user?.userId;
    const { id } = req.params;
    const { startDate, endDate, limit = 50, offset = 0 } = req.query;

    // Verify customer belongs to user
    const customer = await prisma.customer.findFirst({
        where: { id, userId },
        select: { id: true, name: true },
    });

    if (!customer) {
        throw new CustomError(404, "Customer not found");
    }

    const query: any = {
        limit: Number(limit),
        offset: Number(offset),
    };

    if (startDate || endDate) {
        query.dateRange = {};
        if (startDate) query.dateRange.gte = new Date(startDate as string);
        if (endDate) query.dateRange.lte = new Date(endDate as string);
    }

    const ledgerStatement = await LedgerService.getCustomerLedger(id, query);

    const response = new CustomResponse(
        200,
        "Customer ledger retrieved successfully",
        {
            customer: { id: customer.id, name: customer.name },
            ledger: ledgerStatement,
        }
    );
    res.status(response.statusCode).json(response);
});

export const getCustomerStatement = asyncHandler(async (req, res) => {
    const userId = req.user?.userId;
    const { id } = req.params;
    const { startDate, endDate, format = "json" } = req.query;

    // Verify customer belongs to user
    const customer = await prisma.customer.findFirst({
        where: { id, userId },
        select: { id: true, name: true, email: true, phone: true },
    });

    if (!customer) {
        throw new CustomError(404, "Customer not found");
    }

    const start = startDate
        ? new Date(startDate as string)
        : new Date(new Date().getFullYear(), new Date().getMonth(), 1);
    const end = endDate ? new Date(endDate as string) : new Date();

    const ledgerStatement = await LedgerService.getCustomerLedger(id, {
        dateRange: { gte: start, lte: end },
        limit: 1000,
    });

    // Get outstanding sales
    const outstandingSales = await prisma.sale.findMany({
        where: {
            customerId: id,
            status: { in: ["PENDING", "PARTIALLY_PAID", "OVERDUE"] },
        },
        select: {
            id: true,
            saleNo: true,
            voucherId: true,
            date: true,
            amount: true,
            remainingAmount: true,
            status: true,
        },
        orderBy: { date: "asc" },
    });

    const statement = {
        customer,
        period: {
            startDate: start.toISOString(),
            endDate: end.toISOString(),
        },
        ledger: ledgerStatement,
        outstandingSales,
        summary: {
            totalSales: ledgerStatement.totalDebit,
            totalPayments: ledgerStatement.totalCredit,
            currentBalance: ledgerStatement.closingBalance,
            overdueAmount: outstandingSales
                .filter((sale) => sale.status === "OVERDUE")
                .reduce((sum, sale) => sum + Number(sale.remainingAmount), 0),
        },
    };

    const response = new CustomResponse(
        200,
        "Customer statement generated successfully",
        {
            statement,
        }
    );
    res.status(response.statusCode).json(response);
});

export const getCustomerAnalytics = asyncHandler(async (req, res) => {
    const userId = req.user?.userId;
    const { startDate, endDate, city, tags } = req.query;

    const start = startDate
        ? new Date(startDate as string)
        : new Date(new Date().getFullYear(), new Date().getMonth(), 1);
    const end = endDate ? new Date(endDate as string) : new Date();

    const whereClause: any = {
        userId,
        date: { gte: start, lte: end },
        status: { not: "CANCELLED" },
    };

    if (city) {
        whereClause.customer = {
            city: { contains: city as string, mode: "insensitive" },
        };
    }

    // Get overall customer statistics
    const [salesStats, receiptStats, customerStats, topCustomers] =
        await Promise.all([
            // Sales to customers
            prisma.sale.aggregate({
                where: whereClause,
                _sum: { amount: true, remainingAmount: true },
                _count: true,
                _avg: { amount: true },
            }),

            // Receipts from customers
            prisma.saleReceipt.aggregate({
                where: {
                    userId,
                    date: { gte: start, lte: end },
                },
                _sum: { amount: true },
                _count: true,
            }),

            // Customer demographics
            prisma.customer.findMany({
                where: {
                    userId,
                    isActive: true,
                    ...(city
                        ? {
                              city: {
                                  contains: city as string,
                                  mode: "insensitive",
                              },
                          }
                        : {}),
                    ...(tags
                        ? {
                              tags: {
                                  hasSome: Array.isArray(tags)
                                      ? (tags as string[])
                                      : [tags as string],
                              },
                          }
                        : {}),
                },
                select: {
                    city: true,
                    tags: true,
                    creditLimit: true,
                    createdAt: true,
                },
            }),

            // Top customers by sales
            prisma.sale.groupBy({
                by: ["customerId"],
                where: whereClause,
                _sum: { amount: true, remainingAmount: true },
                _count: true,
                orderBy: { _sum: { amount: "desc" } },
                take: 10,
            }),
        ]);

    // Get customer details
    const customerIds = topCustomers.map((tc) => tc.customerId);
    const customers = await prisma.customer.findMany({
        where: { id: { in: customerIds } },
        select: { id: true, name: true, city: true, tags: true },
    });

    const topCustomersWithDetails = topCustomers.map((tc) => {
        const customer = customers.find((c) => c.id === tc.customerId);
        return {
            customerId: tc.customerId,
            customerName: customer?.name || "Unknown",
            city: customer?.city,
            tags: customer?.tags,
            totalSales: tc._sum.amount || 0,
            outstandingAmount: tc._sum.remainingAmount || 0,
            saleCount: tc._count,
            collectionRate: tc._sum.amount
                ? ((tc._sum.amount - (tc._sum.remainingAmount || 0)) /
                      tc._sum.amount) *
                  100
                : 0,
        };
    });

    // Geographic analysis
    const cityBreakdown = customerStats.reduce(
        (acc: Record<string, number>, customer) => {
            const city = customer.city || "Unknown";
            acc[city] = (acc[city] || 0) + 1;
            return acc;
        },
        {}
    );

    // Customer segmentation by sales volume
    const customerSegmentation = await Promise.all([
        // High value customers (>50k)
        prisma.sale.groupBy({
            by: ["customerId"],
            where: whereClause,
            having: { amount: { _sum: { gt: 50000 } } },
            _count: true,
        }),
        // Medium value customers (10k-50k)
        prisma.sale.groupBy({
            by: ["customerId"],
            where: whereClause,
            having: {
                amount: {
                    _sum: { gte: 10000, lte: 50000 },
                },
            },
            _count: true,
        }),
    ]);

    // Customer acquisition trends
    const acquisitionTrends = customerStats.reduce(
        (acc: Record<string, number>, customer) => {
            const monthKey = customer.createdAt.toISOString().substring(0, 7); // YYYY-MM
            acc[monthKey] = (acc[monthKey] || 0) + 1;
            return acc;
        },
        {}
    );

    const response = new CustomResponse(
        200,
        "Customer analytics retrieved successfully",
        {
            period: {
                startDate: start.toISOString(),
                endDate: end.toISOString(),
            },
            overview: {
                totalCustomers: customerStats.length,
                totalSales: salesStats._sum.amount || 0,
                totalReceived: receiptStats._sum.amount || 0,
                totalOutstanding: salesStats._sum.remainingAmount || 0,
                averageSaleValue: salesStats._avg.amount || 0,
                collectionRate: salesStats._sum.amount
                    ? ((receiptStats._sum.amount || 0) /
                          salesStats._sum.amount) *
                      100
                    : 0,
            },
            topCustomers: topCustomersWithDetails,
            demographics: {
                cityBreakdown,
                acquisitionTrends: Object.entries(acquisitionTrends)
                    .sort(([a], [b]) => a.localeCompare(b))
                    .map(([month, count]) => ({ month, newCustomers: count })),
            },
            segmentation: {
                highValue: customerSegmentation[0]?.length || 0,
                mediumValue: customerSegmentation[1]?.length || 0,
                lowValue: Math.max(
                    0,
                    customerStats.length -
                        (customerSegmentation[0]?.length || 0) -
                        (customerSegmentation[1]?.length || 0)
                ),
            },
        }
    );
    res.status(response.statusCode).json(response);
});

export const getCustomerLifetimeValue = asyncHandler(async (req, res) => {
    const userId = req.user?.userId;
    const { customerId, months = 12 } = req.query;

    if (!customerId) {
        throw new CustomError(400, "Customer ID is required");
    }

    // Verify customer belongs to user
    const customer = await prisma.customer.findFirst({
        where: { id: customerId as string, userId },
        select: { id: true, name: true, createdAt: true },
    });

    if (!customer) {
        throw new CustomError(404, "Customer not found");
    }

    const endDate = new Date();
    const startDate = new Date();
    startDate.setMonth(startDate.getMonth() - Number(months));

    // Get customer's sales and payment history
    const [salesHistory, receiptHistory] = await Promise.all([
        prisma.sale.findMany({
            where: {
                customerId: customerId as string,
                date: { gte: startDate, lte: endDate },
                status: { not: "CANCELLED" },
            },
            select: {
                date: true,
                amount: true,
                remainingAmount: true,
                items: true,
            },
            orderBy: { date: "asc" },
        }),

        prisma.saleReceipt.findMany({
            where: {
                customerId: customerId as string,
                date: { gte: startDate, lte: endDate },
            },
            select: {
                date: true,
                amount: true,
                method: true,
            },
            orderBy: { date: "asc" },
        }),
    ]);

    // Calculate lifetime metrics
    const totalSales = salesHistory.reduce(
        (sum, sale) => sum + Number(sale.amount),
        0
    );
    const totalReceipts = receiptHistory.reduce(
        (sum, receipt) => sum + Number(receipt.amount),
        0
    );
    const totalOutstanding = salesHistory.reduce(
        (sum, sale) => sum + Number(sale.remainingAmount),
        0
    );

    // Calculate customer behavior patterns
    const purchaseFrequency = salesHistory.length / Number(months);
    const averageOrderValue =
        salesHistory.length > 0 ? totalSales / salesHistory.length : 0;
    const paymentFrequency = receiptHistory.length / Number(months);

    // Monthly trends
    const monthlyData: Record<
        string,
        { sales: number; receipts: number; orders: number }
    > = {};

    salesHistory.forEach((sale) => {
        const monthKey = sale.date.toISOString().substring(0, 7);
        if (!monthlyData[monthKey]) {
            monthlyData[monthKey] = { sales: 0, receipts: 0, orders: 0 };
        }
        monthlyData[monthKey].sales += Number(sale.amount);
        monthlyData[monthKey].orders += 1;
    });

    receiptHistory.forEach((receipt) => {
        const monthKey = receipt.date.toISOString().substring(0, 7);
        if (!monthlyData[monthKey]) {
            monthlyData[monthKey] = { sales: 0, receipts: 0, orders: 0 };
        }
        monthlyData[monthKey].receipts += Number(receipt.amount);
    });

    const monthlyTrends = Object.entries(monthlyData)
        .sort(([a], [b]) => a.localeCompare(b))
        .map(([month, data]) => ({
            month,
            sales: data.sales,
            receipts: data.receipts,
            orders: data.orders,
            averageOrderValue: data.orders > 0 ? data.sales / data.orders : 0,
        }));

    // Calculate customer lifetime value (CLV) prediction
    const averageMonthlyValue =
        monthlyTrends.length > 0
            ? monthlyTrends.reduce((sum, month) => sum + month.sales, 0) /
              monthlyTrends.length
            : 0;

    const customerLifespan = Math.max(
        1,
        (new Date().getTime() - customer.createdAt.getTime()) /
            (1000 * 60 * 60 * 24 * 30.44)
    ); // months
    const predictedCLV = averageMonthlyValue * 36; // Predict 3 years

    const response = new CustomResponse(
        200,
        "Customer lifetime value retrieved successfully",
        {
            customer: {
                id: customer.id,
                name: customer.name,
                customerSince: customer.createdAt.toISOString(),
                lifespanMonths: Math.round(customerLifespan * 100) / 100,
            },
            period: {
                startDate: startDate.toISOString(),
                endDate: endDate.toISOString(),
                months: Number(months),
            },
            lifetimeMetrics: {
                totalSales: totalSales,
                totalReceipts: totalReceipts,
                totalOutstanding: totalOutstanding,
                netLifetimeValue: totalReceipts,
                collectionRate:
                    totalSales > 0 ? (totalReceipts / totalSales) * 100 : 0,
            },
            behaviorPatterns: {
                purchaseFrequency: Math.round(purchaseFrequency * 100) / 100, // purchases per month
                averageOrderValue: Math.round(averageOrderValue * 100) / 100,
                paymentFrequency: Math.round(paymentFrequency * 100) / 100, // payments per month
                totalTransactions: salesHistory.length + receiptHistory.length,
            },
            predictions: {
                predictedLifetimeValue: Math.round(predictedCLV * 100) / 100,
                averageMonthlyValue:
                    Math.round(averageMonthlyValue * 100) / 100,
                customerSegment:
                    averageMonthlyValue > 10000
                        ? "High Value"
                        : averageMonthlyValue > 2000
                          ? "Medium Value"
                          : "Low Value",
            },
            monthlyTrends,
        }
    );
    res.status(response.statusCode).json(response);
});

import {
    CustomerCreatedEvent,
    CustomerDeletedEvent,
    CustomerUpdatedEvent,
} from "@repo/common-backend/interfaces";
import { Subjects } from "@repo/common/subjects";
import { KafkaPublisher } from "@repo/common-backend/kafka";
import { TopicNames } from "@repo/common/topics";

export class CustomerCreatedPublisher extends KafkaPublisher<CustomerCreatedEvent> {
    subject = Subjects.CustomerCreated as const;
    topic = TopicNames.CUSTOMER_EVENTS;

    protected generateMessageKey(data: CustomerCreatedEvent["data"]): string {
        return `${data.email} created by -> ${data.createdBy}`;
    }
}

export class CustomerUpdatedPublisher extends KafkaPublisher<CustomerUpdatedEvent> {
    subject = Subjects.CustomerUpdated as const;
    topic = TopicNames.CUSTOMER_EVENTS;

    protected generateMessageKey(data: CustomerUpdatedEvent["data"]): string {
        return `${data.id} updated by -> ${data.updatedBy}`;
    }
}

export class CustomerDeletedPublisher extends KafkaPublisher<CustomerDeletedEvent> {
    subject = Subjects.CustomerDeleted as const;
    topic = TopicNames.CUSTOMER_EVENTS;

    protected generateMessageKey(data: CustomerDeletedEvent["data"]): string {
        return `${data.email} deleted by -> ${data.deletedBy}`;
    }
}

// apps/accounts/src/routes/customerRoutes.ts
import express from "express";
import {
    createCustomer,
    getCustomers,
    getCustomerById,
    updateCustomer,
    deleteCustomer,
    getCustomerLedger,
    getCustomerStatement,
    getCustomerAnalytics,
    getCustomerLifetimeValue,
} from "../controllers/customerController";
import { authenticate } from "@repo/common-backend/middleware";
import {
    validateCreateCustomer,
    validateUpdateCustomer,
    validateGetCustomers,
    validateCustomerLedger,
} from "@repo/common-backend/validators";

const router = express.Router();

// Customer CRUD operations
router.get("/", authenticate, validateGetCustomers, getCustomers);
router.post("/", authenticate, validateCreateCustomer, createCustomer);
router.get("/:id", authenticate, getCustomerById);
router.put("/:id", authenticate, validateUpdateCustomer, updateCustomer);
router.delete("/:id", authenticate, deleteCustomer);

// Customer ledger and statements
router.get(
    "/:id/ledger",
    authenticate,
    validateCustomerLedger,
    getCustomerLedger
);
router.get("/:id/statement", authenticate, getCustomerStatement);

// Analytics endpoints
router.get("/analytics", authenticate, getCustomerAnalytics);
router.get("/:id/lifetime-value", authenticate, getCustomerLifetimeValue);

export default router;

// packages/common/src/schemas/customer.schemas.ts
import { z } from "zod";
import { PaginationSchema } from "./baseSchemas";

export const CreateCustomerSchema = z.object({
    name: z.string().min(1, "Customer name is required"),
    phone: z.string().optional(),
    email: z.string().email().optional().or(z.literal("")),
    address: z.string().optional(),
    city: z.string().optional(),
    state: z.string().optional(),
    pincode: z.string().optional(),
    gstNumber: z.string().optional(),
    creditLimit: z.number().min(0).default(0),
    dateOfBirth: z.string().datetime().optional(),
    anniversary: z.string().datetime().optional(),
    preferredContact: z.enum(["email", "phone", "whatsapp"]).optional(),
    tags: z.array(z.string()).default([]),
    notes: z.string().optional(),
});

export const UpdateCustomerSchema = CreateCustomerSchema.partial();

// export const CustomerQuerySchema = z.object({
//     page: z.coerce.number().min(1).default(1),
//     limit: z.coerce.number().min(1).max(100).default(10),
//     search: z.string().optional(),
//     sortBy: z.string().optional(),
//     sortOrder: z.enum(["asc", "desc"]).default("desc"),
//     isActive: z.boolean().optional(),
//     city: z.string().optional(),
//     state: z.string().optional(),
//     tags: z.array(z.string()).optional(),
// });

export const CustomerQuerySchema = PaginationSchema.extend({
    name: z.string().optional(),
    phone: z.string().optional(),
    email: z.string().optional(),
    city: z.string().optional(),
    isActive: z.coerce.boolean().optional(),
    tags: z.string().optional(), // comma separated tags
});

export type CreateCustomerType = z.infer<typeof CreateCustomerSchema>;
export type UpdateCustomerType = z.infer<typeof UpdateCustomerSchema>;
export type CustomerQueryType = z.infer<typeof CustomerQuerySchema>;

// packages/common-backend/src/events/interfaces/customerInterfaces.ts

import { BaseEvent } from "./base-interfaces";
import { Subjects } from "@repo/common/subjects";

// ========================================
// CUSTOMER LIFECYCLE EVENTS
// ========================================

export interface CustomerCreatedEvent extends BaseEvent {
    subject: Subjects.CustomerCreated;
    data: {
        id: string;
        name: string;
        phone?: string | null;
        email?: string | null;
        address?: string | null;
        city?: string | null;
        state?: string | null;
        pincode?: string | null;
        gstNumber?: string | null;
        creditLimit: number;
        dateOfBirth?: string | null;
        anniversary?: string | null;
        preferredContact?: string | null;
        tags: string[];
        notes?: string | null;
        createdBy: string;
        createdAt: string;
        userId: string;
    };
}

export interface CustomerUpdatedEvent extends BaseEvent {
    subject: Subjects.CustomerUpdated;
    data: {
        id: string;
        updatedAt: string;
        changes: Record<
            string,
            {
                oldValue: any;
                newValue: any;
            }
        >;
        updatedBy: string;
        nameChanged?: boolean;
        contactChanged?: boolean;
        creditLimitChanged?: boolean;
        addressChanged?: boolean;
    };
}

export interface CustomerDeletedEvent extends BaseEvent {
    subject: Subjects.CustomerDeleted;
    data: {
        id: string;
        name: string;
        email?: string | null;
        phone?: string | null;
        deletedAt: string;
        deletedBy: string;
        hasOutstandingBalance?: boolean;
        finalBalance?: number;
        reason?: string;
    };
}

export interface CustomerActivatedEvent extends BaseEvent {
    subject: Subjects.CustomerActivated;
    data: {
        id: string;
        name: string;
        activatedBy: string;
        activatedAt: string;
        reason?: string;
        previousStatus?: string;
    };
}

export interface CustomerDeactivatedEvent extends BaseEvent {
    subject: Subjects.CustomerDeactivated;
    data: {
        id: string;
        name: string;
        deactivatedBy: string;
        deactivatedAt: string;
        reason?: string;
        hasOutstandingBalance?: boolean;
        outstandingAmount?: number;
    };
}

// ========================================
// CUSTOMER CONTACT EVENTS
// ========================================

export interface CustomerContactUpdatedEvent extends BaseEvent {
    subject: Subjects.CustomerContactUpdated;
    data: {
        id: string;
        name: string;
        contactChanges: {
            phone?: {
                oldValue?: string;
                newValue?: string;
            };
            email?: {
                oldValue?: string;
                newValue?: string;
            };
            address?: {
                oldValue?: string;
                newValue?: string;
            };
        };
        updatedBy: string;
        updatedAt: string;
        notificationsSent?: string[]; // channels where update notifications were sent
    };
}

// ========================================
// CUSTOMER CREDIT EVENTS
// ========================================

export interface CustomerCreditLimitUpdatedEvent extends BaseEvent {
    subject: Subjects.CustomerCreditLimitUpdated;
    data: {
        customerId: string;
        customerName: string;
        oldLimit: number;
        newLimit: number;
        changeAmount: number;
        changePercentage: number;
        reason: string;
        approvedBy?: string;
        updatedBy: string;
        updatedAt: string;
        currentBalance?: number;
        availableCredit?: number;
    };
}

export interface CustomerCreditLimitExceededEvent extends BaseEvent {
    subject: Subjects.CustomerCreditLimitExceeded;
    data: {
        customerId: string;
        customerName: string;
        creditLimit: number;
        currentBalance: number;
        excessAmount: number;
        transactionId?: string;
        transactionType?: "SALE" | "INVOICE" | "ADJUSTMENT";
        transactionAmount?: number;
        detectedAt: string;
        alertLevel: "WARNING" | "CRITICAL";
        actionTaken?: "BLOCKED" | "ALLOWED_WITH_APPROVAL" | "REQUIRES_REVIEW";
    };
}

export interface CustomerCreditLimitWarningEvent extends BaseEvent {
    subject: Subjects.CustomerCreditLimitWarning;
    data: {
        customerId: string;
        customerName: string;
        creditLimit: number;
        currentBalance: number;
        utilizationPercentage: number;
        warningThreshold: number;
        remainingCredit: number;
        warningLevel: "75%" | "90%" | "95%";
        detectedAt: string;
        recommendedAction?: string;
    };
}

// ========================================
// CUSTOMER LIFECYCLE MILESTONES
// ========================================

export interface CustomerFirstVisitEvent extends BaseEvent {
    subject: Subjects.CustomerFirstVisit;
    data: {
        customerId: string;
        customerName: string;
        visitDate: string;
        visitType: "PHYSICAL" | "ONLINE" | "PHONE";
        source?: string;
        referredBy?: string;
        initialInterest?: string[];
        staffAssigned?: string;
        welcomeMessageSent?: boolean;
    };
}

// export interface CustomerBecameVIPEvent extends BaseEvent {
//     subject: Subjects.CustomerBecameVIP;
//     data: {
//         customerId: string;
//         customerName: string;
//         totalPurchases: number;
//         totalAmount: number;
//         averageOrderValue: number;
//         memberSince: string;
//         promotedAt: string;
//         promotionCriteria: {
//             totalSpent?: number;
//             totalOrders?: number;
//             averageOrderValue?: number;
//             loyaltyPeriod?: number;
//         };
//         vipBenefits: string[];
//         notificationSent?: boolean;
//     };
// }

// export interface CustomerReturnVisitEvent extends BaseEvent {
//     subject: Subjects.CustomerReturnVisit;
//     data: {
//         customerId: string;
//         customerName: string;
//         visitDate: string;
//         visitNumber: number;
//         daysSinceLastVisit: number;
//         visitType: "PHYSICAL" | "ONLINE" | "PHONE";
//         purchaseMade?: boolean;
//         purchaseAmount?: number;
//         engagementLevel: "HIGH" | "MEDIUM" | "LOW";
//     };
// }

// export interface CustomerLongTimeNoVisitEvent extends BaseEvent {
//     subject: Subjects.CustomerLongTimeNoVisit;
//     data: {
//         customerId: string;
//         customerName: string;
//         lastVisitDate: string;
//         daysSinceLastVisit: number;
//         lastPurchaseDate?: string;
//         daysSinceLastPurchase?: number;
//         totalLifetimeValue: number;
//         riskLevel: "LOW" | "MEDIUM" | "HIGH";
//         recommendedAction:
//             | "REMINDER"
//             | "SPECIAL_OFFER"
//             | "PERSONAL_CALL"
//             | "WIN_BACK_CAMPAIGN";
//         detectedAt: string;
//     };
// }

// ========================================
// CUSTOMER LOYALTY EVENTS
// ========================================

export interface CustomerLoyaltyPointsEarnedEvent extends BaseEvent {
    subject: Subjects.CustomerLoyaltyPointsEarned;
    data: {
        customerId: string;
        customerName: string;
        pointsEarned: number;
        totalPoints: number;
        earnedFrom:
            | "PURCHASE"
            | "REFERRAL"
            | "BONUS"
            | "BIRTHDAY"
            | "ANNIVERSARY"
            | "REVIEW";
        referenceId?: string;
        referenceType?: "SALE" | "INVOICE" | "REFERRAL";
        multiplier?: number;
        campaignId?: string;
        earnedAt: string;
        expiryDate?: string;
    };
}

export interface CustomerLoyaltyPointsRedeemedEvent extends BaseEvent {
    subject: Subjects.CustomerLoyaltyPointsRedeemed;
    data: {
        customerId: string;
        customerName: string;
        pointsRedeemed: number;
        remainingPoints: number;
        redeemValue: number;
        redemptionType: "DISCOUNT" | "CASHBACK" | "GIFT" | "SERVICE";
        saleId?: string;
        discountAmount?: number;
        redeemedAt: string;
        staffProcessed?: string;
    };
}

// export interface CustomerReferralMadeEvent extends BaseEvent {
//     subject: Subjects.CustomerReferralMade;
//     data: {
//         referrerCustomerId: string;
//         referrerName: string;
//         referredCustomerId: string;
//         referredName: string;
//         referralCode?: string;
//         referralChannel:
//             | "WORD_OF_MOUTH"
//             | "SOCIAL_MEDIA"
//             | "EMAIL"
//             | "WHATSAPP"
//             | "OTHER";
//         referralDate: string;
//         referredCustomerFirstPurchase?: boolean;
//         referralRewardEarned?: number;
//         referralStatus: "PENDING" | "QUALIFIED" | "REWARDED";
//     };
// }

// // ========================================
// // CUSTOMER BEHAVIOR EVENTS
// // ========================================

// export interface CustomerPreferenceUpdatedEvent extends BaseEvent {
//     subject: Subjects.CustomerPreferenceUpdated;
//     data: {
//         customerId: string;
//         customerName: string;
//         preferenceType:
//             | "FABRIC"
//             | "COLOR"
//             | "STYLE"
//             | "PRICE_RANGE"
//             | "BRAND"
//             | "COMMUNICATION";
//         preferences: {
//             fabrics?: string[];
//             colors?: string[];
//             styles?: string[];
//             priceRange?: {
//                 min: number;
//                 max: number;
//             };
//             brands?: string[];
//             communicationChannel?: "EMAIL" | "WHATSAPP" | "SMS" | "PHONE";
//             frequency?: "DAILY" | "WEEKLY" | "MONTHLY" | "SPECIAL_EVENTS";
//         };
//         updatedBy?: string;
//         updatedAt: string;
//         source:
//             | "CUSTOMER_REQUEST"
//             | "PURCHASE_BEHAVIOR"
//             | "SURVEY"
//             | "STAFF_OBSERVATION";
//     };
// }

// export interface CustomerComplaintReceivedEvent extends BaseEvent {
//     subject: Subjects.CustomerComplaintReceived;
//     data: {
//         customerId: string;
//         customerName: string;
//         complaintId: string;
//         complaintType:
//             | "PRODUCT_QUALITY"
//             | "SERVICE"
//             | "BILLING"
//             | "DELIVERY"
//             | "STAFF_BEHAVIOR"
//             | "OTHER";
//         severity: "LOW" | "MEDIUM" | "HIGH" | "CRITICAL";
//         description: string;
//         relatedTransaction?: {
//             type: "SALE" | "INVOICE";
//             id: string;
//             number: string;
//             date: string;
//         };
//         channel: "PHONE" | "EMAIL" | "WHATSAPP" | "IN_PERSON" | "SOCIAL_MEDIA";
//         receivedBy: string;
//         receivedAt: string;
//         status:
//             | "NEW"
//             | "ACKNOWLEDGED"
//             | "INVESTIGATING"
//             | "RESOLVED"
//             | "CLOSED";
//         priority: "LOW" | "MEDIUM" | "HIGH" | "URGENT";
//     };
// }

// export interface CustomerFeedbackReceivedEvent extends BaseEvent {
//     subject: Subjects.CustomerFeedbackReceived;
//     data: {
//         customerId: string;
//         customerName: string;
//         feedbackId: string;
//         feedbackType:
//             | "PRODUCT_REVIEW"
//             | "SERVICE_RATING"
//             | "SUGGESTION"
//             | "TESTIMONIAL"
//             | "GENERAL";
//         rating?: number; // 1-5 scale
//         feedback: string;
//         relatedTransaction?: {
//             type: "SALE" | "INVOICE";
//             id: string;
//             number: string;
//         };
//         channel: "EMAIL" | "WHATSAPP" | "PHONE" | "IN_PERSON" | "ONLINE_FORM";
//         isPositive: boolean;
//         tags?: string[];
//         receivedAt: string;
//         requiresResponse?: boolean;
//         publicReview?: boolean;
//     };
// }

// ========================================
// EXPORT ALL CUSTOMER EVENT TYPES
// ========================================

export type CustomerEventTypes =
    | CustomerCreatedEvent
    | CustomerUpdatedEvent
    | CustomerDeletedEvent
    | CustomerActivatedEvent
    | CustomerDeactivatedEvent
    | CustomerContactUpdatedEvent
    | CustomerCreditLimitUpdatedEvent
    | CustomerCreditLimitExceededEvent
    | CustomerCreditLimitWarningEvent
    | CustomerFirstVisitEvent
    // | CustomerBecameVIPEvent
    // | CustomerReturnVisitEvent
    // | CustomerLongTimeNoVisitEvent
    | CustomerLoyaltyPointsEarnedEvent
    | CustomerLoyaltyPointsRedeemedEvent;
// | CustomerReferralMadeEvent
// | CustomerPreferenceUpdatedEvent
// | CustomerComplaintReceivedEvent
// | CustomerFeedbackReceivedEvent;

// ========================================
// CUSTOMER VALIDATORS
// ========================================

export const validateCreateCustomer = async (
    req: Request,
    res: Response,
    next: NextFunction
) => {
    try {
        req.parsedBody = await BusinessSchemas.CreateCustomer.parseAsync(
            req.body
        );
        req.body = req.parsedBody;
        next();
    } catch (error) {
        if (error instanceof ZodError) {
            const errors = formatZodErrors(error);
            throw new CustomError(
                400,
                "Customer creation validation failed",
                errors as any
            );
        }
        next(error);
    }
};

export const validateUpdateCustomer = async (
    req: Request,
    res: Response,
    next: NextFunction
) => {
    try {
        req.parsedBody = await BusinessSchemas.UpdateCustomer.parseAsync(
            req.body
        );
        req.body = req.parsedBody;
        next();
    } catch (error) {
        if (error instanceof ZodError) {
            const errors = formatZodErrors(error);
            throw new CustomError(
                400,
                "Customer update validation failed",
                errors as any
            );
        }
        next(error);
    }
};

export const validateCustomerQuery = async (
    req: Request,
    res: Response,
    next: NextFunction
) => {
    try {
        req.parsedQuery = await QuerySchemas.CustomerQuery.parseAsync(
            req.query
        );
        next();
    } catch (error) {
        if (error instanceof ZodError) {
            const errors = formatZodErrors(error);
            throw new CustomError(
                400,
                "Customer query validation failed",
                errors as any
            );
        }
        next(error);
    }
};
```
