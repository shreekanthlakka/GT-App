```prisma
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}


// ========================================
// USER MANAGEMENT
// ========================================

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String
  phone     String?
  password  String
  role      UserRole @default(OWNER)
  isActive  Boolean  @default(true)

  // Security fields
  twoFactorSecret     String?
  twoFactorEnabled    Boolean   @default(false)
  ipWhitelist         Json?     // Array of allowed IP addresses
  failedLoginAttempts Int       @default(0)
  lockedUntil         DateTime?
  lastLoginAt         DateTime?
  lastLoginIP         String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  parties          Party[]
  customers        Customer[]
  invoices         Invoice[]
  invoicePayments  InvoicePayment[]
  saleReceipts     SaleReceipt[]
  sales            Sale[]
  ledgerEntries    LedgerEntry[]
  ocrData          OCRData[]
  reminders        Reminder[]
  notifications    Notification[]
  inventoryItems   InventoryItem[]
  orders           Order[]
  userSessions     UserSession[]
  backups          Backup[]
  restores         Restore[]
  backupSchedule   BackupSchedule?
  auditLogs        AuditLog[]
  stockMovements   StockMovement[]

  @@map("users")
}

model UserSession {
  id           String   @id @default(cuid())
  userId       String
  sessionToken String   @unique
  refreshToken String   @unique
  expiresAt    DateTime
  deviceInfo   Json?    // Device information
  ipAddress    String?
  userAgent    String?
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_sessions")
}

// ========================================
// ECOMMERCE USERS (Public App Users)
// ========================================

model EcommerceUser {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String
  phone     String?
  password  String?  // Nullable for social login users

  // Profile information
  dateOfBirth DateTime?
  gender      String?  // MALE, FEMALE, OTHER
  avatar      String?  // Profile picture URL

  // Address information
  addresses   Json     @default("[]") // [{type: 'home|office', name, phone, address, city, state, pincode, isDefault}]

  // Authentication & Security
  emailVerified     Boolean   @default(false)
  phoneVerified     Boolean   @default(false)
  emailVerificationToken String?
  phoneVerificationToken String?
  passwordResetToken     String?
  passwordResetExpiry    DateTime?

  // Social login
  googleId          String?
  facebookId        String?

  // Account status
  isActive          Boolean   @default(true)
  isBlocked         Boolean   @default(false)
  blockedReason     String?
  blockedAt         DateTime?

  // Preferences
  preferences       Json      @default("{}") // {newsletter: true, sms: true, whatsapp: true, language: 'en'}

  // Marketing
  referralCode      String?   @unique
  referredBy        String?

  // Metadata
  lastLoginAt       DateTime?
  lastLoginIP       String?
  signupSource      String?   // WEBSITE, MOBILE_APP, SOCIAL, REFERRAL

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  orders            Order[]
  ecommerceUserSessions EcommerceUserSession[]
  reviews           Review[]
  wishlistItems     WishlistItem[]
  cartItems         CartItem[]

  @@index([email])
  @@index([phone])
  @@index([referralCode])
  @@index([isActive])
  @@map("ecommerce_users")
}

model EcommerceUserSession {
  id           String   @id @default(cuid())
  userId       String
  sessionToken String   @unique
  refreshToken String   @unique
  expiresAt    DateTime
  deviceInfo   Json?    // {type: 'mobile|desktop', os, browser, version}
  ipAddress    String?
  userAgent    String?
  isActive     Boolean  @default(true)

  ecommerceUser EcommerceUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([userId])
  @@index([sessionToken])
  @@map("ecommerce_user_sessions")
}

// ========================================
// BUSINESS ENTITIES
// ========================================

model Customer {
  id          String  @id @default(cuid())
  name        String
  phone       String?
  email       String?
  address     String?
  city        String?
  state       String?
  pincode     String?
  gstNumber   String?
  creditLimit Decimal @default(0) @db.Decimal(12, 2)

  // Additional fields
  dateOfBirth      DateTime?
  anniversary      DateTime?
  preferredContact String?    // email, phone, whatsapp
  tags             String[]   // VIP, Regular, New, etc.
  notes            String?
  isActive         Boolean    @default(true)

  userId      String
  user        User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  sales         Sale[]
  saleReceipts  SaleReceipt[]
  ledger        LedgerEntry[]
  reminders     Reminder[]
  notifications Notification[]
  orders        Order[]

  @@index([userId])
  @@index([name])
  @@index([phone])
  @@index([email])
  @@map("customers")
}

model Party {
  id            String  @id @default(cuid())
  name          String
  gstNo         String?
  panNo         String?
  phone         String?
  email         String?
  address       String?
  city          String?
  state         String?
  pincode       String?
  contactPerson String?
  bankDetails   Json?   // {bankName, accountNo, ifsc, branch}

  // Additional fields
  category      String?  // Manufacturer, Distributor, Wholesaler
  paymentTerms  Int?     // Payment terms in days
  creditLimit   Decimal  @default(0) @db.Decimal(12, 2)
  taxId         String?
  website       String?
  notes         String?
  isActive      Boolean  @default(true)

  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  invoices         Invoice[]
  invoicePayments  InvoicePayment[]
  ledger           LedgerEntry[]
  notifications    Notification[]

  @@unique([gstNo, userId], name: "unique_gst_per_user")
  @@index([userId])
  @@index([name])
  @@index([gstNo])
  @@map("parties")
}

// ========================================
// INVENTORY MANAGEMENT
// ========================================

model InventoryItem {
  id          String   @id @default(cuid())
  name        String
  description String?
  sku         String?  @unique
  barcode     String?  @unique
  category    String
  subCategory String?
  brand       String?

  // Pricing
  sellingPrice Decimal  @db.Decimal(10, 2)
  costPrice    Decimal? @db.Decimal(10, 2)
  mrp          Decimal? @db.Decimal(10, 2)

  // Stock management
  currentStock    Int      @default(0)
  minimumStock    Int      @default(0)
  maximumStock    Int?
  reorderLevel    Int?
  unit            String   @default("PCS") // PCS, MTR, KG, etc.

  // Textile specific fields
  fabric          String?  // Cotton, Silk, Polyester, etc.
  gsm             Int?     // Grams per square meter
  width           Decimal? @db.Decimal(8, 2) // Width in inches/cm
  color           String?
  design          String?
  pattern         String?
  weaveType       String?  // Plain, Twill, Satin, etc.

  // Product details
  images          Json     @default("[]")
  attributes      Json     @default("{}")

  // Tax and compliance
  hsnCode         String?
  taxRate         Decimal? @db.Decimal(5, 2)

  // Storage and supplier info
  location        String?  // Storage location in shop
  supplier        String?
  leadTime        Int?     // Days
  lastPurchaseDate DateTime?
  lastPurchasePrice Decimal? @db.Decimal(10, 2)

  isActive        Boolean  @default(true)

  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  orderItems      OrderItem[]
  stockMovements  StockMovement[]
  reviews         Review[]
  wishlistItems   WishlistItem[]
  cartItems       CartItem[]

  @@index([userId])
  @@index([category])
  @@index([isActive])
  @@index([sku])
  @@index([barcode])
  @@index([currentStock])
  @@map("inventory_items")
}

model StockMovement {
  id            String       @id @default(cuid())
  inventoryItemId String
  inventoryItem   InventoryItem @relation(fields: [inventoryItemId], references: [id], onDelete: Cascade)

  type          MovementType // IN, OUT, ADJUSTMENT, TRANSFER
  quantity      Int
  previousStock Int
  newStock      Int
  reason        String?
  reference     String?      // Sale ID, Purchase ID, etc.
  batchNumber   String?      // For textile rolls/batches

  // Additional details
  unitPrice     Decimal?     @db.Decimal(10, 2)
  totalValue    Decimal?     @db.Decimal(12, 2)
  notes         String?

  userId        String
  user          User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt     DateTime     @default(now())

  @@index([inventoryItemId])
  @@index([userId])
  @@index([type])
  @@index([createdAt])
  @@map("stock_movements")
}

// ========================================
// SALES TRANSACTIONS
// ========================================

model Sale {
  id              String     @id @default(cuid())
  voucherId       String     @unique
  saleNo          String
  date            DateTime
  amount          Decimal    @db.Decimal(12, 2)
  paidAmount      Decimal    @default(0) @db.Decimal(12, 2)
  remainingAmount Decimal    @db.Decimal(12, 2)
  status          SaleStatus @default(PENDING)

  // Sale items - storing as JSON for flexibility in textile business
  items           Json       // [{itemName, itemType, design, color, price, quantity, total, hsnCode, unit}]

  // Financial details
  taxAmount       Decimal?   @db.Decimal(12, 2)
  discountAmount  Decimal?   @default(0) @db.Decimal(12, 2)
  roundOffAmount  Decimal?   @default(0) @db.Decimal(12, 2)

  // Additional sale details
  salesPerson     String?
  deliveryDate    DateTime?
  deliveryAddress String?
  transportation  String?
  vehicleNo       String?
  reference       String?    // Customer's reference
  terms           String?    // Payment terms
  notes           String?

  customerId      String
  customer        Customer   @relation(fields: [customerId], references: [id], onDelete: Cascade)

  userId          String
  user            User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt

  // Relations
  saleReceipts    SaleReceipt[]
  ledger          LedgerEntry[]
  notifications   Notification[]

  @@unique([saleNo, customerId, userId], name: "unique_sale_per_customer")
  @@index([userId])
  @@index([customerId])
  @@index([status])
  @@index([date])
  @@map("sales")
}

// ========================================
// PURCHASE TRANSACTIONS
// ========================================

model Invoice {
  id              String        @id @default(cuid())
  voucherId       String        @unique
  invoiceNo       String
  date            DateTime
  dueDate         DateTime?
  amount          Decimal       @db.Decimal(12, 2)
  paidAmount      Decimal       @default(0) @db.Decimal(12, 2)
  remainingAmount Decimal       @db.Decimal(12, 2)
  status          InvoiceStatus @default(PENDING)

  // Invoice line items - flexible JSON structure for textile purchases
  items           Json?         // [{description, quantity, rate, amount, hsnCode, taxRate}]

  description     String?
  taxAmount       Decimal?      @db.Decimal(12, 2)
  discountAmount  Decimal?      @default(0) @db.Decimal(12, 2)
  roundOffAmount  Decimal?      @default(0) @db.Decimal(12, 2)
  notes           String?

  // Additional invoice fields
  poNumber        String?       // Purchase Order Number
  transportMode   String?
  vehicleNo       String?
  deliveryNote    String?
  supplierRef     String?
  otherRef        String?
  buyersOrderNo   String?
  dispatchedThrough String?
  destination     String?

  partyId         String
  party           Party         @relation(fields: [partyId], references: [id], onDelete: Cascade)

  userId          String
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // Relations
  invoicePayments InvoicePayment[]
  ledger          LedgerEntry[]
  ocrData         OCRData?
  notifications   Notification[]

  @@unique([invoiceNo, partyId, userId], name: "unique_invoice_per_party")
  @@index([userId])
  @@index([partyId])
  @@index([status])
  @@index([date])
  @@index([dueDate])
  @@map("invoices")
}

// ========================================
// PAYMENT TRANSACTIONS
// ========================================

model InvoicePayment {
  id          String        @id @default(cuid())
  voucherId   String        @unique
  amount      Decimal       @db.Decimal(12, 2)
  date        DateTime
  method      PaymentMethod
  reference   String?       // Bank ref, cheque no, UPI transaction ID
  description String?
  status      PaymentStatus @default(COMPLETED)

  // Gateway fields for online payments
  gatewayOrderId   String?
  gatewayPaymentId String?
  transactionId    String?
  failureReason    String?

  // Banking details
  bankName        String?
  chequeNo        String?
  chequeDate      DateTime?
  clearanceDate   DateTime?
  charges         Decimal? @db.Decimal(8, 2)

  // Relations
  partyId     String
  party       Party        @relation(fields: [partyId], references: [id], onDelete: Cascade)

  invoiceId   String?
  invoice     Invoice?     @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  userId      String
  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  // Relations
  ledger        LedgerEntry[]
  ocrData       OCRData?
  notifications Notification[]

  @@index([userId])
  @@index([method])
  @@index([date])
  @@index([partyId])
  @@index([invoiceId])
  @@map("invoice_payments")
}

model SaleReceipt {
  id          String   @id @default(cuid())
  voucherId   String   @unique
  receiptNo   String
  date        DateTime
  amount      Decimal  @db.Decimal(12, 2)
  method      PaymentMethod
  description String?
  reference   String?  // Transaction reference
  imageUrl    String?  // Photo of physical receipt

  // Banking details
  bankName        String?
  chequeNo        String?
  chequeDate      DateTime?
  clearanceDate   DateTime?
  charges         Decimal? @db.Decimal(8, 2)

  // Relations
  customerId  String
  customer    Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  saleId      String?
  sale        Sale?    @relation(fields: [saleId], references: [id], onDelete: Cascade)

  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  ledger        LedgerEntry[]
  ocrData       OCRData?
  notifications Notification[]

  @@unique([receiptNo, customerId, userId], name: "unique_receipt_per_customer")
  @@index([userId])
  @@index([customerId])
  @@index([date])
  @@index([method])
  @@map("sale_receipts")
}

// ========================================
// E-COMMERCE FEATURES
// ========================================

model Review {
  id        String   @id @default(cuid())
  rating    Int      // 1-5 stars
  title     String?
  comment   String?
  images    Json     @default("[]") // Array of image URLs

  // Status
  isVerified Boolean @default(false) // Verified purchase review
  isApproved Boolean @default(false) // Admin approved

  // Relations
  inventoryItemId String
  inventoryItem   InventoryItem @relation(fields: [inventoryItemId], references: [id], onDelete: Cascade)

  ecommerceUserId String
  ecommerceUser   EcommerceUser @relation(fields: [ecommerceUserId], references: [id], onDelete: Cascade)

  orderId     String? // Link to purchase for verified reviews
  order       Order?  @relation(fields: [orderId], references: [id], onDelete: SetNull)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([inventoryItemId])
  @@index([ecommerceUserId])
  @@index([rating])
  @@index([isApproved])
  @@map("reviews")
}

model WishlistItem {
  id        String   @id @default(cuid())

  inventoryItemId String
  inventoryItem   InventoryItem @relation(fields: [inventoryItemId], references: [id], onDelete: Cascade)

  ecommerceUserId String
  ecommerceUser   EcommerceUser @relation(fields: [ecommerceUserId], references: [id], onDelete: Cascade)

  createdAt   DateTime @default(now())

  @@unique([inventoryItemId, ecommerceUserId])
  @@index([ecommerceUserId])
  @@map("wishlist_items")
}

model CartItem {
  id        String   @id @default(cuid())
  quantity  Int      @default(1)

  inventoryItemId String
  inventoryItem   InventoryItem @relation(fields: [inventoryItemId], references: [id], onDelete: Cascade)

  ecommerceUserId String
  ecommerceUser   EcommerceUser @relation(fields: [ecommerceUserId], references: [id], onDelete: Cascade)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([inventoryItemId, ecommerceUserId])
  @@index([ecommerceUserId])
  @@map("cart_items")
}

model Order {
  id             String      @id @default(cuid())
  orderNo        String      @unique
  date           DateTime    @default(now())
  status         OrderStatus @default(PENDING)
  totalAmount    Decimal     @db.Decimal(12, 2)
  paidAmount     Decimal     @default(0) @db.Decimal(12, 2)
  shippingAmount Decimal     @default(0) @db.Decimal(12, 2)
  taxAmount      Decimal     @default(0) @db.Decimal(12, 2)
  discountAmount Decimal     @default(0) @db.Decimal(12, 2)

  shippingAddress Json?      // {name, phone, address, city, state, pincode}
  billingAddress  Json?
  notes          String?

  // Additional fields
  source         String?     // ONLINE, PHONE, WALK_IN, ECOMMERCE
  priority       String?     // HIGH, NORMAL, LOW
  expectedDelivery DateTime?
  actualDelivery   DateTime?
  trackingNumber   String?

  // Relations - Can be either internal customer or ecommerce user
  customerId      String?
  customer        Customer?     @relation(fields: [customerId], references: [id], onDelete: Cascade)

  ecommerceUserId String?
  ecommerceUser   EcommerceUser? @relation(fields: [ecommerceUserId], references: [id], onDelete: Cascade)

  userId         String
  user           User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt

  // Relations
  items          OrderItem[]
  payments       OrderPayment[]
  notifications  Notification[]
  reviews        Review[]

  @@index([userId])
  @@index([customerId])
  @@index([ecommerceUserId])
  @@index([status])
  @@index([date])
  @@map("orders")
}

model OrderItem {
  id        String  @id @default(cuid())
  quantity  Int
  price     Decimal @db.Decimal(10, 2)
  total     Decimal @db.Decimal(12, 2)
  discount  Decimal @default(0) @db.Decimal(8, 2)

  inventoryItemId String
  inventoryItem   InventoryItem @relation(fields: [inventoryItemId], references: [id], onDelete: Cascade)

  orderId   String
  order     Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([orderId])
  @@index([inventoryItemId])
  @@map("order_items")
}

model OrderPayment {
  id               String        @id @default(cuid())
  amount           Decimal       @db.Decimal(12, 2)
  method           PaymentMethod
  status           String        // pending, completed, failed, refunded
  gatewayOrderId   String?       // Razorpay/Stripe order ID
  gatewayPaymentId String?       // Razorpay/Stripe payment ID
  transactionId    String?
  failureReason    String?

  orderId          String
  order            Order         @relation(fields: [orderId], references: [id], onDelete: Cascade)

  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt

  @@index([orderId])
  @@index([status])
  @@map("order_payments")
}

// ========================================
// LEDGER & ACCOUNTING
// ========================================

model LedgerEntry {
  id          String     @id @default(cuid())
  date        DateTime
  description String
  debit       Decimal    @default(0) @db.Decimal(12, 2)
  credit      Decimal    @default(0) @db.Decimal(12, 2)
  balance     Decimal    @db.Decimal(12, 2)
  type        LedgerType
  reference   String?    // Reference to source document

  // Relations (nullable for flexibility)
  partyId     String?
  party       Party?     @relation(fields: [partyId], references: [id], onDelete: Cascade)

  customerId  String?
  customer    Customer?  @relation(fields: [customerId], references: [id], onDelete: Cascade)

  invoiceId   String?
  invoice     Invoice?   @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  saleId      String?
  sale        Sale?      @relation(fields: [saleId], references: [id], onDelete: Cascade)

  invoicePaymentId String?
  invoicePayment   InvoicePayment? @relation(fields: [invoicePaymentId], references: [id], onDelete: Cascade)

  saleReceiptId    String?
  saleReceipt      SaleReceipt?    @relation(fields: [saleReceiptId], references: [id], onDelete: Cascade)

  userId      String
  user        User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  @@index([userId])
  @@index([partyId])
  @@index([customerId])
  @@index([date])
  @@index([type])
  @@map("ledger_entries")
}

// ========================================
// COMMUNICATION & NOTIFICATIONS
// ========================================

model Notification {
  id        String             @id @default(cuid())
  title     String
  message   String
  type      NotificationType
  channel   NotificationChannel
  status    NotificationStatus @default(PENDING)

  // Recipient details
  recipientType String           // CUSTOMER, PARTY, USER
  recipientId   String
  recipientName String
  recipientContact String?

  // Message details
  templateName String?
  templateData Json?

  // Delivery details
  sentAt       DateTime?
  deliveredAt  DateTime?
  readAt       DateTime?
  failureReason String?
  retryCount   Int              @default(0)
  maxRetries   Int              @default(3)

  // External service details
  externalId   String?
  externalData Json?

  // Relations (nullable - notification can be related to any entity)
  partyId    String?
  party      Party?    @relation(fields: [partyId], references: [id], onDelete: Cascade)

  customerId String?
  customer   Customer? @relation(fields: [customerId], references: [id], onDelete: Cascade)

  invoiceId  String?
  invoice    Invoice?  @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  saleId     String?
  sale       Sale?     @relation(fields: [saleId], references: [id], onDelete: Cascade)

  invoicePaymentId String?
  invoicePayment   InvoicePayment? @relation(fields: [invoicePaymentId], references: [id], onDelete: Cascade)

  saleReceiptId    String?
  saleReceipt      SaleReceipt?    @relation(fields: [saleReceiptId], references: [id], onDelete: Cascade)

  orderId    String?
  order      Order?    @relation(fields: [orderId], references: [id], onDelete: Cascade)

  userId     String
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  @@index([userId])
  @@index([status])
  @@index([type])
  @@index([channel])
  @@index([recipientType, recipientId])
  @@index([createdAt])
  @@index([sentAt])
  @@map("notifications")
}


model NotificationTemplate {
  id          String   @id @default(cuid())
  name        String   @unique
  channel     NotificationChannel
  type        NotificationType
  subject     String?  // For email templates
  content     String   // Template content with placeholders
  variables   Json     // Expected variables and their types
  metadata    Json?    // Additional template metadata
  isActive    Boolean  @default(true)
  category    String?
  description String?

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([channel, type])
  @@index([isActive])
  @@map("notification_templates")
}

model Reminder {
  id          String         @id @default(cuid())
  message     String
  type        ReminderType
  status      ReminderStatus @default(PENDING)
  scheduledAt DateTime
  sentAt      DateTime?
  channel     String         // whatsapp, sms, email
  metadata    Json?          // Additional data like template variables

  customerId  String
  customer    Customer       @relation(fields: [customerId], references: [id], onDelete: Cascade)

  userId      String
  user        User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  @@index([userId])
  @@index([customerId])
  @@index([status])
  @@index([scheduledAt])
  @@map("reminders")
}

// ========================================
// OCR & DOCUMENT PROCESSING
// ========================================

model OCRData {
  id            String    @id @default(cuid())
  imageUrl      String
  originalName  String?   // Original filename
  fileSize      Int?      // File size in bytes
  extractedData Json      @default("{}") // Raw extracted data from OCR
  processedData Json?     // Cleaned and structured data
  confidence    Float?
  status        OCRStatus @default(PROCESSING)
  errorMessage  String?   // Error details if failed

  // Relations (nullable - one OCR can be linked to any document)
  invoiceId     String?   @unique
  invoice       Invoice?  @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  invoicePaymentId String? @unique
  invoicePayment   InvoicePayment? @relation(fields: [invoicePaymentId], references: [id], onDelete: Cascade)

  saleReceiptId    String? @unique
  saleReceipt      SaleReceipt? @relation(fields: [saleReceiptId], references: [id], onDelete: Cascade)

  userId        String
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@index([userId])
  @@index([status])
  @@map("ocr_data")
}

// ========================================
// BACKUP & SYSTEM MANAGEMENT
// ========================================

model Backup {
  id          String    @id @default(cuid())
  type        String    // FULL, INCREMENTAL, SCHEMA
  description String?
  status      String    // IN_PROGRESS, COMPLETED, FAILED
  filePath    String?
  cloudPath   String?
  fileSize    BigInt?
  startedAt   DateTime
  completedAt DateTime?
  errorMessage String?

  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([userId])
  @@index([status])
  @@map("backups")
}

model Restore {
  id          String    @id @default(cuid())
  backupId    String
  status      String    // IN_PROGRESS, COMPLETED, FAILED
  startedAt   DateTime
  completedAt DateTime?
  errorMessage String?

  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([userId])
  @@index([status])
  @@map("restores")
}

model BackupSchedule {
  id        String   @id @default(cuid())
  frequency String   // DAILY, WEEKLY, MONTHLY
  time      String   // HH:MM format
  type      String   // FULL, INCREMENTAL
  enabled   Boolean  @default(true)

  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("backup_schedules")
}

// ========================================
// AUDIT & COMPLIANCE
// ========================================

model AuditLog {
  id        String   @id @default(cuid())
  userId    String?
  user      User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  action    String   // CREATE, UPDATE, DELETE, LOGIN, etc.
  entity    String   // Table name or resource
  entityId  String   // Record ID
  oldData   Json?    // Previous data
  newData   Json?    // New data
  metadata  Json?    // Additional context
  ipAddress String?
  userAgent String?

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([entity])
  @@index([action])
  @@index([createdAt])
  @@map("audit_logs")
}

model SystemConfig {
  id    String @id @default(cuid())
  key   String @unique
  value Json

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("system_config")
}

// ========================================
// ENUMS
// ========================================

enum UserRole {
  OWNER
  MANAGER
  STAFF
  VIEWER
  ACCOUNTANT
}

enum InvoiceStatus {
  PENDING
  PARTIALLY_PAID
  PAID
  OVERDUE
  CANCELLED
}

enum SaleStatus {
  PENDING
  PARTIALLY_PAID
  PAID
  OVERDUE
  CANCELLED
  RETURNED
}

enum PaymentMethod {
  CASH
  BANK_TRANSFER
  CHEQUE
  UPI
  CARD
  ONLINE
  OTHER
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  CANCELLED
  REFUNDED
}

enum LedgerType {
  // Document creation entries
  INVOICE_CREATED           // When invoice is received from supplier
  SALE_CREATED             // When sale is made to customer

  // Payment entries
  INVOICE_PAYMENT          // Payment made to supplier
  SALE_RECEIPT             // Receipt from customer
  EXPENSE_PAYMENT          // General business expenses
  ADVANCE_PAYMENT_MADE     // Advance paid to supplier
  ADVANCE_PAYMENT_RECEIVED // Advance received from customer

  // Adjustments
  ADJUSTMENT
  OPENING_BALANCE
  CLOSING_BALANCE

  // Additional specific types
  DISCOUNT_ALLOWED         // Discount given to customer
  DISCOUNT_RECEIVED        // Discount from supplier
  BAD_DEBT_WRITEOFF       // Uncollectable customer debt
  BANK_CHARGES            // Bank transaction charges
  INTEREST_EARNED         // Interest income
  INTEREST_PAID           // Interest expense
  CREDIT_LIMIT_CHANGE
}

enum ReminderType {
  PAYMENT_DUE
  OVERDUE_PAYMENT
  FOLLOW_UP
  CUSTOM
  BIRTHDAY
  ANNIVERSARY
  STOCK_REORDER
  TAX_FILING
}

enum ReminderStatus {
  PENDING
  SENT
  DELIVERED
  FAILED
  CANCELLED
}

enum OCRStatus {
  PROCESSING
  COMPLETED
  FAILED
  MANUAL_REVIEW
  CANCELLED
}

enum OrderStatus {
  PENDING
  CONFIRMED
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
  RETURNED
  REFUNDED
}

enum NotificationType {
  PAYMENT_REMINDER
  PAYMENT_CONFIRMATION
  INVOICE_CREATED
  INVOICE_OVERDUE
  SALE_CREATED
  ORDER_CONFIRMATION
  ORDER_STATUS_UPDATE
  STOCK_ALERT
  LOW_STOCK_ALERT
  REORDER_ALERT
  CUSTOM
  WELCOME
  BIRTHDAY
  ANNIVERSARY
  PROMOTIONAL
  SYSTEM_ALERT
  BACKUP_COMPLETED
  BACKUP_FAILED
}

enum NotificationChannel {
  WHATSAPP
  SMS
  EMAIL
  PUSH
  IN_APP
}

enum NotificationStatus {
  PENDING
  SENT
  DELIVERED
  READ
  FAILED
  CANCELLED
}

enum MovementType {
  IN          // Stock received
  OUT         // Stock sold/dispatched
  ADJUSTMENT  // Manual stock correction
  TRANSFER    // Transfer between locations
  RETURN      // Customer/supplier returns
  DAMAGE      // Damaged goods writeoff
  SAMPLE      // Sample given to customer
  WASTAGE     // Production wastage
}

```

```typescript
// packages/common/events/subjects.ts

// Event subjects for Kafka messaging
export enum Subjects {
    // ========================================
    // üîê AUTHENTICATION & USER MANAGEMENT
    // ========================================

    // User Lifecycle
    UserCreated = "user:created",
    UserUpdated = "user:updated",
    UserDeleted = "user:deleted",
    UserActivated = "user:activated",
    UserDeactivated = "user:deactivated",
    UserRoleChanged = "user:role-changed",
    UserPasswordChanged = "user:password-changed",

    // Authentication Events
    UserLoggedIn = "user:logged-in",
    UserLoggedOut = "user:logged-out",
    UserLoginFailed = "user:login-failed",
    UserTokenRefreshed = "user:token-refreshed",
    UserPasswordResetRequested = "user:password-reset-requested",
    UserPasswordResetCompleted = "user:password-reset-completed",

    // Session Management
    SessionCreated = "session:created",
    SessionExpired = "session:expired",
    SessionTerminated = "session:terminated",

    // Security Events
    SuspiciousActivityDetected = "security:suspicious-activity",
    UserAccountLocked = "user:account-locked",
    AccessAttemptFailed = "security:access-failed",

    // ========================================
    // üí• PARTY/SUPPLIER MANAGEMENT
    // ========================================

    PartyCreated = "party:created",
    PartyUpdated = "party:updated",
    PartyDeleted = "party:deleted",
    PartyActivated = "party:activated",
    PartyDeactivated = "party:deactivated",
    PartyContactUpdated = "party:contact-updated",
    PartyGSTUpdated = "party:gst-updated",
    PartyBankDetailsUpdated = "party:bank-details-updated",
    PartyPaymentTermsUpdated = "party:payment-terms-updated",
    PartyStatementSent = "party:statement-sent",

    // ========================================
    // üõí CUSTOMER MANAGEMENT
    // ========================================

    CustomerCreated = "customer:created",
    CustomerUpdated = "customer:updated",
    CustomerDeleted = "customer:deleted",
    CustomerActivated = "customer:activated",
    CustomerDeactivated = "customer:deactivated",
    CustomerContactUpdated = "customer:contact-updated",
    CustomerCreditLimitUpdated = "customer:credit-limit-updated",
    CustomerCreditLimitExceeded = "customer:credit-limit-exceeded",
    CustomerCreditLimitWarning = "customer:credit-limit-warning",
    CustomerFirstVisit = "customer:first-visit",

    // ========================================
    // üìÑ INVOICE MANAGEMENT
    // ========================================

    // Invoice Lifecycle
    InvoiceCreated = "invoice:created",
    InvoiceUpdated = "invoice:updated",
    InvoiceDeleted = "invoice:deleted",
    InvoiceCancelled = "invoice:cancelled",
    InvoiceVoided = "invoice:voided",
    InvoiceDraftCreated = "invoice:draft-created",
    InvoiceSent = "invoice:sent",
    InvoiceViewed = "invoice:viewed",

    // Invoice Payment Status
    InvoicePaid = "invoice:paid",
    InvoicePartiallyPaid = "invoice:partially-paid",
    InvoiceOverdue = "invoice:overdue",
    InvoiceDueSoon = "invoice:due-soon",
    InvoiceDueToday = "invoice:due-today",
    InvoicePaymentReceived = "invoice:payment-received",

    // Invoice Actions
    InvoicePrinted = "invoice:printed",
    InvoiceEmailed = "invoice:emailed",
    InvoiceWhatsAppSent = "invoice:whatsapp-sent",
    InvoiceReminderSent = "invoice:reminder-sent",
    InvoiceFollowUpRequired = "invoice:follow-up-required",
    InvoiceGSTValidated = "invoice:gst-validated",
    InvoiceAnalyticsGenerated = "invoice:analytics-generated",

    // ========================================
    // üõç SALES MANAGEMENT
    // ========================================

    // Sale Lifecycle
    SaleCreated = "sale:created",
    SaleUpdated = "sale:updated",
    SaleDeleted = "sale:deleted",
    SaleCancelled = "sale:cancelled",
    SaleCompleted = "sale:completed",
    SaleReturned = "sale:returned",
    SalePartiallyReturned = "sale:partially-returned",
    SaleExchanged = "sale:exchanged",

    // Sale Payment Status
    SalePaid = "sale:paid",
    SalePartiallyPaid = "sale:partially-paid",
    SaleCreditSale = "sale:credit-sale",
    SaleCashSale = "sale:cash-sale",
    SaleOverdue = "sale:overdue",

    // Sale Operations
    SaleReceiptPrinted = "sale:receipt-printed",
    SaleReceiptEmailed = "sale:receipt-emailed",
    SaleReceiptWhatsAppSent = "sale:receipt-whatsapp-sent",
    SaleTrendAnalyzed = "sale:trend-analyzed",

    // ========================================
    // üí∞ INVOICE PAYMENT MANAGEMENT
    // ========================================

    // Invoice Payment Lifecycle
    InvoicePaymentCreated = "invoice-payment:created",
    InvoicePaymentUpdated = "invoice-payment:updated",
    InvoicePaymentDeleted = "invoice-payment:deleted",
    InvoicePaymentVoided = "invoice-payment:voided",

    // Invoice Payment Processing
    InvoicePaymentProcessed = "invoice-payment:processed",
    InvoicePaymentFailed = "invoice-payment:failed",
    InvoicePaymentPending = "invoice-payment:pending",
    InvoicePaymentConfirmed = "invoice-payment:confirmed",
    InvoicePaymentReconciled = "invoice-payment:reconciled",
    InvoicePaymentRefunded = "invoice-payment:refunded",

    // Invoice Payment Methods
    CashInvoicePaymentMade = "invoice-payment:cash-made",
    UPIInvoicePaymentMade = "invoice-payment:upi-made",
    BankTransferInvoicePaymentMade = "invoice-payment:bank-transfer-made",
    ChequeInvoicePaymentMade = "invoice-payment:cheque-made",
    CardInvoicePaymentMade = "invoice-payment:card-made",
    InvoicePaymentTrendAnalyzed = "invoice-payment:trend-analysed",
    InvoicePaymentAllocated = "invoice-payment:allocated",
    BankTransferStatusUpdated = "invoice-payment:banktransfer-statusupdated",
    ChequeStatusUpdated = "invoice-payment:chequestatusupdated",

    // ========================================
    // üßæ SALE RECEIPT MANAGEMENT
    // ========================================

    SaleReceiptCreated = "sale-receipt:created",
    SaleReceiptUpdated = "sale-receipt:updated",
    SaleReceiptDeleted = "sale-receipt:deleted",
    SaleReceiptVoided = "sale-receipt:voided",
    // SaleReceiptPrinted = "sale-receipt:printed",
    // SaleReceiptEmailed = "sale-receipt:emailed",
    // SaleReceiptWhatsAppSent = "sale-receipt:whatsapp-sent",

    // ========================================
    // üìä LEDGER & ACCOUNTING
    // ========================================

    // Ledger Operations
    LedgerEntryCreated = "ledger:entry-created",
    LedgerEntryUpdated = "ledger:entry-updated",
    LedgerEntryDeleted = "ledger:entry-deleted",
    LedgerBalanceUpdated = "ledger:balance-updated",
    LedgerReconciled = "ledger:reconciled",
    LedgerAdjustmentMade = "ledger:adjustment-made",

    // Financial Periods
    DayBookClosed = "daybook:closed",
    MonthClosed = "month:closed",
    FinancialYearOpened = "financial-year:opened",
    FinancialYearClosed = "financial-year:closed",

    // Tax & GST
    GSTCalculated = "gst:calculated",
    GSTReturnGenerated = "gst:return-generated",
    GSTReturnFiled = "gst:return-filed",
    TaxCalculated = "tax:calculated",
    TDSCalculated = "tds:calculated",

    // ========================================
    // üì± REMINDERS & NOTIFICATIONS
    // ========================================

    // Reminder Lifecycle
    ReminderCreated = "reminder:created",
    ReminderScheduled = "reminder:scheduled",
    ReminderSent = "reminder:sent",
    ReminderDelivered = "reminder:delivered",
    ReminderRead = "reminder:read",
    ReminderFailed = "reminder:failed",
    ReminderCancelled = "reminder:cancelled",
    ReminderSnoozed = "reminder:snoozed",
    ReminderCompleted = "reminder:completed",

    // Notification Types
    PaymentReminderSent = "notification:payment-reminder-sent",
    OverdueNotificationSent = "notification:overdue-sent",
    WelcomeNotificationSent = "notification:welcome-sent",
    BirthdayReminderSent = "notification:birthday-reminder-sent",
    FestivalGreetingSent = "notification:festival-greeting-sent",

    // REQUEST SUBJECTS (what other services publish)
    SendEmailRequested = "notification:send-email-requested",
    SendSMSRequested = "notification:send-sms-requested",
    SendWhatsAppRequested = "notification:send-whatsapp-requested",

    // Communication Channels
    WhatsAppMessageSent = "whatsapp:message-sent",
    WhatsAppMessageDelivered = "whatsapp:message-delivered",
    WhatsAppMessageRead = "whatsapp:message-read",
    WhatsAppMessageFailed = "whatsapp:message-failed",

    SMSMessageSent = "sms:message-sent",
    SMSMessageDelivered = "sms:message-delivered",
    SMSMessageFailed = "sms:message-failed",

    EmailSent = "email:sent",
    EmailDelivered = "email:delivered",
    EmailOpened = "email:opened",
    EmailClicked = "email:clicked",
    EmailBounced = "email:bounced",
    EmailFailed = "email:failed",

    // ========================================
    // üìÑ OCR & DOCUMENT PROCESSING
    // ========================================

    // Document Upload & Processing
    DocumentUploaded = "document:uploaded",
    DocumentQueued = "document:queued",
    DocumentProcessingStarted = "document:processing-started",
    DocumentProcessed = "document:processed",
    DocumentProcessingFailed = "document:processing-failed",
    DocumentValidated = "document:validated",
    DocumentRejected = "document:rejected",
    DocumentArchived = "document:archived",
    DocumentDeleted = "document:deleted",

    // OCR Job Lifecycle
    OCRJobCreated = "ocr:job-created",
    OCRJobStarted = "ocr:job-started",
    OCRJobCompleted = "ocr:job-completed",
    OCRJobFailed = "ocr:job-failed",
    OCRJobCancelled = "ocr:job-cancelled",
    OCRJobRetried = "ocr:job-retried",

    // OCR Results
    OCRDataExtracted = "ocr:data-extracted",
    OCRDataValidated = "ocr:data-validated",
    OCRDataCorrected = "ocr:data-corrected",
    OCRHighConfidenceResult = "ocr:high-confidence",
    OCRLowConfidenceResult = "ocr:low-confidence",
    OCRManualReviewRequired = "ocr:manual-review-required",

    // Auto-Creation from OCR
    InvoiceAutoCreatedFromOCR = "invoice:auto-created-from-ocr",
    SaleReceiptAutoCreatedFromOCR = "sale-receipt:auto-created-from-ocr",
    InvoicePaymentAutoCreatedFromOCR = "invoice-payment:auto-created-from-ocr",
    ExpenseAutoCreatedFromOCR = "expense:auto-created-from-ocr",

    // ========================================
    // üì¶ INVENTORY & ITEM MANAGEMENT
    // ========================================

    // Inventory Item Lifecycle
    InventoryItemCreated = "inventory-item:created",
    InventoryItemUpdated = "inventory-item:updated",
    InventoryItemDeleted = "inventory-item:deleted",
    InventoryItemActivated = "inventory-item:activated",
    InventoryItemDeactivated = "inventory-item:deactivated",
    InventoryItemPriceUpdated = "inventory-item:price-updated",
    InventoryItemCostUpdated = "inventory-item:cost-updated",
    InventoryItemCategoryChanged = "inventory-item:category-changed",
    InventoryItemImageUpdated = "inventory-item:image-updated",

    // Stock Management
    StockAdded = "stock:added",
    StockReduced = "stock:reduced",
    StockAdjusted = "stock:adjusted",
    StockTransferred = "stock:transferred",
    StockDamaged = "stock:damaged",
    StockExpired = "stock:expired",
    StockReturned = "stock:returned",

    // Stock Alerts
    StockLow = "stock:low",
    StockCritical = "stock:critical",
    StockOut = "stock:out",
    StockReorderRequired = "stock:reorder-required",
    StockReceived = "stock:received",
    StockOrdered = "stock:ordered",

    // Inventory Operations
    InventoryCountStarted = "inventory:count-started",
    InventoryCountCompleted = "inventory:count-completed",
    InventoryVarianceDetected = "inventory:variance-detected",
    InventoryAdjustmentMade = "inventory:adjustment-made",

    // ========================================
    // üë• E-COMMERCE USER MANAGEMENT
    // ========================================

    // E-commerce User Lifecycle
    EcommerceUserCreated = "ecommerce-user:created",
    EcommerceUserUpdated = "ecommerce-user:updated",
    EcommerceUserDeleted = "ecommerce-user:deleted",
    EcommerceUserActivated = "ecommerce-user:activated",
    EcommerceUserDeactivated = "ecommerce-user:deactivated",
    EcommerceUserBlocked = "ecommerce-user:blocked",
    EcommerceUserUnblocked = "ecommerce-user:unblocked",

    // E-commerce Authentication
    EcommerceUserLoggedIn = "ecommerce-user:logged-in",
    EcommerceUserLoggedOut = "ecommerce-user:logged-out",
    EcommerceUserLoginFailed = "ecommerce-user:login-failed",
    EcommerceUserPasswordChanged = "ecommerce-user:password-changed",
    EcommerceUserPasswordResetRequested = "ecommerce-user:password-reset-requested",
    EcommerceUserPasswordResetCompleted = "ecommerce-user:password-reset-completed",

    // E-commerce User Verification
    EcommerceUserEmailVerified = "ecommerce-user:email-verified",
    EcommerceUserPhoneVerified = "ecommerce-user:phone-verified",
    EcommerceUserEmailVerificationSent = "ecommerce-user:email-verification-sent",
    EcommerceUserPhoneVerificationSent = "ecommerce-user:phone-verification-sent",

    // E-commerce User Profile
    EcommerceUserProfileUpdated = "ecommerce-user:profile-updated",
    EcommerceUserAddressAdded = "ecommerce-user:address-added",
    EcommerceUserAddressUpdated = "ecommerce-user:address-updated",
    EcommerceUserAddressDeleted = "ecommerce-user:address-deleted",
    EcommerceUserPreferencesUpdated = "ecommerce-user:preferences-updated",

    // Social Login
    EcommerceUserSocialLoginLinked = "ecommerce-user:social-login-linked",
    EcommerceUserSocialLoginUnlinked = "ecommerce-user:social-login-unlinked",

    // E-commerce User Session
    EcommerceUserSessionCreated = "ecommerce-user:session-created",
    EcommerceUserSessionExpired = "ecommerce-user:session-expired",
    EcommerceUserSessionTerminated = "ecommerce-user:session-terminated",

    // ========================================
    // üõç E-COMMERCE & ORDERS
    // ========================================

    // Order Management
    OrderCreated = "order:created",
    OrderUpdated = "order:updated",
    OrderConfirmed = "order:confirmed",
    OrderPacked = "order:packed",
    OrderShipped = "order:shipped",
    OrderDelivered = "order:delivered",
    OrderCancelled = "order:cancelled",
    OrderReturned = "order:returned",
    OrderRefunded = "order:refunded",
    OrderCompleted = "order:completed",

    // Shopping Cart
    CartCreated = "cart:created",
    CartUpdated = "cart:updated",
    CartItemAdded = "cart:item-added",
    CartItemRemoved = "cart:item-removed",
    CartAbandoned = "cart:abandoned",
    CartRecovered = "cart:recovered",
    CartConverted = "cart:converted",

    // Online Payments
    OnlinePaymentInitiated = "online-payment:initiated",
    OnlinePaymentSucceeded = "online-payment:succeeded",
    OnlinePaymentFailed = "online-payment:failed",
    OnlinePaymentRefunded = "online-payment:refunded",

    // ========================================
    // üìä REPORTS & ANALYTICS
    // ========================================

    // Report Generation
    ReportGenerated = "report:generated",
    ReportScheduled = "report:scheduled",
    ReportEmailed = "report:emailed",
    ReportDownloaded = "report:downloaded",
    ReportFailed = "report:failed",

    // Daily Reports
    DailySalesReportGenerated = "report:daily-sales-generated",
    DailyCashReportGenerated = "report:daily-cash-generated",
    DailyInventoryReportGenerated = "report:daily-inventory-generated",
    DailyOutstandingReportGenerated = "report:daily-outstanding-generated",

    // Weekly/Monthly Reports
    WeeklySalesReportGenerated = "report:weekly-sales-generated",
    MonthlySalesReportGenerated = "report:monthly-sales-generated",
    MonthlyProfitLossGenerated = "report:monthly-pl-generated",
    MonthlyGSTReportGenerated = "report:monthly-gst-generated",

    // Analytics & KPIs
    KPICalculated = "analytics:kpi-calculated",
    SalesTrendAnalyzed = "analytics:sales-trend-analyzed",
    CustomerAnalyticsGenerated = "analytics:customer-analytics-generated",
    InventoryTurnoverCalculated = "analytics:inventory-turnover-calculated",
    ProfitMarginCalculated = "analytics:profit-margin-calculated",

    // Dashboard Updates
    DashboardDataUpdated = "dashboard:data-updated",
    DashboardViewed = "dashboard:viewed",
    DashboardExported = "dashboard:exported",

    // ========================================
    // ‚öôÔ∏è SYSTEM & ADMINISTRATION
    // ========================================

    // System Events
    SystemStarted = "system:started",
    SystemShutdown = "system:shutdown",
    SystemHealthCheckPerformed = "system:health-check",
    SystemMaintenanceStarted = "system:maintenance-started",
    SystemMaintenanceCompleted = "system:maintenance-completed",
    SystemUpdated = "system:updated",
    SystemMetricsCollected = "system:metrics-collected",
    SystemAlertTriggered = "system:alert-triggered",
    APIEndpointAccessed = "system:api-endpoint-accessed",
    WebhookReceived = "system:webhook-received",
    SystemConfigUpdated = "system:config-updated",

    // Data Management
    DataBackupStarted = "data:backup-started",
    DataBackupCompleted = "data:backup-completed",
    DataBackupFailed = "data:backup-failed",
    DataRestoreStarted = "data:restore-started",
    DataRestoreCompleted = "data:restore-completed",
    DataExported = "data:exported",
    DataImported = "data:imported",

    // Configuration
    SettingsUpdated = "settings:updated",
    ConfigurationChanged = "config:changed",
    BusinessProfileUpdated = "business:profile-updated",
    TaxSettingsUpdated = "tax:settings-updated",
    NotificationPreferencesUpdated = "notification:preferences-updated",

    // Audit & Compliance
    AuditLogCreated = "audit:log-created",
    ComplianceCheckPerformed = "compliance:check-performed",
    DataIntegrityCheckPerformed = "data:integrity-check",
    SecurityScanPerformed = "security:scan-performed",

    // ========================================
    // üè™ TEXTILE SHOP SPECIFIC EVENTS
    // ========================================

    // Customer Events
    CustomerVisitLogged = "customer:visit-logged",
    CustomerPreferenceUpdated = "customer:preference-updated",
    CustomerLoyaltyPointsEarned = "customer:loyalty-points-earned",
    CustomerLoyaltyPointsRedeemed = "customer:loyalty-points-redeemed",

    // Textile/Inventory Specific
    TextileDisplayed = "textile:displayed",
    TextileDemonstrated = "textile:demonstrated",
    TextileReserved = "textile:reserved",
    TextileCustomized = "textile:customized",

    // Seasonal Events
    FestivalDiscountApplied = "festival:discount-applied",
    SeasonalInventoryUpdated = "seasonal:inventory-updated",
    WeddingSeasonAlertSent = "wedding-season:alert-sent",

    // Business Operations
    ShopOpeningLogged = "shop:opening-logged",
    ShopClosingLogged = "shop:closing-logged",
    CashCountPerformed = "cash:count-performed",
    CashShortageDetected = "cash:shortage-detected",
    CashExcessDetected = "cash:excess-detected",
}

// Export type for better TypeScript support
export type SubjectType = keyof typeof Subjects;

// Helper to get all subjects as array
export const getAllSubjects = (): string[] => {
    return Object.values(Subjects);
};

// Group subjects by category for better organization
export const SubjectCategories = {
    AUTHENTICATION: [
        Subjects.UserCreated,
        Subjects.UserLoggedIn,
        Subjects.UserLoggedOut,
        Subjects.SessionCreated,
    ],

    CORE_BUSINESS: [
        Subjects.InvoiceCreated,
        Subjects.SaleCreated,
        Subjects.InvoicePaymentCreated,
        Subjects.SaleReceiptCreated,
        Subjects.CustomerCreated,
        Subjects.PartyCreated,
    ],

    NOTIFICATIONS: [
        Subjects.InvoiceOverdue,
        Subjects.PaymentReminderSent,
        Subjects.WhatsAppMessageSent,
        Subjects.EmailSent,
    ],

    DOCUMENT_PROCESSING: [
        Subjects.DocumentUploaded,
        Subjects.OCRJobCompleted,
        Subjects.InvoiceAutoCreatedFromOCR,
        Subjects.SaleReceiptAutoCreatedFromOCR,
    ],

    INVENTORY: [
        Subjects.InventoryItemCreated,
        Subjects.StockLow,
        Subjects.StockOut,
        Subjects.InventoryCountCompleted,
    ],

    REPORTS: [
        Subjects.DailySalesReportGenerated,
        Subjects.MonthlySalesReportGenerated,
        Subjects.KPICalculated,
    ],

    SYSTEM: [
        Subjects.SystemStarted,
        Subjects.DataBackupCompleted,
        Subjects.AuditLogCreated,
    ],
} as const;

// Priority mapping for event processing
export const EventPriorities = {
    CRITICAL: [
        Subjects.SystemShutdown,
        Subjects.DataBackupFailed,
        Subjects.SuspiciousActivityDetected,
        Subjects.CashShortageDetected,
        Subjects.InvoicePaymentFailed,
    ],

    HIGH: [
        Subjects.InvoiceOverdue,
        Subjects.CustomerCreditLimitExceeded,
        Subjects.StockOut,
        Subjects.WhatsAppMessageFailed,
    ],

    MEDIUM: [
        Subjects.InvoiceCreated,
        Subjects.SaleCreated,
        Subjects.InvoicePaymentCreated,
        Subjects.CustomerCreated,
    ],

    LOW: [
        Subjects.DashboardViewed,
        Subjects.ReportGenerated,
        Subjects.EmailOpened,
        Subjects.UserLoggedIn,
    ],
} as const;

// Method 1: Domain-Based Topics (Recommended)
export const TopicNames = {
    // NOTIFICATION DOMAIN
    NOTIFICATION_EMAIL_REQUESTS: "notification.email.requests",
    NOTIFICATION_EMAIL_RESPONSES: "notification.email.responses",
    NOTIFICATION_SMS_REQUESTS: "notification.sms.requests",
    NOTIFICATION_SMS_RESPONSES: "notification.sms.responses",
    NOTIFICATION_WHATSAPP_REQUESTS: "notification.whatsapp.requests",
    NOTIFICATION_WHATSAPP_RESPONSES: "notification.whatsapp.responses",

    // AUTH DOMAIN
    AUTH_USER_EVENTS: "auth.user.events",
    AUTH_SESSION_EVENTS: "auth.session.events",
    AUTH_SECURITY_EVENTS: "auth.security.events",

    // ACCOUNTS DOMAIN
    ACCOUNTS_INVOICE_EVENTS: "accounts.invoice.events",
    ACCOUNTS_INVOICE_PAYMENT_EVENTS: "accounts.invoice.payment.events",
    ACCOUNTS_SALE_EVENTS: "accounts.sale.events",
    ACCOUNTS_LEDGER_EVENTS: "accounts.ledger.events",

    // OCR DOMAIN
    OCR_PROCESSING_EVENTS: "ocr.processing.events",
    OCR_DOCUMENT_EVENTS: "ocr.document.events",

    // INVENTORY DOMAIN
    INVENTORY_ITEM_EVENTS: "inventory.item.events",
    INVENTORY_STOCK_EVENTS: "inventory.stock.events",

    // ANALYTICS DOMAIN
    ANALYTICS_EVENTS: "analytics.events",
    AUDIT_EVENTS: "audit.events",

    // party
    PARTY_EVENTS: "party.events",

    // customer
    CUSTOMER_EVENTS: "customer.events",
};

// general publishers in packages/common-backend/events/publishers
import { KafkaPublisher } from "../../kafka/index";
import { Subjects } from "@repo/common/subjects";
import { SendEmailRequestEvent } from "../interfaces/index";
import { TopicNames } from "@repo/common/topics";

export class SendEmailRequestPublisher extends KafkaPublisher<SendEmailRequestEvent> {
    subject = Subjects.SendEmailRequested as const;
    topic = TopicNames.NOTIFICATION_EMAIL_REQUESTS;
    protected generateMessageKey(data: SendEmailRequestEvent["data"]): string {
        return `${data.recipientId}_${data.recipient.email.split("@")[1]}`;
    }
}

export class SendSMSRequestPublisher extends KafkaPublisher<SendSMSRequestEvent> {
    subject = Subjects.SendSMSRequested as const;
    topic = TopicNames.NOTIFICATION_SMS_REQUESTS;
    protected generateMessageKey(data: SendSMSRequestEvent["data"]): string {
        return `${data.recipientId}_${data.recipient.phone}`;
    }
}

export class SendWhatsAppRequestPublisher extends KafkaPublisher<SendWhatsAppRequestEvent> {
    subject = Subjects.SendWhatsAppRequested as const;
    topic = TopicNames.NOTIFICATION_WHATSAPP_REQUESTS;
    protected generateMessageKey(
        data: SendWhatsAppRequestEvent["data"]
    ): string {
        return `${data.recipientId}_${data.recipient.phone}`;
    }
}

// packages/common-backend/src/events/interfaces/index.ts

// Export base interfaces
export * from "./base-interfaces";

// Export domain-specific interfaces
export * from "./user-interfaces";
export * from "./customer-interfaces";
export * from "./party-interfaces";
export * from "./sale-interfaces";
export * from "./invoice-interfaces";
export * from "./invoicePayment-interfaces";
export * from "./system-interfaces";
export * from "./ocr-interfaces";
export * from "./inventoryItem-interfaces";
export * from "./order-interfaces";
export * from "./ecomm-interfaces";
export * from "./notification-interfaces";
export * from "./service-results-interfaces";
// Additional domain interfaces (to be created)
// TODO here
// export * from "./ledgerInterfaces";
// export * from "./notificationInterfaces";
// export * from "./ocrInterfaces";
// export * from "./receiptInterfaces";
// export * from "./textileInterfaces";
// export * from "./reportInterfaces";

// Import all event types for union type
import type { UserEventTypes } from "./user-interfaces";
import type { CustomerEventTypes } from "./customer-interfaces";
import type { PartyEventTypes } from "./party-interfaces";
import type { SaleEventTypes } from "./sale-interfaces";
import type { InvoiceEventTypes } from "./invoice-interfaces";
import type { InvoicePaymentEventTypes } from "./invoicePayment-interfaces";
import type { SystemEventTypes } from "./system-interfaces";

// Master union type of all events
export type AllEventTypes =
    | UserEventTypes
    | CustomerEventTypes
    | PartyEventTypes
    | SaleEventTypes
    | InvoiceEventTypes
    | InvoicePaymentEventTypes
    | SystemEventTypes;

// Event type mapping for type-safe event handling
export interface EventTypeMap {
    // User events
    "user:created": UserEventTypes;
    "user:updated": UserEventTypes;
    "user:deleted": UserEventTypes;
    "user:logged-in": UserEventTypes;
    "user:logged-out": UserEventTypes;

    // Customer events
    "customer:created": CustomerEventTypes;
    "customer:updated": CustomerEventTypes;
    "customer:deleted": CustomerEventTypes;
    "customer:credit-limit-exceeded": CustomerEventTypes;
    "customer:became-vip": CustomerEventTypes;

    // Party events
    "party:created": PartyEventTypes;
    "party:updated": PartyEventTypes;
    "party:deleted": PartyEventTypes;
    "party:gst-updated": PartyEventTypes;

    // Sale events
    "sale:created": SaleEventTypes;
    "sale:updated": SaleEventTypes;
    "sale:paid": SaleEventTypes;
    "sale:overdue": SaleEventTypes;
    "sale:returned": SaleEventTypes;

    // Invoice events
    "invoice:created": InvoiceEventTypes;
    "invoice:updated": InvoiceEventTypes;
    "invoice:paid": InvoiceEventTypes;
    "invoice:overdue": InvoiceEventTypes;
    "invoice:emailed": InvoiceEventTypes;

    // Payment events
    "InvoicePayment:created": InvoicePaymentEventTypes;
    "invoicePayment:received": InvoicePaymentEventTypes;
    "invoicePayment:failed": InvoicePaymentEventTypes;
    "invoicePayment:reconciled": InvoicePaymentEventTypes;

    // System events
    "system:started": SystemEventTypes;
    "system:shutdown": SystemEventTypes;
    "data:backup-completed": SystemEventTypes;
    "audit:log-created": SystemEventTypes;
}

// Event category groupings for better organization
export const EventCategories = {
    AUTHENTICATION: [
        "user:created",
        "user:logged-in",
        "user:logged-out",
        "session:created",
        "session:expired",
    ],

    BUSINESS_CORE: [
        "customer:created",
        "party:created",
        "sale:created",
        "invoice:created",
        "payment:received",
    ],

    FINANCIAL: [
        "payment:received",
        "payment:failed",
        "invoice:paid",
        "sale:paid",
        "ledger:entry-created",
    ],

    CUSTOMER_LIFECYCLE: [
        "customer:first-visit",
        "customer:became-vip",
        "customer:long-time-no-visit",
        "customer:loyalty-points-earned",
    ],

    ALERTS: [
        "customer:credit-limit-exceeded",
        "invoice:overdue",
        "sale:overdue",
        "payment:failed",
        "stock:low",
    ],

    COMMUNICATION: [
        "whatsapp:message-sent",
        "email:sent",
        "payment:reminder-sent",
        "notification:sent",
    ],

    SYSTEM_OPERATIONS: [
        "system:started",
        "system:shutdown",
        "data:backup-completed",
        "system:health-check",
    ],

    COMPLIANCE: [
        "audit:log-created",
        "compliance:check-performed",
        "security:scan-performed",
        "data:integrity-check",
    ],

    DOCUMENT_PROCESSING: [
        "document:uploaded",
        "ocr:job-completed",
        "invoice:auto-created-from-ocr",
    ],

    INVENTORY: [
        "product:created",
        "stock:added",
        "stock:low",
        "inventory:count-completed",
    ],

    TEXTILE_SPECIFIC: [
        "fabric:received",
        "fabric:quality-checked",
        "festival:season-started",
        "saree:stock-received",
    ],
} as const;

// Priority levels for event processing
export const EventPriorities = {
    CRITICAL: [
        "system:shutdown",
        "data:backup-failed",
        "payment:fraud-detected",
        "security:suspicious-activity",
    ],

    HIGH: [
        "payment:failed",
        "invoice:overdue",
        "customer:credit-limit-exceeded",
        "stock:out",
    ],

    MEDIUM: [
        "customer:created",
        "sale:created",
        "invoice:created",
        "payment:received",
    ],

    LOW: [
        "user:logged-in",
        "dashboard:viewed",
        "report:generated",
        "email:opened",
    ],
} as const;

// Event routing configuration for Kafka topics
export const EventRouting = {
    "user-events": [
        "user:created",
        "user:updated",
        "user:deleted",
        "user:role-changed",
    ],

    "auth-events": [
        "user:logged-in",
        "user:logged-out",
        "session:created",
        "session:expired",
    ],

    "customer-events": [
        "customer:created",
        "customer:updated",
        "customer:deleted",
        "customer:contact-updated",
    ],

    "party-events": [
        "party:created",
        "party:updated",
        "party:deleted",
        "party:gst-updated",
    ],

    "sale-events": [
        "sale:created",
        "sale:updated",
        "sale:cancelled",
        "sale:completed",
    ],

    "invoice-events": [
        "invoice:created",
        "invoice:updated",
        "invoice:sent",
        "invoice:viewed",
    ],

    "payment-events": [
        "payment:created",
        "payment:received",
        "payment:processed",
        "payment:reconciled",
        "sale:paid",
        "invoice:paid",
    ],

    "alert-events": [
        "customer:credit-limit-exceeded",
        "invoice:overdue",
        "sale:overdue",
        "payment:failed",
        "stock:low",
        "stock:out",
    ],

    "notification-events": [
        "whatsapp:message-sent",
        "email:sent",
        "sms:message-sent",
        "payment:reminder-sent",
    ],

    "ledger-events": [
        "ledger:entry-created",
        "ledger:balance-updated",
        "opening:balance-set",
        "ledger:out-of-balance",
    ],

    "system-events": [
        "system:started",
        "system:shutdown",
        "system:health-check",
        "system:maintenance-started",
    ],

    "backup-events": [
        "data:backup-started",
        "data:backup-completed",
        "data:backup-failed",
        "data:restore-started",
    ],

    "audit-events": [
        "audit:log-created",
        "compliance:check-performed",
        "security:scan-performed",
    ],

    "security-events": [
        "suspicious:activity-detected",
        "user:login-failed",
        "user:account-locked",
        "payment:fraud-detected",
    ],

    "business-events": [
        "business:profile-updated",
        "settings:updated",
        "festival:season-started",
        "customer:became-vip",
    ],

    "inventory-events": [
        "product:created",
        "stock:added",
        "stock:reduced",
        "stock:low",
        "inventory:count-completed",
    ],

    "ocr-events": [
        "document:uploaded",
        "ocr:job-created",
        "ocr:job-completed",
        "invoice:auto-created-from-ocr",
    ],

    "analytics-events": [
        "sales:trend-analyzed",
        "kpi:calculated",
        "customer:segmentation-updated",
        "report:generated",
    ],
} as const;

// Helper functions for event handling
export function getEventCategory(eventSubject: string): string | undefined {
    for (const [category, events] of Object.entries(EventCategories) as [
        string,
        readonly string[],
    ][]) {
        if (events.includes(eventSubject)) {
            return category;
        }
    }
    return undefined;
}

export function getEventPriority(eventSubject: string): string | undefined {
    for (const [priority, events] of Object.entries(EventPriorities) as [
        string,
        readonly string[],
    ][]) {
        if (events.includes(eventSubject)) {
            return priority;
        }
    }
    return "MEDIUM"; // Default priority
}

export function getEventTopic(eventSubject: string): string | undefined {
    for (const [topic, events] of Object.entries(EventRouting) as [
        string,
        readonly string[],
    ][]) {
        if (events.includes(eventSubject as any)) {
            return topic;
        }
    }
    return "general-events"; // Default topic
}

// Type guards for event types
export function isUserEvent(event: AllEventTypes): event is UserEventTypes {
    return (
        event.subject.startsWith("user:") ||
        event.subject.startsWith("session:") ||
        event.subject.startsWith("security:")
    );
}

export function isCustomerEvent(
    event: AllEventTypes
): event is CustomerEventTypes {
    return event.subject.startsWith("customer:");
}

export function isPartyEvent(event: AllEventTypes): event is PartyEventTypes {
    return event.subject.startsWith("party:");
}

export function isSaleEvent(event: AllEventTypes): event is SaleEventTypes {
    return event.subject.startsWith("sale:");
}

export function isInvoiceEvent(
    event: AllEventTypes
): event is InvoiceEventTypes {
    return event.subject.startsWith("invoice:");
}

export function isPaymentEvent(
    event: AllEventTypes
): event is InvoicePaymentEventTypes {
    return (
        event.subject.startsWith("payment:") ||
        event.subject.includes(":payment:") ||
        event.subject.endsWith(":paid")
    );
}

export function isSystemEvent(event: AllEventTypes): event is SystemEventTypes {
    return (
        event.subject.startsWith("system:") ||
        event.subject.startsWith("data:") ||
        event.subject.startsWith("audit:") ||
        event.subject.startsWith("config:")
    );
}

// Event validation helpers
export function validateEventStructure<T extends AllEventTypes>(
    event: any,
    expectedSubject: T["subject"]
): event is T {
    return (
        event &&
        typeof event === "object" &&
        event.subject === expectedSubject &&
        event.data &&
        typeof event.data === "object"
    );
}

// Event metrics and monitoring
export interface EventMetrics {
    eventCount: number;
    averageProcessingTime: number;
    errorRate: number;
    lastProcessedAt?: string;
    topEventTypes: Array<{
        subject: string;
        count: number;
        percentage: number;
    }>;
}

export function createEventMetrics(): EventMetrics {
    return {
        eventCount: 0,
        averageProcessingTime: 0,
        errorRate: 0,
        topEventTypes: [],
    };
}

// ========================================
// CORRECTED NOTIFICATION SERVICE
// ========================================

// notification-service/src/services/notificationService.ts
import { prisma } from "@repo/db/prisma";
import { EmailProvider } from "./providers/emailProvider";
import { SMSProvider } from "./providers/smsProvider";
import { WhatsAppProvider } from "./providers/whatsAppProvider";
import { TemplateService } from "./templateServices";
import { NotificationType } from "@repo/db/prisma";
import {
    SendEmailRequestEvent,
    SendSMSRequestEvent,
    SendWhatsAppRequestEvent,
    EmailResult,
    SMSResult,
    WhatsAppResult,
    ProviderEmailResult,
    ProviderSMSResult,
    ProviderWhatsAppResult,
} from "@repo/common-backend/interfaces";
import { logger, LogCategory } from "@repo/common-backend/logger";

export class NotificationService {
    private emailProvider: EmailProvider;
    private smsProvider: SMSProvider;
    private whatsappProvider: WhatsAppProvider;
    private templateService: TemplateService;

    constructor() {
        this.emailProvider = new EmailProvider();
        this.smsProvider = new SMSProvider();
        this.whatsappProvider = new WhatsAppProvider();
        this.templateService = new TemplateService();
    }

    // ========================================
    // FIXED EMAIL METHOD
    // ========================================
    async sendEmail(data: SendEmailRequestEvent["data"]): Promise<EmailResult> {
        let notification: any = null;

        try {
            // Create notification record
            notification = await this.createNotificationRecord(data, "EMAIL");

            logger.info(
                "Processing email send request",
                LogCategory.NOTIFICATION,
                {
                    notificationId: notification.id,
                    eventId: data.eventId,
                    recipient: data.recipient.email,
                    templateName: data.email.templateName,
                }
            );

            let htmlBody = data.email.htmlBody;
            let textBody = data.email.textBody;
            let subject = data.email.subject;

            // Use template if specified
            if (data.email.templateName && data.email.templateData) {
                try {
                    // htmlBody = await this.templateService.renderTemplate(
                    //     data.email.templateName,
                    //     data.email.templateData
                    // );

                    const rendered = await this.templateService.renderTemplate(
                        data.email.templateName,
                        data.email.templateData
                    );
                    htmlBody = rendered.content;
                    // Render subject if it contains variables
                    if (subject.includes("{{")) {
                        subject = await this.templateService.renderString(
                            subject,
                            data.email.templateData
                        );
                    }
                } catch (templateError) {
                    logger.error(
                        "Template rendering failed",
                        undefined,
                        LogCategory.NOTIFICATION,
                        {
                            templateName: data.email.templateName,
                            error:
                                templateError instanceof Error
                                    ? templateError.message
                                    : String(templateError),
                        }
                    );
                    throw new Error(
                        `Template rendering failed: ${templateError instanceof Error ? templateError.message : "Unknown error"}`
                    );
                }
            }

            // Send email via provider
            const providerResult: ProviderEmailResult =
                await this.emailProvider.sendEmail({
                    to: {
                        email: data.recipient.email,
                        name: data.recipient.name,
                    },
                    subject,
                    htmlBody,
                    textBody,
                    attachments: data.email.attachments,
                });

            if (providerResult.success) {
                // Update notification as sent
                await this.updateNotificationStatus(notification.id, {
                    success: true,
                    messageId: providerResult.messageId,
                    externalId: providerResult.externalId,
                    deliveredAt: providerResult.deliveredAt,
                });

                logger.info(
                    "Email sent successfully",
                    LogCategory.NOTIFICATION,
                    {
                        notificationId: notification.id,
                        messageId: providerResult.messageId,
                        recipient: data.recipient.email,
                    }
                );

                return {
                    success: true,
                    messageId: providerResult.messageId,
                    externalId: providerResult.externalId,
                    cost: providerResult.cost,
                    deliveredAt: providerResult.deliveredAt,
                };
            } else {
                throw new Error(
                    providerResult.errorMessage || "Email provider failed"
                );
            }
        } catch (error) {
            const errorMessage =
                error instanceof Error ? error.message : "Unknown error";
            const errorCode = this.getEmailErrorCode(error);

            // Update notification as failed
            if (notification) {
                await this.updateNotificationStatus(notification.id, {
                    success: false,
                    errorMessage,
                });
            }

            logger.error(
                "Email sending failed",
                undefined,
                LogCategory.NOTIFICATION,
                {
                    notificationId: notification?.id,
                    eventId: data.eventId,
                    recipient: data.recipient.email,
                    error: errorMessage,
                    errorCode,
                }
            );

            return {
                success: false,
                errorMessage,
                errorCode,
            };
        }
    }

    // ========================================
    // FIXED SMS METHOD
    // ========================================
    async sendSMS(data: SendSMSRequestEvent["data"]): Promise<SMSResult> {
        let notification: any = null;

        try {
            // Create notification record
            notification = await this.createNotificationRecord(data, "SMS");

            logger.info(
                "Processing SMS send request",
                LogCategory.NOTIFICATION,
                {
                    notificationId: notification.id,
                    eventId: data.eventId,
                    recipient: data.recipient.phone,
                    templateName: data.message.templateName,
                }
            );

            let message = data.message.content;

            // Use template if specified
            if (data.message.templateName && data.message.templateData) {
                try {
                    // message = await this.templateService.renderTemplate(
                    //     data.message.templateName,
                    //     data.message.templateData
                    // );
                    const rendered = await this.templateService.renderTemplate(
                        data.message.templateName,
                        data.message.templateData
                    );
                    message = rendered.content;
                } catch (templateError) {
                    logger.error(
                        "SMS template rendering failed",
                        undefined,
                        LogCategory.NOTIFICATION,
                        {
                            templateName: data.message.templateName,
                            error:
                                templateError instanceof Error
                                    ? templateError.message
                                    : String(templateError),
                        }
                    );
                    throw new Error(
                        `SMS template rendering failed: ${templateError instanceof Error ? templateError.message : "Unknown error"}`
                    );
                }
            }

            if (!message) {
                throw new Error("SMS message content is required");
            }

            // Send SMS via provider
            const providerResult: ProviderSMSResult =
                await this.smsProvider.sendSMS({
                    to: data.recipient.phone,
                    message,
                    unicode: data.message.unicode,
                });

            if (providerResult.success) {
                // Update notification as sent
                await this.updateNotificationStatus(notification.id, {
                    success: true,
                    messageId: providerResult.messageId,
                    externalId: providerResult.externalId,
                });

                logger.info("SMS sent successfully", LogCategory.NOTIFICATION, {
                    notificationId: notification.id,
                    messageId: providerResult.messageId,
                    recipient: data.recipient.phone,
                    segments: providerResult.segmentCount,
                });

                return {
                    success: true,
                    messageId: providerResult.messageId,
                    externalId: providerResult.externalId,
                    actualContent: providerResult.actualContent || message,
                    messageLength:
                        providerResult.messageLength || message.length,
                    segmentCount:
                        providerResult.segmentCount ||
                        Math.ceil(message.length / 160),
                    cost: providerResult.cost,
                    provider: providerResult.provider || "unknown",
                    statusUrl: providerResult.statusUrl,
                };
            } else {
                throw new Error(
                    providerResult.errorMessage || "SMS provider failed"
                );
            }
        } catch (error) {
            const errorMessage =
                error instanceof Error ? error.message : "Unknown error";
            const errorCode = this.getSMSErrorCode(error);

            // Update notification as failed
            if (notification) {
                await this.updateNotificationStatus(notification.id, {
                    success: false,
                    errorMessage,
                });
            }

            logger.error(
                "SMS sending failed",
                undefined,
                LogCategory.NOTIFICATION,
                {
                    notificationId: notification?.id,
                    eventId: data.eventId,
                    recipient: data.recipient.phone,
                    error: errorMessage,
                    errorCode,
                }
            );

            return {
                success: false,
                errorMessage,
                errorCode,
            };
        }
    }

    // ========================================
    // FIXED WHATSAPP METHOD
    // ========================================
    async sendWhatsApp(
        data: SendWhatsAppRequestEvent["data"]
    ): Promise<WhatsAppResult> {
        let notification: any = null;

        try {
            // Create notification record
            notification = await this.createNotificationRecord(
                data,
                "WHATSAPP"
            );

            logger.info(
                "Processing WhatsApp send request",
                LogCategory.NOTIFICATION,
                {
                    notificationId: notification.id,
                    eventId: data.eventId,
                    recipient: data.recipient.phone,
                    messageType: data.message.type,
                    templateName: data.message.templateName,
                }
            );

            let message = data.message.content;

            // Use template if specified
            if (data.message.templateName && data.message.templateData) {
                try {
                    // message = await this.templateService.renderTemplate(
                    //     data.message.templateName,
                    //     data.message.templateData
                    // );
                    const rendered = await this.templateService.renderTemplate(
                        data.message.templateName,
                        data.message.templateData
                    );
                    message = rendered.content;
                } catch (templateError) {
                    logger.error(
                        "WhatsApp template rendering failed",
                        undefined,
                        LogCategory.NOTIFICATION,
                        {
                            templateName: data.message.templateName,
                            error:
                                templateError instanceof Error
                                    ? templateError.message
                                    : String(templateError),
                        }
                    );
                    throw new Error(
                        `WhatsApp template rendering failed: ${templateError instanceof Error ? templateError.message : "Unknown error"}`
                    );
                }
            }

            // Send WhatsApp via provider
            const providerResult: ProviderWhatsAppResult =
                await this.whatsappProvider.sendMessage({
                    to: data.recipient.phone,
                    message: message || "",
                    type:
                        data.message.type === "TEMPLATE" ? "TEMPLATE" : "TEXT",
                    templateName: data.message.templateName,
                    templateData: data.message.templateData,
                    mediaUrl: data.message.mediaUrl,
                    mediaType: data.message.mediaType,
                    buttons: data.message.buttons,
                });

            if (providerResult.success) {
                // Update notification as sent
                await this.updateNotificationStatus(notification.id, {
                    success: true,
                    messageId: providerResult.messageId,
                    externalId: providerResult.externalId,
                });

                logger.info(
                    "WhatsApp message sent successfully",
                    LogCategory.NOTIFICATION,
                    {
                        notificationId: notification.id,
                        messageId: providerResult.messageId,
                        recipient: data.recipient.phone,
                        messageType: data.message.type,
                    }
                );

                return {
                    success: true,
                    messageId: providerResult.messageId,
                    externalId: providerResult.externalId,
                    actualContent: providerResult.actualContent || message,
                    cost: providerResult.cost,
                    provider: providerResult.provider || "unknown",
                    conversationId: providerResult.conversationId,
                    conversationType: providerResult.conversationType,
                };
            } else {
                throw new Error(
                    providerResult.errorMessage || "WhatsApp provider failed"
                );
            }
        } catch (error) {
            const errorMessage =
                error instanceof Error ? error.message : "Unknown error";
            const errorCode = this.getWhatsAppErrorCode(error);

            // Update notification as failed
            if (notification) {
                await this.updateNotificationStatus(notification.id, {
                    success: false,
                    errorMessage,
                });
            }

            logger.error(
                "WhatsApp sending failed",
                undefined,
                LogCategory.NOTIFICATION,
                {
                    notificationId: notification?.id,
                    eventId: data.eventId,
                    recipient: data.recipient.phone,
                    messageType: data.message.type,
                    error: errorMessage,
                    errorCode,
                }
            );

            return {
                success: false,
                errorMessage,
                errorCode,
                templateStatus: (error as any)?.templateStatus,
            };
        }
    }

    // ========================================
    // PRIVATE HELPER METHODS
    // ========================================

    private async createNotificationRecord(
        data:
            | SendEmailRequestEvent["data"]
            | SendSMSRequestEvent["data"]
            | SendWhatsAppRequestEvent["data"],
        channel: "EMAIL" | "SMS" | "WHATSAPP"
    ): Promise<any> {
        return await prisma.notification.create({
            data: {
                title: this.extractTitle(data),
                message: this.extractMessage(data),
                type: this.mapNotificationType(data.metadata.sourceEntity),
                channel: channel as any,
                recipientType: data.recipientType,
                recipientId: data.recipientId,
                recipientName: data.recipient.name,
                recipientContact:
                    "email" in data.recipient
                        ? data.recipient.email
                        : data.recipient.phone,
                templateName: this.getTemplateName(data),
                templateData: this.getTemplateData(data),
                userId: data.userId,
                // Map source entity relationships
                ...(data.metadata.sourceEntity === "Invoice" && {
                    invoiceId: data.metadata.sourceEntityId,
                }),
                ...(data.metadata.sourceEntity === "Sale" && {
                    saleId: data.metadata.sourceEntityId,
                }),
                ...(data.metadata.sourceEntity === "InvoicePayment" && {
                    invoicePaymentId: data.metadata.sourceEntityId,
                }),
                ...(data.metadata.sourceEntity === "SaleReceipt" && {
                    saleReceiptId: data.metadata.sourceEntityId,
                }),
                ...(data.metadata.sourceEntity === "EcommerceUser" &&
                    {
                        // No specific relation field in schema for this
                    }),
            },
        });
    }

    private async updateNotificationStatus(
        notificationId: string,
        result: {
            success: boolean;
            messageId?: string;
            externalId?: string;
            deliveredAt?: Date;
            errorMessage?: string;
        }
    ): Promise<void> {
        await prisma.notification.update({
            where: { id: notificationId },
            data: {
                status: result.success ? "SENT" : "FAILED",
                sentAt: result.success ? new Date() : undefined,
                deliveredAt: result.deliveredAt,
                failureReason: result.errorMessage,
                externalId: result.externalId || result.messageId,
            },
        });
    }

    private extractTitle(data: any): string {
        if ("email" in data && data.email?.subject) {
            return data.email.subject;
        }
        if ("message" in data && data.message?.content) {
            return (
                data.message.content.substring(0, 50) +
                (data.message.content.length > 50 ? "..." : "")
            );
        }
        return "Notification";
    }

    private extractMessage(data: any): string {
        if ("email" in data) {
            return (
                data.email?.textBody ||
                data.email?.subject ||
                "Email notification"
            );
        }
        if ("message" in data) {
            return data.message?.content || "Message notification";
        }
        return "Notification message";
    }

    private getTemplateName(data: any): string | undefined {
        if ("email" in data) {
            return data.email?.templateName;
        }
        if ("message" in data) {
            return data.message?.templateName;
        }
        return undefined;
    }

    private getTemplateData(data: any): any {
        if ("email" in data) {
            return data.email?.templateData;
        }
        if ("message" in data) {
            return data.message?.templateData;
        }
        return undefined;
    }

    private mapNotificationType(sourceEntity: string): NotificationType {
        const mapping: Record<string, NotificationType> = {
            Invoice: NotificationType.INVOICE_CREATED,
            Sale: NotificationType.SALE_CREATED,
            InvoicePayment: NotificationType.PAYMENT_CONFIRMATION,
            SaleReceipt: NotificationType.PAYMENT_CONFIRMATION,
            EcommerceUser: NotificationType.WELCOME,
            Customer: NotificationType.WELCOME,
            InventoryItem: NotificationType.STOCK_ALERT,
        };
        return mapping[sourceEntity] || NotificationType.CUSTOM;
    }

    // ========================================
    // ERROR CODE MAPPERS
    // ========================================

    private getEmailErrorCode(error: unknown): string {
        if (error instanceof Error) {
            const message = error.message.toLowerCase();
            if (message.includes("invalid email")) return "INVALID_EMAIL";
            if (message.includes("rate limit")) return "RATE_LIMIT";
            if (message.includes("bounce")) return "EMAIL_BOUNCED";
            if (message.includes("spam")) return "SPAM_DETECTED";
            if (message.includes("authentication")) return "AUTH_FAILED";
            if (message.includes("template")) return "TEMPLATE_ERROR";
        }
        return "EMAIL_SEND_FAILED";
    }

    private getSMSErrorCode(error: unknown): string {
        if (error instanceof Error) {
            const message = error.message.toLowerCase();
            if (message.includes("invalid phone")) return "INVALID_PHONE";
            if (message.includes("rate limit")) return "RATE_LIMIT";
            if (message.includes("insufficient balance"))
                return "INSUFFICIENT_BALANCE";
            if (message.includes("blocked")) return "PHONE_BLOCKED";
            if (message.includes("carrier")) return "CARRIER_ERROR";
            if (message.includes("template")) return "TEMPLATE_ERROR";
        }
        return "SMS_SEND_FAILED";
    }

    private getWhatsAppErrorCode(error: unknown): string {
        if (error instanceof Error) {
            const message = error.message.toLowerCase();
            if (message.includes("invalid phone")) return "INVALID_PHONE";
            if (message.includes("template")) return "TEMPLATE_ERROR";
            if (message.includes("rate limit")) return "RATE_LIMIT";
            if (message.includes("media")) return "MEDIA_ERROR";
            if (message.includes("business account"))
                return "BUSINESS_ACCOUNT_ERROR";
            if (message.includes("country code")) return "INVALID_COUNTRY_CODE";
        }
        return "WHATSAPP_SEND_FAILED";
    }
}

// notification-service/src/services/templateService.ts
import Handlebars from "handlebars";
import { prisma } from "@repo/db/prisma";

export class TemplateService {
    private templates: Map<string, any> = new Map();

    async loadTemplates(): Promise<void> {
        const templates = await prisma.notificationTemplate.findMany({
            where: { isActive: true },
        });

        templates.forEach((template) => {
            this.templates.set(template.name, template);
        });
    }

    // FIX 1: Change return type to match what NotificationService expects
    async renderTemplate(
        templateName: string,
        data: Record<string, any>
    ): Promise<{ content: string; subject?: string }> {
        // Try to get from cache first
        let template = this.templates.get(templateName);

        // If not in cache, fetch from database
        if (!template) {
            template = await prisma.notificationTemplate.findUnique({
                where: { name: templateName },
            });

            if (template) {
                this.templates.set(templateName, template);
            }
        }

        if (!template) {
            throw new Error(`Template not found: ${templateName}`);
        }

        const compiledTemplate = Handlebars.compile(template.content);
        const renderedContent = compiledTemplate(data);

        // Handle subject rendering if it exists and has variables
        let renderedSubject: string | undefined;
        if (template.subject) {
            if (template.subject.includes("{{")) {
                const compiledSubject = Handlebars.compile(template.subject);
                renderedSubject = compiledSubject(data);
            } else {
                renderedSubject = template.subject;
            }
        }

        return {
            content: renderedContent,
            subject: renderedSubject,
        };
    }

    // FIX 2: Add the missing getTemplateInfo method
    async getTemplateInfo(
        templateName: string
    ): Promise<{ channel: string } | null> {
        let template = this.templates.get(templateName);

        if (!template) {
            template = await prisma.notificationTemplate.findUnique({
                where: { name: templateName },
            });
        }

        return template ? { channel: template.channel } : null;
    }

    async renderString(
        content: string,
        data: Record<string, any>
    ): Promise<string> {
        const compiledTemplate = Handlebars.compile(content);
        return compiledTemplate(data);
    }

    // Keep your existing helper registration
    registerHelpers(): void {
        Handlebars.registerHelper("currency", (amount: number) => {
            return `‚Çπ${amount.toLocaleString("en-IN")}`;
        });

        Handlebars.registerHelper("date", (date: string) => {
            return new Date(date).toLocaleDateString("en-IN");
        });

        Handlebars.registerHelper("eq", (a: any, b: any) => {
            return a === b;
        });

        Handlebars.registerHelper("gt", (a: number, b: number) => {
            return a > b;
        });
    }
}

// notification-service/src/services/providers/emailProvider.ts
import nodemailer from "nodemailer";
import {
    EmailData,
    ProviderEmailResult,
} from "@repo/common-backend/interfaces";
import { notificationConfig } from "../../config/index";
import { logger, LogCategory } from "@repo/common-backend/logger";

export class EmailProvider {
    private transporter: nodemailer.Transporter;

    constructor() {
        this.transporter = nodemailer.createTransport({
            host: notificationConfig.email.config.host,
            port: notificationConfig.email.config.port,
            secure: notificationConfig.email.config.secure,
            auth: notificationConfig.email.config.auth,
        });

        // Verify transporter configuration
        this.transporter.verify((error) => {
            if (error) {
                logger.error(
                    "Email transporter configuration failed",
                    undefined,
                    LogCategory.NOTIFICATION,
                    {
                        error: error.message,
                        host: notificationConfig.email.config.host,
                        port: notificationConfig.email.config.port,
                    }
                );
            } else {
                logger.info(
                    "Email transporter ready",
                    LogCategory.NOTIFICATION,
                    {
                        host: notificationConfig.email.config.host,
                        port: notificationConfig.email.config.port,
                    }
                );
            }
        });
    }

    async sendEmail(emailData: EmailData): Promise<ProviderEmailResult> {
        try {
            logger.debug(
                "Preparing email for sending",
                LogCategory.NOTIFICATION,
                {
                    recipient: emailData.to.email,
                    subject: emailData.subject,
                    hasAttachments: !!emailData.attachments?.length,
                }
            );

            // Validate email data
            if (!emailData.to.email || !emailData.subject) {
                throw new Error("Email address and subject are required");
            }

            // Prepare mail options
            const mailOptions: nodemailer.SendMailOptions = {
                from: `${notificationConfig.email.config.fromName} <${notificationConfig.email.config.fromEmail}>`,
                to: `${emailData.to.name} <${emailData.to.email}>`,
                subject: emailData.subject,
                html: emailData.htmlBody,
                text: emailData.textBody,
                attachments: emailData.attachments?.map((att) => ({
                    filename: att.filename,
                    content: Buffer.from(att.content, "base64"), // Assuming base64 content
                    contentType: att.contentType,
                })),
            };

            // Send email
            const result = await this.transporter.sendMail(mailOptions);

            logger.info(
                "Email sent successfully via provider",
                LogCategory.NOTIFICATION,
                {
                    recipient: emailData.to.email,
                    messageId: result.messageId,
                    subject: emailData.subject,
                }
            );

            return {
                success: true,
                messageId: result.messageId,
                externalId: result.messageId, // Nodemailer doesn't provide separate external ID
                cost: this.calculateEmailCost(), // Implement cost calculation
                deliveredAt: new Date(), // For immediate delivery providers like SMTP
            };
        } catch (error) {
            const errorMessage =
                error instanceof Error ? error.message : "Unknown email error";
            const errorCode = this.mapEmailErrorCode(error);

            logger.error(
                "Email sending failed via provider",
                undefined,
                LogCategory.NOTIFICATION,
                {
                    recipient: emailData.to.email,
                    subject: emailData.subject,
                    error: errorMessage,
                    errorCode,
                }
            );

            return {
                success: false,
                errorMessage,
                errorCode,
            };
        }
    }

    private calculateEmailCost(): number {
        // Implement your cost calculation logic here
        // This could be based on provider pricing, email size, etc.
        return Number(notificationConfig.email.costPerEmail) || 0.01;
    }

    private mapEmailErrorCode(error: unknown): string {
        if (error instanceof Error) {
            const message = error.message.toLowerCase();

            // SMTP specific error codes
            if (
                message.includes("invalid login") ||
                message.includes("authentication")
            ) {
                return "SMTP_AUTH_FAILED";
            }
            if (message.includes("recipient address rejected")) {
                return "INVALID_EMAIL";
            }
            if (message.includes("mailbox full") || message.includes("quota")) {
                return "MAILBOX_FULL";
            }
            if (message.includes("spam") || message.includes("blocked")) {
                return "SPAM_DETECTED";
            }
            if (message.includes("timeout") || message.includes("connection")) {
                return "CONNECTION_ERROR";
            }
            if (
                message.includes("rate limit") ||
                message.includes("too many")
            ) {
                return "RATE_LIMIT";
            }
        }

        return "EMAIL_SEND_FAILED";
    }
}

// sms provider

import twilio from "twilio";
import { SMSData, ProviderSMSResult } from "@repo/common-backend/interfaces";
import { notificationConfig } from "../../config/index";
import { logger, LogCategory } from "@repo/common-backend/logger";

export class SMSProvider {
    private client: twilio.Twilio;

    constructor() {
        // Initialize Twilio client
        const accountSid = notificationConfig.sms.config.accountSid;
        const authToken = notificationConfig.sms.config.authToken;

        if (!accountSid || !authToken) {
            throw new Error(
                "Twilio credentials are required (TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN)"
            );
        }

        this.client = twilio(accountSid, authToken);

        logger.info(
            "SMS Provider (Twilio) initialized",
            LogCategory.NOTIFICATION,
            {
                accountSid: accountSid.substring(0, 10) + "...", // Log partial SID for security
            }
        );
    }

    async sendSMS(smsData: SMSData): Promise<ProviderSMSResult> {
        try {
            logger.debug("Sending SMS via Twilio", LogCategory.NOTIFICATION, {
                recipient: smsData.to,
                messageLength: smsData.message.length,
                unicode: smsData.unicode,
                fromNumber: notificationConfig.sms.config.fromNumber,
            });

            // Validate SMS data
            if (!smsData.to || !smsData.message) {
                throw new Error("Phone number and message are required");
            }

            // Ensure phone number format
            const formattedPhone = this.formatPhoneNumber(smsData.to);

            // Calculate message info
            const messageLength = smsData.message.length;
            const segmentSize = smsData.unicode ? 70 : 160;
            const segmentCount = Math.ceil(messageLength / segmentSize);

            // Send SMS via Twilio
            const result = await this.client.messages.create({
                body: smsData.message,
                from: notificationConfig.sms.config.fromNumber,
                to: formattedPhone,
                // Optional: Add status callback URL for delivery tracking
                statusCallback: notificationConfig.sms.config.statusCallbackUrl,
            });

            logger.info(
                "SMS sent successfully via Twilio",
                LogCategory.NOTIFICATION,
                {
                    recipient: formattedPhone,
                    messageId: result.sid,
                    status: result.status,
                    segments: segmentCount,
                    price: result.price,
                    priceUnit: result.priceUnit,
                }
            );

            // Calculate cost (Twilio provides price, but it might be null initially)
            const cost = result.price
                ? parseFloat(result.price)
                : this.calculateSMSCost(segmentCount);

            return {
                success: true,
                messageId: result.sid,
                externalId: result.sid,
                actualContent: smsData.message,
                messageLength,
                segmentCount,
                cost,
                provider: "twilio",
                statusUrl: this.buildStatusUrl(result.sid),
            };
        } catch (error) {
            const errorMessage =
                error instanceof Error ? error.message : "Unknown SMS error";
            const errorCode = this.mapTwilioErrorCode(error);

            logger.error(
                "SMS sending failed via Twilio",
                undefined,
                LogCategory.NOTIFICATION,
                {
                    recipient: smsData.to,
                    error: errorMessage,
                    errorCode,
                    twilioErrorCode: (error as any)?.code,
                    twilioErrorStatus: (error as any)?.status,
                }
            );

            return {
                success: false,
                errorMessage,
                errorCode,
            };
        }
    }

    // ========================================
    // PRIVATE HELPER METHODS
    // ========================================

    private formatPhoneNumber(phone: string): string {
        // Remove any non-digit characters
        const cleaned = phone.replace(/\D/g, "");

        // Add + if not present
        if (!phone.startsWith("+")) {
            // Assume Indian number if no country code (adjust based on your region)
            if (cleaned.length === 10) {
                return `+91${cleaned}`;
            } else if (cleaned.length > 10) {
                return `+${cleaned}`;
            }
        }

        return phone;
    }

    private calculateSMSCost(segmentCount: number): number {
        // Fallback cost calculation if Twilio doesn't provide price immediately
        const costPerSegment = notificationConfig.sms.costPerSegment || 0.05;
        return segmentCount * Number(costPerSegment);
    }

    private buildStatusUrl(messageSid: string): string {
        return `${notificationConfig.sms.config.baseUrl}/status/${messageSid}`;
    }

    private mapTwilioErrorCode(error: any): string {
        // Map Twilio-specific error codes to our standard codes
        const twilioCode = error?.code;
        const message = error?.message?.toLowerCase() || "";

        // Twilio error code mappings
        switch (twilioCode) {
            case 21211:
                return "INVALID_PHONE";
            case 21214:
                return "INVALID_PHONE";
            case 21408:
                return "PERMISSION_DENIED";
            case 21610:
                return "MESSAGE_BLOCKED";
            case 21611:
                return "MESSAGE_BLOCKED";
            case 21617:
                return "PHONE_UNREACHABLE";
            case 21620:
                return "MESSAGE_TOO_LONG";
            case 21902:
                return "MESSAGE_BLOCKED";
            case 30001:
                return "MESSAGE_QUEUED";
            case 30002:
                return "MESSAGE_QUEUED";
            case 30003:
                return "MESSAGE_FAILED";
            case 30004:
                return "MESSAGE_BLOCKED";
            case 30005:
                return "PHONE_UNREACHABLE";
            case 30006:
                return "PHONE_UNREACHABLE";
            case 30007:
                return "CARRIER_VIOLATION";
            case 30008:
                return "MESSAGE_BLOCKED";
            default:
                // Fallback to message-based mapping
                if (
                    message.includes("invalid phone") ||
                    message.includes("invalid number")
                ) {
                    return "INVALID_PHONE";
                }
                if (
                    message.includes("insufficient funds") ||
                    message.includes("balance")
                ) {
                    return "INSUFFICIENT_BALANCE";
                }
                if (message.includes("rate limit")) {
                    return "RATE_LIMIT";
                }
                if (
                    message.includes("blocked") ||
                    message.includes("blacklist")
                ) {
                    return "PHONE_BLOCKED";
                }
                if (
                    message.includes("authentication") ||
                    message.includes("credentials")
                ) {
                    return "AUTH_FAILED";
                }
                return "SMS_SEND_FAILED";
        }
    }

    // ========================================
    // OPTIONAL: STATUS WEBHOOK HANDLER
    // ========================================

    async handleStatusCallback(webhookData: any): Promise<void> {
        // Handle Twilio status callbacks for delivery tracking
        try {
            const { MessageSid, MessageStatus, ErrorCode } = webhookData;

            logger.info(
                "Received SMS status callback from Twilio",
                LogCategory.NOTIFICATION,
                {
                    messageId: MessageSid,
                    status: MessageStatus,
                    errorCode: ErrorCode,
                }
            );

            // Update notification status in database if needed
            // This would integrate with your notification tracking system
        } catch (error) {
            logger.error(
                "Error processing SMS status callback",
                undefined,
                LogCategory.NOTIFICATION,
                {
                    error:
                        error instanceof Error ? error.message : String(error),
                    webhookData,
                }
            );
        }
    }
}
```
