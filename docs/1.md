## Project Structure

Project Overview
Business Requirements
Gangadhara Textiles App is a comprehensive textile business management solution designed for:

Customer Management - Complete CRM with purchase history
Inventory Management - Textile-specific product attributes (fabric, GSM, width, color)
Sales Processing - Point of sale with receipt generation
Invoice Management - B2B invoicing with automated reminders
Payment Processing - Multi-method payment tracking
Communication - WhatsApp, SMS, Email notifications
OCR Integration - Automated document processing
Analytics - Business intelligence and reporting

Architecture Overview

Monorepo Structure - Turborepo with shared packages
Microservices - Event-driven communication via Kafka
Database - PostgreSQL with Prisma ORM
Event Streaming - Apache Kafka for reliable messaging
Validation - Zod schemas for type-safe validation
Authentication - JWT-based with role-based access control

Technology Stack
Core Technologies

Framework: Next.js 14 (Frontend) + Express.js (Backend)
Language: TypeScript
Database: PostgreSQL 15+
ORM: Prisma 5+
Event Streaming: Apache Kafka 3.5+
Validation: Zod
Authentication: JWT
File Upload: Multer

````
GangadharaTextilesApp/
‚îú‚îÄ‚îÄ apps/
‚îÇ   ‚îú‚îÄ‚îÄ accounts/           # Account management service
‚îÇ   ‚îú‚îÄ‚îÄ accounts-web/       # FE for accounts service
‚îÇ   ‚îú‚îÄ‚îÄ auth/               # Authentication service
‚îÇ   ‚îú‚îÄ‚îÄ docs/               # Documentation site
‚îÇ   ‚îú‚îÄ‚îÄ gt/                 # ecomm backend application
‚îÇ   ‚îú‚îÄ‚îÄ gt-web/             # FE for GT application
‚îÇ   ‚îú‚îÄ‚îÄ ocr/                # OCR processing service
‚îÇ   ‚îú‚îÄ‚îÄ checkout-payments/  # Payment processing service
‚îÇ   ‚îú‚îÄ‚îÄ notification/       # Notification management service
‚îÇ   ‚îî‚îÄ‚îÄ android-web/        # (android)
‚îú‚îÄ‚îÄ packages/
‚îÇ   ‚îú‚îÄ‚îÄ common/             # Shared utilities and schemas
‚îÇ   ‚îú‚îÄ‚îÄ common-backend/     # Backend utilities and event system
‚îÇ   ‚îú‚îÄ‚îÄ db/                 # Database layer with Prisma
‚îÇ   ‚îú‚îÄ‚îÄ eslint-config/      # Shared ESLint configuration
‚îÇ   ‚îú‚îÄ‚îÄ typescript-config/  # Shared TypeScript configuration
‚îÇ   ‚îî‚îÄ‚îÄ ui/                 # Shared UI components
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ turbo.json
‚îî‚îÄ‚îÄ README.md

```prisma

// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}


// ========================================
// USER MANAGEMENT
// ========================================

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String
  phone     String?
  password  String
  role      UserRole @default(OWNER)
  isActive  Boolean  @default(true)

  // Security fields
  twoFactorSecret     String?
  twoFactorEnabled    Boolean   @default(false)
  ipWhitelist         Json?     // Array of allowed IP addresses
  failedLoginAttempts Int       @default(0)
  lockedUntil         DateTime?
  lastLoginAt         DateTime?
  lastLoginIP         String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  parties          Party[]
  customers        Customer[]
  invoices         Invoice[]
  invoicePayments  InvoicePayment[]
  saleReceipts     SaleReceipt[]
  sales            Sale[]
  ledgerEntries    LedgerEntry[]
  ocrData          OCRData[]
  reminders        Reminder[]
  notifications    Notification[]
  inventoryItems   InventoryItem[]
  orders           Order[]
  userSessions     UserSession[]
  backups          Backup[]
  restores         Restore[]
  backupSchedule   BackupSchedule?
  auditLogs        AuditLog[]
  stockMovements   StockMovement[]

  @@map("users")
}

model UserSession {
  id           String   @id @default(cuid())
  userId       String
  sessionToken String   @unique
  refreshToken String   @unique
  expiresAt    DateTime
  deviceInfo   Json?    // Device information
  ipAddress    String?
  userAgent    String?
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_sessions")
}

// ========================================
// ECOMMERCE USERS (Public App Users)
// ========================================

model EcommerceUser {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String
  phone     String?
  password  String?  // Nullable for social login users

  // Profile information
  dateOfBirth DateTime?
  gender      String?  // MALE, FEMALE, OTHER
  avatar      String?  // Profile picture URL

  // Address information
  addresses   Json     @default("[]") // [{type: 'home|office', name, phone, address, city, state, pincode, isDefault}]

  // Authentication & Security
  emailVerified     Boolean   @default(false)
  phoneVerified     Boolean   @default(false)
  emailVerificationToken String?
  phoneVerificationToken String?
  passwordResetToken     String?
  passwordResetExpiry    DateTime?

  // Social login
  googleId          String?
  facebookId        String?

  // Account status
  isActive          Boolean   @default(true)
  isBlocked         Boolean   @default(false)
  blockedReason     String?
  blockedAt         DateTime?

  // Preferences
  preferences       Json      @default("{}") // {newsletter: true, sms: true, whatsapp: true, language: 'en'}

  // Marketing
  referralCode      String?   @unique
  referredBy        String?

  // Metadata
  lastLoginAt       DateTime?
  lastLoginIP       String?
  signupSource      String?   // WEBSITE, MOBILE_APP, SOCIAL, REFERRAL

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  orders            Order[]
  ecommerceUserSessions EcommerceUserSession[]
  reviews           Review[]
  wishlistItems     WishlistItem[]
  cartItems         CartItem[]

  @@index([email])
  @@index([phone])
  @@index([referralCode])
  @@index([isActive])
  @@map("ecommerce_users")
}

model EcommerceUserSession {
  id           String   @id @default(cuid())
  userId       String
  sessionToken String   @unique
  refreshToken String   @unique
  expiresAt    DateTime
  deviceInfo   Json?    // {type: 'mobile|desktop', os, browser, version}
  ipAddress    String?
  userAgent    String?
  isActive     Boolean  @default(true)

  ecommerceUser EcommerceUser @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([userId])
  @@index([sessionToken])
  @@map("ecommerce_user_sessions")
}

// ========================================
// BUSINESS ENTITIES
// ========================================

model Customer {
  id          String  @id @default(cuid())
  name        String
  phone       String?
  email       String?
  address     String?
  city        String?
  state       String?
  pincode     String?
  gstNumber   String?
  creditLimit Decimal @default(0) @db.Decimal(12, 2)

  // Additional fields
  dateOfBirth      DateTime?
  anniversary      DateTime?
  preferredContact String?    // email, phone, whatsapp
  tags             String[]   // VIP, Regular, New, etc.
  notes            String?
  isActive         Boolean    @default(true)

  userId      String
  user        User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  sales         Sale[]
  saleReceipts  SaleReceipt[]
  ledger        LedgerEntry[]
  reminders     Reminder[]
  notifications Notification[]
  orders        Order[]

  @@index([userId])
  @@index([name])
  @@index([phone])
  @@index([email])
  @@map("customers")
}

model Party {
  id            String  @id @default(cuid())
  name          String
  gstNo         String?
  panNo         String?
  phone         String?
  email         String?
  address       String?
  city          String?
  state         String?
  pincode       String?
  contactPerson String?
  bankDetails   Json?   // {bankName, accountNo, ifsc, branch}

  // Additional fields
  category      String?  // Manufacturer, Distributor, Wholesaler
  paymentTerms  Int?     // Payment terms in days
  creditLimit   Decimal  @default(0) @db.Decimal(12, 2)
  taxId         String?
  website       String?
  notes         String?
  isActive      Boolean  @default(true)

  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  invoices         Invoice[]
  invoicePayments  InvoicePayment[]
  ledger           LedgerEntry[]
  notifications    Notification[]

  @@unique([gstNo, userId], name: "unique_gst_per_user")
  @@index([userId])
  @@index([name])
  @@index([gstNo])
  @@map("parties")
}

// ========================================
// INVENTORY MANAGEMENT
// ========================================

model InventoryItem {
  id          String   @id @default(cuid())
  name        String
  description String?
  sku         String?  @unique
  barcode     String?  @unique
  category    String
  subCategory String?
  brand       String?

  // Pricing
  sellingPrice Decimal  @db.Decimal(10, 2)
  costPrice    Decimal? @db.Decimal(10, 2)
  mrp          Decimal? @db.Decimal(10, 2)

  // Stock management
  currentStock    Int      @default(0)
  minimumStock    Int      @default(0)
  maximumStock    Int?
  reorderLevel    Int?
  unit            String   @default("PCS") // PCS, MTR, KG, etc.

  // Textile specific fields
  fabric          String?  // Cotton, Silk, Polyester, etc.
  gsm             Int?     // Grams per square meter
  width           Decimal? @db.Decimal(8, 2) // Width in inches/cm
  color           String?
  design          String?
  pattern         String?
  weaveType       String?  // Plain, Twill, Satin, etc.

  // Product details
  images          Json     @default("[]")
  attributes      Json     @default("{}")

  // Tax and compliance
  hsnCode         String?
  taxRate         Decimal? @db.Decimal(5, 2)

  // Storage and supplier info
  location        String?  // Storage location in shop
  supplier        String?
  leadTime        Int?     // Days
  lastPurchaseDate DateTime?
  lastPurchasePrice Decimal? @db.Decimal(10, 2)

  isActive        Boolean  @default(true)

  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  orderItems      OrderItem[]
  stockMovements  StockMovement[]
  reviews         Review[]
  wishlistItems   WishlistItem[]
  cartItems       CartItem[]

  @@index([userId])
  @@index([category])
  @@index([isActive])
  @@index([sku])
  @@index([barcode])
  @@index([currentStock])
  @@map("inventory_items")
}

model StockMovement {
  id            String       @id @default(cuid())
  inventoryItemId String
  inventoryItem   InventoryItem @relation(fields: [inventoryItemId], references: [id], onDelete: Cascade)

  type          MovementType // IN, OUT, ADJUSTMENT, TRANSFER
  quantity      Int
  previousStock Int
  newStock      Int
  reason        String?
  reference     String?      // Sale ID, Purchase ID, etc.
  batchNumber   String?      // For textile rolls/batches

  // Additional details
  unitPrice     Decimal?     @db.Decimal(10, 2)
  totalValue    Decimal?     @db.Decimal(12, 2)
  notes         String?

  userId        String
  user          User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt     DateTime     @default(now())

  @@index([inventoryItemId])
  @@index([userId])
  @@index([type])
  @@index([createdAt])
  @@map("stock_movements")
}

// ========================================
// SALES TRANSACTIONS
// ========================================

model Sale {
  id              String     @id @default(cuid())
  voucherId       String     @unique
  saleNo          String
  date            DateTime
  amount          Decimal    @db.Decimal(12, 2)
  paidAmount      Decimal    @default(0) @db.Decimal(12, 2)
  remainingAmount Decimal    @db.Decimal(12, 2)
  status          SaleStatus @default(PENDING)

  // Sale items - storing as JSON for flexibility in textile business
  items           Json       // [{itemName, itemType, design, color, price, quantity, total, hsnCode, unit}]

  // Financial details
  taxAmount       Decimal?   @db.Decimal(12, 2)
  discountAmount  Decimal?   @default(0) @db.Decimal(12, 2)
  roundOffAmount  Decimal?   @default(0) @db.Decimal(12, 2)

  // Additional sale details
  salesPerson     String?
  deliveryDate    DateTime?
  deliveryAddress String?
  transportation  String?
  vehicleNo       String?
  reference       String?    // Customer's reference
  terms           String?    // Payment terms
  notes           String?

  customerId      String
  customer        Customer   @relation(fields: [customerId], references: [id], onDelete: Cascade)

  userId          String
  user            User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt

  // Relations
  saleReceipts    SaleReceipt[]
  ledger          LedgerEntry[]
  notifications   Notification[]

  @@unique([saleNo, customerId, userId], name: "unique_sale_per_customer")
  @@index([userId])
  @@index([customerId])
  @@index([status])
  @@index([date])
  @@map("sales")
}

// ========================================
// PURCHASE TRANSACTIONS
// ========================================

model Invoice {
  id              String        @id @default(cuid())
  voucherId       String        @unique
  invoiceNo       String
  date            DateTime
  dueDate         DateTime?
  amount          Decimal       @db.Decimal(12, 2)
  paidAmount      Decimal       @default(0) @db.Decimal(12, 2)
  remainingAmount Decimal       @db.Decimal(12, 2)
  status          InvoiceStatus @default(PENDING)

  // Invoice line items - flexible JSON structure for textile purchases
  items           Json?         // [{description, quantity, rate, amount, hsnCode, taxRate}]

  description     String?
  taxAmount       Decimal?      @db.Decimal(12, 2)
  discountAmount  Decimal?      @default(0) @db.Decimal(12, 2)
  roundOffAmount  Decimal?      @default(0) @db.Decimal(12, 2)
  notes           String?

  // Additional invoice fields
  poNumber        String?       // Purchase Order Number
  transportMode   String?
  vehicleNo       String?
  deliveryNote    String?
  supplierRef     String?
  otherRef        String?
  buyersOrderNo   String?
  dispatchedThrough String?
  destination     String?

  partyId         String
  party           Party         @relation(fields: [partyId], references: [id], onDelete: Cascade)

  userId          String
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // Relations
  invoicePayments InvoicePayment[]
  ledger          LedgerEntry[]
  ocrData         OCRData?
  notifications   Notification[]

  @@unique([invoiceNo, partyId, userId], name: "unique_invoice_per_party")
  @@index([userId])
  @@index([partyId])
  @@index([status])
  @@index([date])
  @@index([dueDate])
  @@map("invoices")
}

// ========================================
// PAYMENT TRANSACTIONS
// ========================================

model InvoicePayment {
  id          String        @id @default(cuid())
  voucherId   String        @unique
  amount      Decimal       @db.Decimal(12, 2)
  date        DateTime
  method      PaymentMethod
  reference   String?       // Bank ref, cheque no, UPI transaction ID
  description String?
  status      PaymentStatus @default(COMPLETED)

  // Gateway fields for online payments
  gatewayOrderId   String?
  gatewayPaymentId String?
  transactionId    String?
  failureReason    String?

  // Banking details
  bankName        String?
  chequeNo        String?
  chequeDate      DateTime?
  clearanceDate   DateTime?
  charges         Decimal? @db.Decimal(8, 2)

  // Relations
  partyId     String
  party       Party        @relation(fields: [partyId], references: [id], onDelete: Cascade)

  invoiceId   String?
  invoice     Invoice?     @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  userId      String
  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  // Relations
  ledger        LedgerEntry[]
  ocrData       OCRData?
  notifications Notification[]

  @@index([userId])
  @@index([method])
  @@index([date])
  @@index([partyId])
  @@index([invoiceId])
  @@map("invoice_payments")
}

model SaleReceipt {
  id          String   @id @default(cuid())
  voucherId   String   @unique
  receiptNo   String
  date        DateTime
  amount      Decimal  @db.Decimal(12, 2)
  method      PaymentMethod
  description String?
  reference   String?  // Transaction reference
  imageUrl    String?  // Photo of physical receipt

  // Banking details
  bankName        String?
  chequeNo        String?
  chequeDate      DateTime?
  clearanceDate   DateTime?
  charges         Decimal? @db.Decimal(8, 2)

  // Relations
  customerId  String
  customer    Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)

  saleId      String?
  sale        Sale?    @relation(fields: [saleId], references: [id], onDelete: Cascade)

  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  ledger        LedgerEntry[]
  ocrData       OCRData?
  notifications Notification[]

  @@unique([receiptNo, customerId, userId], name: "unique_receipt_per_customer")
  @@index([userId])
  @@index([customerId])
  @@index([date])
  @@index([method])
  @@map("sale_receipts")
}

// ========================================
// E-COMMERCE FEATURES
// ========================================

model Review {
  id        String   @id @default(cuid())
  rating    Int      // 1-5 stars
  title     String?
  comment   String?
  images    Json     @default("[]") // Array of image URLs

  // Status
  isVerified Boolean @default(false) // Verified purchase review
  isApproved Boolean @default(false) // Admin approved

  // Relations
  inventoryItemId String
  inventoryItem   InventoryItem @relation(fields: [inventoryItemId], references: [id], onDelete: Cascade)

  ecommerceUserId String
  ecommerceUser   EcommerceUser @relation(fields: [ecommerceUserId], references: [id], onDelete: Cascade)

  orderId     String? // Link to purchase for verified reviews
  order       Order?  @relation(fields: [orderId], references: [id], onDelete: SetNull)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([inventoryItemId])
  @@index([ecommerceUserId])
  @@index([rating])
  @@index([isApproved])
  @@map("reviews")
}

model WishlistItem {
  id        String   @id @default(cuid())

  inventoryItemId String
  inventoryItem   InventoryItem @relation(fields: [inventoryItemId], references: [id], onDelete: Cascade)

  ecommerceUserId String
  ecommerceUser   EcommerceUser @relation(fields: [ecommerceUserId], references: [id], onDelete: Cascade)

  createdAt   DateTime @default(now())

  @@unique([inventoryItemId, ecommerceUserId])
  @@index([ecommerceUserId])
  @@map("wishlist_items")
}

model CartItem {
  id        String   @id @default(cuid())
  quantity  Int      @default(1)

  inventoryItemId String
  inventoryItem   InventoryItem @relation(fields: [inventoryItemId], references: [id], onDelete: Cascade)

  ecommerceUserId String
  ecommerceUser   EcommerceUser @relation(fields: [ecommerceUserId], references: [id], onDelete: Cascade)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([inventoryItemId, ecommerceUserId])
  @@index([ecommerceUserId])
  @@map("cart_items")
}

model Order {
  id             String      @id @default(cuid())
  orderNo        String      @unique
  date           DateTime    @default(now())
  status         OrderStatus @default(PENDING)
  totalAmount    Decimal     @db.Decimal(12, 2)
  paidAmount     Decimal     @default(0) @db.Decimal(12, 2)
  shippingAmount Decimal     @default(0) @db.Decimal(12, 2)
  taxAmount      Decimal     @default(0) @db.Decimal(12, 2)
  discountAmount Decimal     @default(0) @db.Decimal(12, 2)

  shippingAddress Json?      // {name, phone, address, city, state, pincode}
  billingAddress  Json?
  notes          String?

  // Additional fields
  source         String?     // ONLINE, PHONE, WALK_IN, ECOMMERCE
  priority       String?     // HIGH, NORMAL, LOW
  expectedDelivery DateTime?
  actualDelivery   DateTime?
  trackingNumber   String?

  // Relations - Can be either internal customer or ecommerce user
  customerId      String?
  customer        Customer?     @relation(fields: [customerId], references: [id], onDelete: Cascade)

  ecommerceUserId String?
  ecommerceUser   EcommerceUser? @relation(fields: [ecommerceUserId], references: [id], onDelete: Cascade)

  userId         String
  user           User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt

  // Relations
  items          OrderItem[]
  payments       OrderPayment[]
  notifications  Notification[]
  reviews        Review[]

  @@index([userId])
  @@index([customerId])
  @@index([ecommerceUserId])
  @@index([status])
  @@index([date])
  @@map("orders")
}

model OrderItem {
  id        String  @id @default(cuid())
  quantity  Int
  price     Decimal @db.Decimal(10, 2)
  total     Decimal @db.Decimal(12, 2)
  discount  Decimal @default(0) @db.Decimal(8, 2)

  inventoryItemId String
  inventoryItem   InventoryItem @relation(fields: [inventoryItemId], references: [id], onDelete: Cascade)

  orderId   String
  order     Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([orderId])
  @@index([inventoryItemId])
  @@map("order_items")
}

model OrderPayment {
  id               String        @id @default(cuid())
  amount           Decimal       @db.Decimal(12, 2)
  method           PaymentMethod
  status           String        // pending, completed, failed, refunded
  gatewayOrderId   String?       // Razorpay/Stripe order ID
  gatewayPaymentId String?       // Razorpay/Stripe payment ID
  transactionId    String?
  failureReason    String?

  orderId          String
  order            Order         @relation(fields: [orderId], references: [id], onDelete: Cascade)

  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt

  @@index([orderId])
  @@index([status])
  @@map("order_payments")
}

// ========================================
// LEDGER & ACCOUNTING
// ========================================

model LedgerEntry {
  id          String     @id @default(cuid())
  date        DateTime
  description String
  debit       Decimal    @default(0) @db.Decimal(12, 2)
  credit      Decimal    @default(0) @db.Decimal(12, 2)
  balance     Decimal    @db.Decimal(12, 2)
  type        LedgerType
  reference   String?    // Reference to source document

  // Relations (nullable for flexibility)
  partyId     String?
  party       Party?     @relation(fields: [partyId], references: [id], onDelete: Cascade)

  customerId  String?
  customer    Customer?  @relation(fields: [customerId], references: [id], onDelete: Cascade)

  invoiceId   String?
  invoice     Invoice?   @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  saleId      String?
  sale        Sale?      @relation(fields: [saleId], references: [id], onDelete: Cascade)

  invoicePaymentId String?
  invoicePayment   InvoicePayment? @relation(fields: [invoicePaymentId], references: [id], onDelete: Cascade)

  saleReceiptId    String?
  saleReceipt      SaleReceipt?    @relation(fields: [saleReceiptId], references: [id], onDelete: Cascade)

  userId      String
  user        User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  @@index([userId])
  @@index([partyId])
  @@index([customerId])
  @@index([date])
  @@index([type])
  @@map("ledger_entries")
}

// ========================================
// COMMUNICATION & NOTIFICATIONS
// ========================================

model Notification {
  id        String             @id @default(cuid())
  title     String
  message   String
  type      NotificationType
  channel   NotificationChannel
  status    NotificationStatus @default(PENDING)

  // Recipient details
  recipientType String           // CUSTOMER, PARTY, USER
  recipientId   String
  recipientName String
  recipientContact String?

  // Message details
  templateName String?
  templateData Json?

  // Delivery details
  sentAt       DateTime?
  deliveredAt  DateTime?
  readAt       DateTime?
  failureReason String?
  retryCount   Int              @default(0)
  maxRetries   Int              @default(3)

  // External service details
  externalId   String?
  externalData Json?

  // Relations (nullable - notification can be related to any entity)
  partyId    String?
  party      Party?    @relation(fields: [partyId], references: [id], onDelete: Cascade)

  customerId String?
  customer   Customer? @relation(fields: [customerId], references: [id], onDelete: Cascade)

  invoiceId  String?
  invoice    Invoice?  @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  saleId     String?
  sale       Sale?     @relation(fields: [saleId], references: [id], onDelete: Cascade)

  invoicePaymentId String?
  invoicePayment   InvoicePayment? @relation(fields: [invoicePaymentId], references: [id], onDelete: Cascade)

  saleReceiptId    String?
  saleReceipt      SaleReceipt?    @relation(fields: [saleReceiptId], references: [id], onDelete: Cascade)

  orderId    String?
  order      Order?    @relation(fields: [orderId], references: [id], onDelete: Cascade)

  userId     String
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  @@index([userId])
  @@index([status])
  @@index([type])
  @@index([channel])
  @@index([recipientType, recipientId])
  @@index([createdAt])
  @@index([sentAt])
  @@map("notifications")
}


model NotificationTemplate {
  id          String   @id @default(cuid())
  name        String   @unique
  channel     NotificationChannel
  type        NotificationType
  subject     String?  // For email templates
  content     String   // Template content with placeholders
  variables   Json     // Expected variables and their types
  metadata    Json?    // Additional template metadata
  isActive    Boolean  @default(true)
  category    String?
  description String?

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([channel, type])
  @@index([isActive])
  @@map("notification_templates")
}

model Reminder {
  id          String         @id @default(cuid())
  message     String
  type        ReminderType
  status      ReminderStatus @default(PENDING)
  scheduledAt DateTime
  sentAt      DateTime?
  channel     String         // whatsapp, sms, email
  metadata    Json?          // Additional data like template variables

  customerId  String
  customer    Customer       @relation(fields: [customerId], references: [id], onDelete: Cascade)

  userId      String
  user        User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  @@index([userId])
  @@index([customerId])
  @@index([status])
  @@index([scheduledAt])
  @@map("reminders")
}

// ========================================
// OCR & DOCUMENT PROCESSING
// ========================================

model OCRData {
  id            String    @id @default(cuid())
  imageUrl      String
  originalName  String?   // Original filename
  fileSize      Int?      // File size in bytes
  extractedData Json      @default("{}") // Raw extracted data from OCR
  processedData Json?     // Cleaned and structured data
  confidence    Float?
  status        OCRStatus @default(PROCESSING)
  errorMessage  String?   // Error details if failed

  // Relations (nullable - one OCR can be linked to any document)
  invoiceId     String?   @unique
  invoice       Invoice?  @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  invoicePaymentId String? @unique
  invoicePayment   InvoicePayment? @relation(fields: [invoicePaymentId], references: [id], onDelete: Cascade)

  saleReceiptId    String? @unique
  saleReceipt      SaleReceipt? @relation(fields: [saleReceiptId], references: [id], onDelete: Cascade)

  userId        String
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@index([userId])
  @@index([status])
  @@map("ocr_data")
}

// ========================================
// BACKUP & SYSTEM MANAGEMENT
// ========================================

model Backup {
  id          String    @id @default(cuid())
  type        String    // FULL, INCREMENTAL, SCHEMA
  description String?
  status      String    // IN_PROGRESS, COMPLETED, FAILED
  filePath    String?
  cloudPath   String?
  fileSize    BigInt?
  startedAt   DateTime
  completedAt DateTime?
  errorMessage String?

  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([userId])
  @@index([status])
  @@map("backups")
}

model Restore {
  id          String    @id @default(cuid())
  backupId    String
  status      String    // IN_PROGRESS, COMPLETED, FAILED
  startedAt   DateTime
  completedAt DateTime?
  errorMessage String?

  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([userId])
  @@index([status])
  @@map("restores")
}

model BackupSchedule {
  id        String   @id @default(cuid())
  frequency String   // DAILY, WEEKLY, MONTHLY
  time      String   // HH:MM format
  type      String   // FULL, INCREMENTAL
  enabled   Boolean  @default(true)

  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("backup_schedules")
}

// ========================================
// AUDIT & COMPLIANCE
// ========================================

model AuditLog {
  id        String   @id @default(cuid())
  userId    String?
  user      User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  action    String   // CREATE, UPDATE, DELETE, LOGIN, etc.
  entity    String   // Table name or resource
  entityId  String   // Record ID
  oldData   Json?    // Previous data
  newData   Json?    // New data
  metadata  Json?    // Additional context
  ipAddress String?
  userAgent String?

  createdAt DateTime @default(now())

  @@index([userId])
  @@index([entity])
  @@index([action])
  @@index([createdAt])
  @@map("audit_logs")
}

model SystemConfig {
  id    String @id @default(cuid())
  key   String @unique
  value Json

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("system_config")
}

// ========================================
// ENUMS
// ========================================

enum UserRole {
  OWNER
  MANAGER
  STAFF
  VIEWER
  ACCOUNTANT
}

enum InvoiceStatus {
  PENDING
  PARTIALLY_PAID
  PAID
  OVERDUE
  CANCELLED
}

enum SaleStatus {
  PENDING
  PARTIALLY_PAID
  PAID
  OVERDUE
  CANCELLED
  RETURNED
}

enum PaymentMethod {
  CASH
  BANK_TRANSFER
  CHEQUE
  UPI
  CARD
  ONLINE
  OTHER
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  CANCELLED
  REFUNDED
}

enum LedgerType {
  // Document creation entries
  INVOICE_CREATED           // When invoice is received from supplier
  SALE_CREATED             // When sale is made to customer

  // Payment entries
  INVOICE_PAYMENT          // Payment made to supplier
  SALE_RECEIPT             // Receipt from customer
  EXPENSE_PAYMENT          // General business expenses
  ADVANCE_PAYMENT_MADE     // Advance paid to supplier
  ADVANCE_PAYMENT_RECEIVED // Advance received from customer

  // Adjustments
  ADJUSTMENT
  OPENING_BALANCE
  CLOSING_BALANCE

  // Additional specific types
  DISCOUNT_ALLOWED         // Discount given to customer
  DISCOUNT_RECEIVED        // Discount from supplier
  BAD_DEBT_WRITEOFF       // Uncollectable customer debt
  BANK_CHARGES            // Bank transaction charges
  INTEREST_EARNED         // Interest income
  INTEREST_PAID           // Interest expense
}

enum ReminderType {
  PAYMENT_DUE
  OVERDUE_PAYMENT
  FOLLOW_UP
  CUSTOM
  BIRTHDAY
  ANNIVERSARY
  STOCK_REORDER
  TAX_FILING
}

enum ReminderStatus {
  PENDING
  SENT
  DELIVERED
  FAILED
  CANCELLED
}

enum OCRStatus {
  PROCESSING
  COMPLETED
  FAILED
  MANUAL_REVIEW
  CANCELLED
}

enum OrderStatus {
  PENDING
  CONFIRMED
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
  RETURNED
  REFUNDED
}

enum NotificationType {
  PAYMENT_REMINDER
  PAYMENT_CONFIRMATION
  INVOICE_CREATED
  INVOICE_OVERDUE
  SALE_CREATED
  ORDER_CONFIRMATION
  ORDER_STATUS_UPDATE
  STOCK_ALERT
  LOW_STOCK_ALERT
  REORDER_ALERT
  CUSTOM
  WELCOME
  BIRTHDAY
  ANNIVERSARY
  PROMOTIONAL
  SYSTEM_ALERT
  BACKUP_COMPLETED
  BACKUP_FAILED
}

enum NotificationChannel {
  WHATSAPP
  SMS
  EMAIL
  PUSH
  IN_APP
}

enum NotificationStatus {
  PENDING
  SENT
  DELIVERED
  READ
  FAILED
  CANCELLED
}

enum MovementType {
  IN          // Stock received
  OUT         // Stock sold/dispatched
  ADJUSTMENT  // Manual stock correction
  TRANSFER    // Transfer between locations
  RETURN      // Customer/supplier returns
  DAMAGE      // Damaged goods writeoff
  SAMPLE      // Sample given to customer
  WASTAGE     // Production wastage
}

```

```typescript
// packages/common/events/subjects.ts

// Event subjects for Kafka messaging
export enum Subjects {
    // ========================================
    // üîê AUTHENTICATION & USER MANAGEMENT
    // ========================================

    // User Lifecycle
    UserCreated = "user:created",
    UserUpdated = "user:updated",
    UserDeleted = "user:deleted",
    UserActivated = "user:activated",
    UserDeactivated = "user:deactivated",
    UserRoleChanged = "user:role-changed",
    UserPasswordChanged = "user:password-changed",

    // Authentication Events
    UserLoggedIn = "user:logged-in",
    UserLoggedOut = "user:logged-out",
    UserLoginFailed = "user:login-failed",
    UserTokenRefreshed = "user:token-refreshed",
    UserPasswordResetRequested = "user:password-reset-requested",
    UserPasswordResetCompleted = "user:password-reset-completed",

    // Session Management
    SessionCreated = "session:created",
    SessionExpired = "session:expired",
    SessionTerminated = "session:terminated",

    // Security Events
    SuspiciousActivityDetected = "security:suspicious-activity",
    UserAccountLocked = "user:account-locked",
    AccessAttemptFailed = "security:access-failed",

    // ========================================
    // üí• PARTY/SUPPLIER MANAGEMENT
    // ========================================

    PartyCreated = "party:created",
    PartyUpdated = "party:updated",
    PartyDeleted = "party:deleted",
    PartyActivated = "party:activated",
    PartyDeactivated = "party:deactivated",
    PartyContactUpdated = "party:contact-updated",
    PartyGSTUpdated = "party:gst-updated",
    PartyBankDetailsUpdated = "party:bank-details-updated",
    PartyPaymentTermsUpdated = "party:payment-terms-updated",
    PartyStatementSent = "party:statement-sent",

    // ========================================
    // üõí CUSTOMER MANAGEMENT
    // ========================================

    CustomerCreated = "customer:created",
    CustomerUpdated = "customer:updated",
    CustomerDeleted = "customer:deleted",
    CustomerActivated = "customer:activated",
    CustomerDeactivated = "customer:deactivated",
    CustomerContactUpdated = "customer:contact-updated",
    CustomerCreditLimitUpdated = "customer:credit-limit-updated",
    CustomerCreditLimitExceeded = "customer:credit-limit-exceeded",
    CustomerCreditLimitWarning = "customer:credit-limit-warning",
    CustomerFirstVisit = "customer:first-visit",

    // ========================================
    // üìÑ INVOICE MANAGEMENT
    // ========================================

    // Invoice Lifecycle
    InvoiceCreated = "invoice:created",
    InvoiceUpdated = "invoice:updated",
    InvoiceDeleted = "invoice:deleted",
    InvoiceCancelled = "invoice:cancelled",
    InvoiceVoided = "invoice:voided",
    InvoiceDraftCreated = "invoice:draft-created",
    InvoiceSent = "invoice:sent",
    InvoiceViewed = "invoice:viewed",

    // Invoice Payment Status
    InvoicePaid = "invoice:paid",
    InvoicePartiallyPaid = "invoice:partially-paid",
    InvoiceOverdue = "invoice:overdue",
    InvoiceDueSoon = "invoice:due-soon",
    InvoiceDueToday = "invoice:due-today",
    InvoicePaymentReceived = "invoice:payment-received",

    // Invoice Actions
    InvoicePrinted = "invoice:printed",
    InvoiceEmailed = "invoice:emailed",
    InvoiceWhatsAppSent = "invoice:whatsapp-sent",
    InvoiceReminderSent = "invoice:reminder-sent",
    InvoiceFollowUpRequired = "invoice:follow-up-required",
    InvoiceGSTValidated = "invoice:gst-validated",
    InvoiceAnalyticsGenerated = "invoice:analytics-generated",

    // ========================================
    // üõç SALES MANAGEMENT
    // ========================================

    // Sale Lifecycle
    SaleCreated = "sale:created",
    SaleUpdated = "sale:updated",
    SaleDeleted = "sale:deleted",
    SaleCancelled = "sale:cancelled",
    SaleCompleted = "sale:completed",
    SaleReturned = "sale:returned",
    SalePartiallyReturned = "sale:partially-returned",
    SaleExchanged = "sale:exchanged",

    // Sale Payment Status
    SalePaid = "sale:paid",
    SalePartiallyPaid = "sale:partially-paid",
    SaleCreditSale = "sale:credit-sale",
    SaleCashSale = "sale:cash-sale",
    SaleOverdue = "sale:overdue",

    // Sale Operations
    SaleReceiptPrinted = "sale:receipt-printed",
    SaleReceiptEmailed = "sale:receipt-emailed",
    SaleReceiptWhatsAppSent = "sale:receipt-whatsapp-sent",
    SaleTrendAnalyzed = "sale:trend-analyzed",

    // ========================================
    // üí∞ INVOICE PAYMENT MANAGEMENT
    // ========================================

    // Invoice Payment Lifecycle
    InvoicePaymentCreated = "invoice-payment:created",
    InvoicePaymentUpdated = "invoice-payment:updated",
    InvoicePaymentDeleted = "invoice-payment:deleted",
    InvoicePaymentVoided = "invoice-payment:voided",

    // Invoice Payment Processing
    InvoicePaymentProcessed = "invoice-payment:processed",
    InvoicePaymentFailed = "invoice-payment:failed",
    InvoicePaymentPending = "invoice-payment:pending",
    InvoicePaymentConfirmed = "invoice-payment:confirmed",
    InvoicePaymentReconciled = "invoice-payment:reconciled",
    InvoicePaymentRefunded = "invoice-payment:refunded",

    // Invoice Payment Methods
    CashInvoicePaymentMade = "invoice-payment:cash-made",
    UPIInvoicePaymentMade = "invoice-payment:upi-made",
    BankTransferInvoicePaymentMade = "invoice-payment:bank-transfer-made",
    ChequeInvoicePaymentMade = "invoice-payment:cheque-made",
    CardInvoicePaymentMade = "invoice-payment:card-made",
    InvoicePaymentTrendAnalyzed = "invoice-payment:trend-analysed",
    InvoicePaymentAllocated = "invoice-payment:allocated",
    BankTransferStatusUpdated = "invoice-payment:banktransfer-statusupdated",
    ChequeStatusUpdated = "invoice-payment:chequestatusupdated",

    // ========================================
    // üßæ SALE RECEIPT MANAGEMENT
    // ========================================

    SaleReceiptCreated = "sale-receipt:created",
    SaleReceiptUpdated = "sale-receipt:updated",
    SaleReceiptDeleted = "sale-receipt:deleted",
    SaleReceiptVoided = "sale-receipt:voided",
    // SaleReceiptPrinted = "sale-receipt:printed",
    // SaleReceiptEmailed = "sale-receipt:emailed",
    // SaleReceiptWhatsAppSent = "sale-receipt:whatsapp-sent",

    // ========================================
    // üìä LEDGER & ACCOUNTING
    // ========================================

    // Ledger Operations
    LedgerEntryCreated = "ledger:entry-created",
    LedgerEntryUpdated = "ledger:entry-updated",
    LedgerEntryDeleted = "ledger:entry-deleted",
    LedgerBalanceUpdated = "ledger:balance-updated",
    LedgerReconciled = "ledger:reconciled",
    LedgerAdjustmentMade = "ledger:adjustment-made",

    // Financial Periods
    DayBookClosed = "daybook:closed",
    MonthClosed = "month:closed",
    FinancialYearOpened = "financial-year:opened",
    FinancialYearClosed = "financial-year:closed",

    // Tax & GST
    GSTCalculated = "gst:calculated",
    GSTReturnGenerated = "gst:return-generated",
    GSTReturnFiled = "gst:return-filed",
    TaxCalculated = "tax:calculated",
    TDSCalculated = "tds:calculated",

    // ========================================
    // üì± REMINDERS & NOTIFICATIONS
    // ========================================

    // Reminder Lifecycle
    ReminderCreated = "reminder:created",
    ReminderScheduled = "reminder:scheduled",
    ReminderSent = "reminder:sent",
    ReminderDelivered = "reminder:delivered",
    ReminderRead = "reminder:read",
    ReminderFailed = "reminder:failed",
    ReminderCancelled = "reminder:cancelled",
    ReminderSnoozed = "reminder:snoozed",
    ReminderCompleted = "reminder:completed",

    // Notification Types
    PaymentReminderSent = "notification:payment-reminder-sent",
    OverdueNotificationSent = "notification:overdue-sent",
    WelcomeNotificationSent = "notification:welcome-sent",
    BirthdayReminderSent = "notification:birthday-reminder-sent",
    FestivalGreetingSent = "notification:festival-greeting-sent",

    // REQUEST SUBJECTS (what other services publish)
    SendEmailRequested = "notification:send-email-requested",
    SendSMSRequested = "notification:send-sms-requested",
    SendWhatsAppRequested = "notification:send-whatsapp-requested",

    // Communication Channels
    WhatsAppMessageSent = "whatsapp:message-sent",
    WhatsAppMessageDelivered = "whatsapp:message-delivered",
    WhatsAppMessageRead = "whatsapp:message-read",
    WhatsAppMessageFailed = "whatsapp:message-failed",

    SMSMessageSent = "sms:message-sent",
    SMSMessageDelivered = "sms:message-delivered",
    SMSMessageFailed = "sms:message-failed",

    EmailSent = "email:sent",
    EmailDelivered = "email:delivered",
    EmailOpened = "email:opened",
    EmailClicked = "email:clicked",
    EmailBounced = "email:bounced",
    EmailFailed = "email:failed",

    // ========================================
    // üìÑ OCR & DOCUMENT PROCESSING
    // ========================================

    // Document Upload & Processing
    DocumentUploaded = "document:uploaded",
    DocumentQueued = "document:queued",
    DocumentProcessingStarted = "document:processing-started",
    DocumentProcessed = "document:processed",
    DocumentProcessingFailed = "document:processing-failed",
    DocumentValidated = "document:validated",
    DocumentRejected = "document:rejected",
    DocumentArchived = "document:archived",
    DocumentDeleted = "document:deleted",

    // OCR Job Lifecycle
    OCRJobCreated = "ocr:job-created",
    OCRJobStarted = "ocr:job-started",
    OCRJobCompleted = "ocr:job-completed",
    OCRJobFailed = "ocr:job-failed",
    OCRJobCancelled = "ocr:job-cancelled",
    OCRJobRetried = "ocr:job-retried",

    // OCR Results
    OCRDataExtracted = "ocr:data-extracted",
    OCRDataValidated = "ocr:data-validated",
    OCRDataCorrected = "ocr:data-corrected",
    OCRHighConfidenceResult = "ocr:high-confidence",
    OCRLowConfidenceResult = "ocr:low-confidence",
    OCRManualReviewRequired = "ocr:manual-review-required",

    // Auto-Creation from OCR
    InvoiceAutoCreatedFromOCR = "invoice:auto-created-from-ocr",
    SaleReceiptAutoCreatedFromOCR = "sale-receipt:auto-created-from-ocr",
    InvoicePaymentAutoCreatedFromOCR = "invoice-payment:auto-created-from-ocr",
    ExpenseAutoCreatedFromOCR = "expense:auto-created-from-ocr",

    // ========================================
    // üì¶ INVENTORY & ITEM MANAGEMENT
    // ========================================

    // Inventory Item Lifecycle
    InventoryItemCreated = "inventory-item:created",
    InventoryItemUpdated = "inventory-item:updated",
    InventoryItemDeleted = "inventory-item:deleted",
    InventoryItemActivated = "inventory-item:activated",
    InventoryItemDeactivated = "inventory-item:deactivated",
    InventoryItemPriceUpdated = "inventory-item:price-updated",
    InventoryItemCostUpdated = "inventory-item:cost-updated",
    InventoryItemCategoryChanged = "inventory-item:category-changed",
    InventoryItemImageUpdated = "inventory-item:image-updated",

    // Stock Management
    StockAdded = "stock:added",
    StockReduced = "stock:reduced",
    StockAdjusted = "stock:adjusted",
    StockTransferred = "stock:transferred",
    StockDamaged = "stock:damaged",
    StockExpired = "stock:expired",
    StockReturned = "stock:returned",

    // Stock Alerts
    StockLow = "stock:low",
    StockCritical = "stock:critical",
    StockOut = "stock:out",
    StockReorderRequired = "stock:reorder-required",
    StockReceived = "stock:received",
    StockOrdered = "stock:ordered",

    // Inventory Operations
    InventoryCountStarted = "inventory:count-started",
    InventoryCountCompleted = "inventory:count-completed",
    InventoryVarianceDetected = "inventory:variance-detected",
    InventoryAdjustmentMade = "inventory:adjustment-made",

    // ========================================
    // üë• E-COMMERCE USER MANAGEMENT
    // ========================================

    // E-commerce User Lifecycle
    EcommerceUserCreated = "ecommerce-user:created",
    EcommerceUserUpdated = "ecommerce-user:updated",
    EcommerceUserDeleted = "ecommerce-user:deleted",
    EcommerceUserActivated = "ecommerce-user:activated",
    EcommerceUserDeactivated = "ecommerce-user:deactivated",
    EcommerceUserBlocked = "ecommerce-user:blocked",
    EcommerceUserUnblocked = "ecommerce-user:unblocked",

    // E-commerce Authentication
    EcommerceUserLoggedIn = "ecommerce-user:logged-in",
    EcommerceUserLoggedOut = "ecommerce-user:logged-out",
    EcommerceUserLoginFailed = "ecommerce-user:login-failed",
    EcommerceUserPasswordChanged = "ecommerce-user:password-changed",
    EcommerceUserPasswordResetRequested = "ecommerce-user:password-reset-requested",
    EcommerceUserPasswordResetCompleted = "ecommerce-user:password-reset-completed",

    // E-commerce User Verification
    EcommerceUserEmailVerified = "ecommerce-user:email-verified",
    EcommerceUserPhoneVerified = "ecommerce-user:phone-verified",
    EcommerceUserEmailVerificationSent = "ecommerce-user:email-verification-sent",
    EcommerceUserPhoneVerificationSent = "ecommerce-user:phone-verification-sent",

    // E-commerce User Profile
    EcommerceUserProfileUpdated = "ecommerce-user:profile-updated",
    EcommerceUserAddressAdded = "ecommerce-user:address-added",
    EcommerceUserAddressUpdated = "ecommerce-user:address-updated",
    EcommerceUserAddressDeleted = "ecommerce-user:address-deleted",
    EcommerceUserPreferencesUpdated = "ecommerce-user:preferences-updated",

    // Social Login
    EcommerceUserSocialLoginLinked = "ecommerce-user:social-login-linked",
    EcommerceUserSocialLoginUnlinked = "ecommerce-user:social-login-unlinked",

    // E-commerce User Session
    EcommerceUserSessionCreated = "ecommerce-user:session-created",
    EcommerceUserSessionExpired = "ecommerce-user:session-expired",
    EcommerceUserSessionTerminated = "ecommerce-user:session-terminated",

    // ========================================
    // üõç E-COMMERCE & ORDERS
    // ========================================

    // Order Management
    OrderCreated = "order:created",
    OrderUpdated = "order:updated",
    OrderConfirmed = "order:confirmed",
    OrderPacked = "order:packed",
    OrderShipped = "order:shipped",
    OrderDelivered = "order:delivered",
    OrderCancelled = "order:cancelled",
    OrderReturned = "order:returned",
    OrderRefunded = "order:refunded",
    OrderCompleted = "order:completed",

    // Shopping Cart
    CartCreated = "cart:created",
    CartUpdated = "cart:updated",
    CartItemAdded = "cart:item-added",
    CartItemRemoved = "cart:item-removed",
    CartAbandoned = "cart:abandoned",
    CartRecovered = "cart:recovered",
    CartConverted = "cart:converted",

    // Online Payments
    OnlinePaymentInitiated = "online-payment:initiated",
    OnlinePaymentSucceeded = "online-payment:succeeded",
    OnlinePaymentFailed = "online-payment:failed",
    OnlinePaymentRefunded = "online-payment:refunded",

    // ========================================
    // üìä REPORTS & ANALYTICS
    // ========================================

    // Report Generation
    ReportGenerated = "report:generated",
    ReportScheduled = "report:scheduled",
    ReportEmailed = "report:emailed",
    ReportDownloaded = "report:downloaded",
    ReportFailed = "report:failed",

    // Daily Reports
    DailySalesReportGenerated = "report:daily-sales-generated",
    DailyCashReportGenerated = "report:daily-cash-generated",
    DailyInventoryReportGenerated = "report:daily-inventory-generated",
    DailyOutstandingReportGenerated = "report:daily-outstanding-generated",

    // Weekly/Monthly Reports
    WeeklySalesReportGenerated = "report:weekly-sales-generated",
    MonthlySalesReportGenerated = "report:monthly-sales-generated",
    MonthlyProfitLossGenerated = "report:monthly-pl-generated",
    MonthlyGSTReportGenerated = "report:monthly-gst-generated",

    // Analytics & KPIs
    KPICalculated = "analytics:kpi-calculated",
    SalesTrendAnalyzed = "analytics:sales-trend-analyzed",
    CustomerAnalyticsGenerated = "analytics:customer-analytics-generated",
    InventoryTurnoverCalculated = "analytics:inventory-turnover-calculated",
    ProfitMarginCalculated = "analytics:profit-margin-calculated",

    // Dashboard Updates
    DashboardDataUpdated = "dashboard:data-updated",
    DashboardViewed = "dashboard:viewed",
    DashboardExported = "dashboard:exported",

    // ========================================
    // ‚öôÔ∏è SYSTEM & ADMINISTRATION
    // ========================================

    // System Events
    SystemStarted = "system:started",
    SystemShutdown = "system:shutdown",
    SystemHealthCheckPerformed = "system:health-check",
    SystemMaintenanceStarted = "system:maintenance-started",
    SystemMaintenanceCompleted = "system:maintenance-completed",
    SystemUpdated = "system:updated",
    SystemMetricsCollected = "system:metrics-collected",
    SystemAlertTriggered = "system:alert-triggered",
    APIEndpointAccessed = "system:api-endpoint-accessed",
    WebhookReceived = "system:webhook-received",
    SystemConfigUpdated = "system:config-updated",

    // Data Management
    DataBackupStarted = "data:backup-started",
    DataBackupCompleted = "data:backup-completed",
    DataBackupFailed = "data:backup-failed",
    DataRestoreStarted = "data:restore-started",
    DataRestoreCompleted = "data:restore-completed",
    DataExported = "data:exported",
    DataImported = "data:imported",

    // Configuration
    SettingsUpdated = "settings:updated",
    ConfigurationChanged = "config:changed",
    BusinessProfileUpdated = "business:profile-updated",
    TaxSettingsUpdated = "tax:settings-updated",
    NotificationPreferencesUpdated = "notification:preferences-updated",

    // Audit & Compliance
    AuditLogCreated = "audit:log-created",
    ComplianceCheckPerformed = "compliance:check-performed",
    DataIntegrityCheckPerformed = "data:integrity-check",
    SecurityScanPerformed = "security:scan-performed",

    // ========================================
    // üè™ TEXTILE SHOP SPECIFIC EVENTS
    // ========================================

    // Customer Events
    CustomerVisitLogged = "customer:visit-logged",
    CustomerPreferenceUpdated = "customer:preference-updated",
    CustomerLoyaltyPointsEarned = "customer:loyalty-points-earned",
    CustomerLoyaltyPointsRedeemed = "customer:loyalty-points-redeemed",

    // Textile/Inventory Specific
    TextileDisplayed = "textile:displayed",
    TextileDemonstrated = "textile:demonstrated",
    TextileReserved = "textile:reserved",
    TextileCustomized = "textile:customized",

    // Seasonal Events
    FestivalDiscountApplied = "festival:discount-applied",
    SeasonalInventoryUpdated = "seasonal:inventory-updated",
    WeddingSeasonAlertSent = "wedding-season:alert-sent",

    // Business Operations
    ShopOpeningLogged = "shop:opening-logged",
    ShopClosingLogged = "shop:closing-logged",
    CashCountPerformed = "cash:count-performed",
    CashShortageDetected = "cash:shortage-detected",
    CashExcessDetected = "cash:excess-detected",
}

// Export type for better TypeScript support
export type SubjectType = keyof typeof Subjects;

// Helper to get all subjects as array
export const getAllSubjects = (): string[] => {
    return Object.values(Subjects);
};

// Group subjects by category for better organization
export const SubjectCategories = {
    AUTHENTICATION: [
        Subjects.UserCreated,
        Subjects.UserLoggedIn,
        Subjects.UserLoggedOut,
        Subjects.SessionCreated,
    ],

    CORE_BUSINESS: [
        Subjects.InvoiceCreated,
        Subjects.SaleCreated,
        Subjects.InvoicePaymentCreated,
        Subjects.SaleReceiptCreated,
        Subjects.CustomerCreated,
        Subjects.PartyCreated,
    ],

    NOTIFICATIONS: [
        Subjects.InvoiceOverdue,
        Subjects.PaymentReminderSent,
        Subjects.WhatsAppMessageSent,
        Subjects.EmailSent,
    ],

    DOCUMENT_PROCESSING: [
        Subjects.DocumentUploaded,
        Subjects.OCRJobCompleted,
        Subjects.InvoiceAutoCreatedFromOCR,
        Subjects.SaleReceiptAutoCreatedFromOCR,
    ],

    INVENTORY: [
        Subjects.InventoryItemCreated,
        Subjects.StockLow,
        Subjects.StockOut,
        Subjects.InventoryCountCompleted,
    ],

    REPORTS: [
        Subjects.DailySalesReportGenerated,
        Subjects.MonthlySalesReportGenerated,
        Subjects.KPICalculated,
    ],

    SYSTEM: [
        Subjects.SystemStarted,
        Subjects.DataBackupCompleted,
        Subjects.AuditLogCreated,
    ],
} as const;

// Priority mapping for event processing
export const EventPriorities = {
    CRITICAL: [
        Subjects.SystemShutdown,
        Subjects.DataBackupFailed,
        Subjects.SuspiciousActivityDetected,
        Subjects.CashShortageDetected,
        Subjects.InvoicePaymentFailed,
    ],

    HIGH: [
        Subjects.InvoiceOverdue,
        Subjects.CustomerCreditLimitExceeded,
        Subjects.StockOut,
        Subjects.WhatsAppMessageFailed,
    ],

    MEDIUM: [
        Subjects.InvoiceCreated,
        Subjects.SaleCreated,
        Subjects.InvoicePaymentCreated,
        Subjects.CustomerCreated,
    ],

    LOW: [
        Subjects.DashboardViewed,
        Subjects.ReportGenerated,
        Subjects.EmailOpened,
        Subjects.UserLoggedIn,
    ],
} as const;


```

``` typescript
// Method 1: Domain-Based Topics (Recommended)
export const TopicNames = {
    // NOTIFICATION DOMAIN
    NOTIFICATION_EMAIL_REQUESTS: "notification.email.requests",
    NOTIFICATION_EMAIL_RESPONSES: "notification.email.responses",
    NOTIFICATION_SMS_REQUESTS: "notification.sms.requests",
    NOTIFICATION_SMS_RESPONSES: "notification.sms.responses",
    NOTIFICATION_WHATSAPP_REQUESTS: "notification.whatsapp.requests",
    NOTIFICATION_WHATSAPP_RESPONSES: "notification.whatsapp.responses",

    // AUTH DOMAIN
    AUTH_USER_EVENTS: "auth.user.events",
    AUTH_SESSION_EVENTS: "auth.session.events",
    AUTH_SECURITY_EVENTS: "auth.security.events",

    // ACCOUNTS DOMAIN
    ACCOUNTS_INVOICE_EVENTS: "accounts.invoice.events",
    ACCOUNTS_PAYMENT_EVENTS: "accounts.payment.events",
    ACCOUNTS_SALE_EVENTS: "accounts.sale.events",
    ACCOUNTS_LEDGER_EVENTS: "accounts.ledger.events",

    // OCR DOMAIN
    OCR_PROCESSING_EVENTS: "ocr.processing.events",
    OCR_DOCUMENT_EVENTS: "ocr.document.events",

    // INVENTORY DOMAIN
    INVENTORY_ITEM_EVENTS: "inventory.item.events",
    INVENTORY_STOCK_EVENTS: "inventory.stock.events",

    // ANALYTICS DOMAIN
    ANALYTICS_EVENTS: "analytics.events",
    AUDIT_EVENTS: "audit.events",
};

// packages/common-backend/src/events/interfaces/invoiceInterfaces.ts

import { BaseEvent } from "./base-interfaces";
import { Subjects } from "@repo/common/subjects";

// ========================================
// INVOICE LIFECYCLE EVENTS
// ========================================

export interface InvoiceCreatedEvent extends BaseEvent {
    subject: Subjects.InvoiceCreated;
    data: {
        id: string;
        voucherId: string;
        invoiceNo: string;
        date: string;
        dueDate?: string;
        amount: number;
        paidAmount: number;
        remainingAmount?: number;
        status: "PENDING" | "PARTIALLY_PAID" | "PAID" | "OVERDUE" | "CANCELLED";
        description?: string;
        taxAmount?: number;
        discountAmount?: number;
        roundOffAmount?: number;
        notes?: string;
        partyId: string;
        partyName: string;
        partyGSTNo?: string;
        poNumber?: string;
        transportMode?: string;
        vehicleNo?: string;
        deliveryNote?: string;
        supplierRef?: string;
        otherRef?: string;
        buyersOrderNo?: string;
        dispatchedThrough?: string;
        destination?: string;
        createdBy: string;
        createdAt: string;
        userId: string;
    };
}

export interface InvoiceUpdatedEvent extends BaseEvent {
    subject: Subjects.InvoiceUpdated;
    data: {
        id: string;
        updatedAt: string;
        changes: Record<
            string,
            {
                oldValue: any;
                newValue: any;
            }
        >;
        updatedBy: string;
        partyId: string;
        statusChanged?: boolean;
        paymentUpdated?: boolean;
        dueDateChanged?: boolean;
        amountChanged?: boolean;
    };
}

export interface InvoiceDeletedEvent extends BaseEvent {
    subject: Subjects.InvoiceDeleted;
    data: {
        id: string;
        invoiceNo: string;
        partyId: string;
        partyName: string;
        amount: number;
        deletedAt: string;
        deletedBy: string;
        reason?: string;
        hadPayments?: boolean;
        refundRequired?: boolean;
        complianceImpact?: boolean;
    };
}

export interface InvoiceCancelledEvent extends BaseEvent {
    subject: Subjects.InvoiceCancelled;
    data: {
        id: string;
        invoiceNo: string;
        partyId: string;
        partyName: string;
        amount: number;
        cancelledAt: string;
        cancelledBy: string;
        reason:
            | "PARTY_REQUEST"
            | "GOODS_NOT_DELIVERED"
            | "BILLING_ERROR"
            | "BUSINESS_DECISION"
            | "DISPUTE"
            | "OTHER";
        refundAmount?: number;
        creditNoteRequired?: boolean;
        partyNotified?: boolean;
        complianceNotificationRequired?: boolean;
    };
}

export interface InvoiceVoidedEvent extends BaseEvent {
    subject: Subjects.InvoiceVoided;
    data: {
        id: string;
        invoiceNo: string;
        partyId: string;
        partyName: string;
        amount: number;
        voidedAt: string;
        voidedBy: string;
        reason:
            | "DUPLICATE"
            | "ERROR"
            | "FRAUDULENT"
            | "COMPLIANCE_ISSUE"
            | "OTHER";
        replacementInvoiceId?: string;
        auditTrailMaintained: boolean;
        complianceReported?: boolean;
    };
}

export interface InvoiceDraftCreatedEvent extends BaseEvent {
    subject: Subjects.InvoiceDraftCreated;
    data: {
        id: string;
        draftNo: string;
        partyId: string;
        partyName: string;
        estimatedAmount: number;
        createdBy: string;
        createdAt: string;
        validUntil?: string;
        notes?: string;
        autoConversionScheduled?: boolean;
    };
}

// ========================================
// INVOICE COMMUNICATION EVENTS
// ========================================

export interface InvoiceSentEvent extends BaseEvent {
    subject: Subjects.InvoiceSent;
    data: {
        id: string;
        invoiceNo: string;
        partyId: string;
        partyName: string;
        sentTo: {
            email?: string;
            phone?: string;
            contactPerson?: string;
        };
        sentVia: "EMAIL" | "WHATSAPP" | "POST" | "HAND_DELIVERY" | "COURIER";
        sentBy: string;
        sentAt: string;
        documentFormat: "PDF" | "PRINTED" | "BOTH";
        deliveryConfirmation?: boolean;
        trackingId?: string;
        estimatedDelivery?: string;
    };
}

export interface InvoiceViewedEvent extends BaseEvent {
    subject: Subjects.InvoiceViewed;
    data: {
        id: string;
        invoiceNo: string;
        partyId: string;
        partyName: string;
        viewedAt: string;
        viewedBy?: string;
        viewMethod:
            | "EMAIL_LINK"
            | "WHATSAPP_LINK"
            | "PORTAL_ACCESS"
            | "PRINTED_COPY";
        ipAddress?: string;
        deviceInfo?: string;
        viewDuration?: number; // seconds
        actionsAfterView?: "DOWNLOADED" | "PRINTED" | "FORWARDED" | "NONE";
    };
}

export interface InvoicePrintedEvent extends BaseEvent {
    subject: Subjects.InvoicePrinted;
    data: {
        id: string;
        invoiceNo: string;
        partyId: string;
        partyName: string;
        printedAt: string;
        printedBy: string;
        copies: number;
        printerName?: string;
        printType: "ORIGINAL" | "DUPLICATE" | "COPY" | "DRAFT";
        paperSize?: string;
        printQuality?: "DRAFT" | "NORMAL" | "HIGH";
    };
}

export interface InvoiceEmailedEvent extends BaseEvent {
    subject: Subjects.InvoiceEmailed;
    data: {
        id: string;
        invoiceNo: string;
        partyId: string;
        partyName: string;
        recipientEmail: string;
        emailSubject: string;
        sentAt: string;
        sentBy: string;
        deliveryStatus: "SENT" | "DELIVERED" | "OPENED" | "FAILED" | "BOUNCED";
        failureReason?: string;
        attachments: {
            fileName: string;
            fileSize: number;
            fileType: string;
        }[];
        trackingEnabled: boolean;
        reminderScheduled?: boolean;
    };
}

export interface InvoiceWhatsAppSentEvent extends BaseEvent {
    subject: Subjects.InvoiceWhatsAppSent;
    data: {
        id: string;
        invoiceNo: string;
        partyId: string;
        partyName: string;
        recipientPhone: string;
        messageId?: string;
        sentAt: string;
        sentBy: string;
        messageType: "TEXT" | "DOCUMENT" | "IMAGE" | "LINK";
        deliveryStatus: "SENT" | "DELIVERED" | "READ" | "FAILED";
        failureReason?: string;
        templateUsed?: string;
        mediaSize?: number;
    };
}

// ========================================
// INVOICE PAYMENT STATUS EVENTS
// ========================================

export interface InvoicePaidEvent extends BaseEvent {
    subject: Subjects.InvoicePaid;
    data: {
        invoiceId: string;
        invoiceNo: string;
        partyId: string;
        partyName: string;
        amount: number;
        paymentId: string;
        paymentMethod: string;
        paymentDate: string;
        paymentReference?: string;
        fullPayment: boolean;
        daysToPayment: number;
        onTimePayment: boolean;
        paidAt: string;
        receiptGenerated?: boolean;
        receiptNo?: string;
    };
}

export interface InvoicePartiallyPaidEvent extends BaseEvent {
    subject: Subjects.InvoicePartiallyPaid;
    data: {
        invoiceId: string;
        invoiceNo: string;
        partyId: string;
        partyName: string;
        totalAmount: number;
        paidAmount: number;
        remainingAmount: number;
        paymentPercentage: number;
        paymentId: string;
        paymentMethod: string;
        paymentDate: string;
        nextPaymentExpected?: string;
        installmentPlan?: {
            totalInstallments: number;
            completedInstallments: number;
            nextInstallmentAmount: number;
            nextInstallmentDate: string;
        };
    };
}

export interface InvoiceOverdueEvent extends BaseEvent {
    subject: Subjects.InvoiceOverdue;
    data: {
        id: string;
        invoiceNo: string;
        amount: number;
        remainingAmount: number;
        dueDate: string;
        daysPastDue: number;
        overdueCategory:
            | "1-7_DAYS"
            | "8-15_DAYS"
            | "16-30_DAYS"
            | "31-60_DAYS"
            | "60+_DAYS";
        partyId: string;
        partyName: string;
        partyPhone?: string;
        partyEmail?: string;
        remindersSent: number;
        lastReminderDate?: string;
        escalationLevel:
            | "FRIENDLY_REMINDER"
            | "FORMAL_NOTICE"
            | "FINAL_NOTICE"
            | "LEGAL_ACTION";
        interestApplicable?: boolean;
        penaltyAmount?: number;
        collectionAgencyInvolved?: boolean;
        legalActionThreatened?: boolean;
    };
}

export interface InvoiceDueSoonEvent extends BaseEvent {
    subject: Subjects.InvoiceDueSoon;
    data: {
        id: string;
        invoiceNo: string;
        amount: number;
        remainingAmount: number;
        dueDate: string;
        daysUntilDue: number;
        partyId: string;
        partyName: string;
        partyPhone?: string;
        partyEmail?: string;
        reminderType: "7_DAY" | "3_DAY" | "1_DAY" | "SAME_DAY";
        autoReminderSent: boolean;
        paymentMethodsAvailable: string[];
        earlyPaymentDiscountAvailable?: boolean;
        discountPercentage?: number;
    };
}

export interface InvoiceDueTodayEvent extends BaseEvent {
    subject: Subjects.InvoiceDueToday;
    data: {
        id: string;
        invoiceNo: string;
        amount: number;
        remainingAmount: number;
        dueDate: string;
        partyId: string;
        partyName: string;
        partyPhone?: string;
        partyEmail?: string;
        reminderSent: boolean;
        urgentFollowUpRequired: boolean;
        accountManagerNotified: boolean;
        penaltyStartsTomorrow?: boolean;
        penaltyRate?: number;
    };
}

export interface InvoicePaymentReceivedEvent extends BaseEvent {
    subject: Subjects.InvoicePaymentReceived;
    data: {
        invoiceId: string;
        invoiceNo: string;
        partyId: string;
        partyName: string;
        paymentAmount: number;
        paymentMethod: string;
        paymentReference?: string;
        receivedAt: string;
        allocationMethod: "AUTO" | "MANUAL";
        appliedAmount: number;
        unappliedAmount?: number;
        overpayment?: number;
        bankCharges?: number;
        netAmountReceived: number;
        reconciliationStatus: "MATCHED" | "PARTIAL_MATCH" | "UNMATCHED";
    };
}

// ========================================
// INVOICE ACTION EVENTS
// ========================================

export interface InvoiceReminderSentEvent extends BaseEvent {
    subject: Subjects.InvoiceReminderSent;
    data: {
        invoiceId: string;
        invoiceNo: string;
        partyId: string;
        partyName: string;
        reminderType:
            | "PAYMENT_DUE"
            | "OVERDUE_NOTICE"
            | "FINAL_NOTICE"
            | "COURTESY_REMINDER";
        reminderNumber: number;
        totalReminders: number;
        channel: "EMAIL" | "WHATSAPP" | "SMS" | "PHONE" | "POST";
        recipientContact: string;
        sentBy: string;
        sentAt: string;
        deliveryStatus: "SENT" | "DELIVERED" | "READ" | "FAILED";
        responseReceived?: boolean;
        responseType?:
            | "PAYMENT_PROMISE"
            | "DISPUTE"
            | "REQUEST_EXTENSION"
            | "ACKNOWLEDGMENT";
        nextReminderScheduled?: string;
        escalationTriggered?: boolean;
    };
}

export interface InvoiceFollowUpRequiredEvent extends BaseEvent {
    subject: Subjects.InvoiceFollowUpRequired;
    data: {
        invoiceId: string;
        invoiceNo: string;
        partyId: string;
        partyName: string;
        amount: number;
        remainingAmount: number;
        daysPastDue: number;
        followUpReason:
            | "NO_RESPONSE_TO_REMINDERS"
            | "PAYMENT_PROMISE_BROKEN"
            | "DISPUTE_RAISED"
            | "PARTIAL_PAYMENT_ISSUES";
        previousActions: string[];
        suggestedActions: string[];
        priority: "LOW" | "MEDIUM" | "HIGH" | "URGENT";
        assignedTo?: string;
        escalationLevel: number;
        customerRelationshipRisk: "LOW" | "MEDIUM" | "HIGH";
        businessImpact: "MINIMAL" | "MODERATE" | "SIGNIFICANT" | "CRITICAL";
    };
}

// export interface InvoiceDisputeRaisedEvent extends BaseEvent {
//     subject: Subjects.InvoiceDisputeRaised;
//     data: {
//         invoiceId: string;
//         invoiceNo: string;
//         partyId: string;
//         partyName: string;
//         disputeId: string;
//         disputeType:
//             | "BILLING_ERROR"
//             | "GOODS_NOT_RECEIVED"
//             | "QUALITY_ISSUE"
//             | "PRICING_DISPUTE"
//             | "DELIVERY_ISSUE"
//             | "OTHER";
//         disputeAmount: number;
//         totalInvoiceAmount: number;
//         description: string;
//         supportingDocuments?: string[];
//         raisedBy: string;
//         raisedAt: string;
//         urgency: "LOW" | "MEDIUM" | "HIGH" | "CRITICAL";
//         paymentOnHold: boolean;
//         resolutionSLA: string;
//         assignedInvestigator?: string;
//         initialResponse?: string;
//     };
// }

// ========================================
// INVOICE COMPLIANCE & REGULATORY EVENTS
// ========================================

export interface InvoiceGSTValidatedEvent extends BaseEvent {
    subject: Subjects.InvoiceGSTValidated;
    data: {
        invoiceId: string;
        invoiceNo: string;
        partyId: string;
        partyGSTNo: string;
        validationStatus: "VALID" | "INVALID" | "SUSPENDED" | "CANCELLED";
        validatedAt: string;
        validationSource:
            | "GOVERNMENT_PORTAL"
            | "THIRD_PARTY_API"
            | "MANUAL_VERIFICATION";
        gstDetails?: {
            businessName: string;
            registrationDate: string;
            status: string;
            taxpayerType: string;
        };
        complianceFlag?: boolean;
        actionRequired?: string[];
        riskLevel?: "LOW" | "MEDIUM" | "HIGH";
    };
}

// export interface InvoiceEWayBillGeneratedEvent extends BaseEvent {
//     subject: Subjects.InvoiceEWayBillGenerated;
//     data: {
//         invoiceId: string;
//         invoiceNo: string;
//         eWayBillNo: string;
//         partyId: string;
//         partyName: string;
//         vehicleNo?: string;
//         transporterId?: string;
//         transporterName?: string;
//         distance?: number;
//         validUpto: string;
//         generatedAt: string;
//         generatedBy: string;
//         consignmentValue: number;
//         goodsDescription: string;
//         fromPlace: string;
//         toPlace: string;
//         documentStatus: "ACTIVE" | "CANCELLED" | "EXPIRED";
//     };
// }

// export interface InvoiceEInvoiceGeneratedEvent extends BaseEvent {
//     subject: Subjects.InvoiceEInvoiceGenerated;
//     data: {
//         invoiceId: string;
//         invoiceNo: string;
//         eInvoiceReferenceNo: string;
//         irn: string; // Invoice Reference Number
//         ackNo: string;
//         ackDate: string;
//         partyId: string;
//         partyName: string;
//         partyGSTNo: string;
//         qrCode: string;
//         signedInvoice: string;
//         generatedAt: string;
//         generatedBy: string;
//         validityPeriod: string;
//         complianceStatus: "COMPLIANT" | "NON_COMPLIANT";
//         governmentPortalStatus: "SUCCESS" | "PENDING" | "FAILED";
//     };
// }

// ========================================
// INVOICE ANALYTICS & REPORTING EVENTS
// ========================================

export interface InvoiceAnalyticsGeneratedEvent extends BaseEvent {
    subject: Subjects.InvoiceAnalyticsGenerated;
    data: {
        analysisId: string;
        period: {
            startDate: string;
            endDate: string;
        };
        metrics: {
            totalInvoices: number;
            totalAmount: number;
            averageInvoiceValue: number;
            paymentRate: number; // percentage
            averagePaymentTime: number; // days
            overdueRate: number; // percentage
            disputeRate: number; // percentage
        };
        trends: {
            topParties: Array<{
                partyId: string;
                partyName: string;
                invoiceCount: number;
                totalAmount: number;
                paymentReliability: number;
            }>;
            paymentPatterns: {
                onTime: number;
                early: number;
                late: number;
                veryLate: number;
            };
            monthlyTrends: Array<{
                month: string;
                invoiceCount: number;
                amount: number;
                collectionEfficiency: number;
            }>;
        };
        insights: string[];
        recommendations: string[];
        generatedAt: string;
        generatedBy: string;
    };
}

// ========================================
// EXPORT ALL INVOICE EVENT TYPES
// ========================================

export type InvoiceEventTypes =
    | InvoiceCreatedEvent
    | InvoiceUpdatedEvent
    | InvoiceDeletedEvent
    | InvoiceCancelledEvent
    | InvoiceVoidedEvent
    | InvoiceDraftCreatedEvent
    | InvoiceSentEvent
    | InvoiceViewedEvent
    | InvoicePrintedEvent
    | InvoiceEmailedEvent
    | InvoiceWhatsAppSentEvent
    | InvoicePaidEvent
    | InvoicePartiallyPaidEvent
    | InvoiceOverdueEvent
    | InvoiceDueSoonEvent
    | InvoiceDueTodayEvent
    | InvoicePaymentReceivedEvent
    | InvoiceReminderSentEvent
    | InvoiceFollowUpRequiredEvent
    | InvoiceGSTValidatedEvent
    | InvoiceAnalyticsGeneratedEvent;
// | InvoiceDisputeRaisedEvent
// | InvoiceEWayBillGeneratedEvent
// | InvoiceEInvoiceGeneratedEvent

// packages/common-backend/src/events/interfaces/partyInterfaces.ts

import { BaseEvent } from "./base-interfaces";
import { Subjects } from "@repo/common/subjects";

// ========================================
// PARTY LIFECYCLE EVENTS
// ========================================

export interface PartyCreatedEvent extends BaseEvent {
    subject: Subjects.PartyCreated;
    data: {
        id: string;
        name: string;
        gstNo?: string;
        panNo?: string;
        phone?: string;
        email?: string;
        address?: string;
        city?: string;
        state?: string;
        pincode?: string;
        contactPerson?: string;
        bankDetails?: {
            bankName?: string;
            accountNo?: string;
            ifsc?: string;
            branch?: string;
        };
        category?: string;
        paymentTerms?: number;
        creditLimit: number;
        taxId?: string;
        website?: string;
        notes?: string;
        createdBy: string;
        createdAt: string;
    };
}

export interface PartyUpdatedEvent extends BaseEvent {
    subject: Subjects.PartyUpdated;
    data: {
        id: string;
        updatedAt: string;
        changes: Record<
            string,
            {
                oldValue: any;
                newValue: any;
            }
        >;
        updatedBy: string;
        gstChanged?: boolean;
        contactChanged?: boolean;
        bankDetailsChanged?: boolean;
        creditLimitChanged?: boolean;
        categoryChanged?: boolean;
    };
}

export interface PartyDeletedEvent extends BaseEvent {
    subject: Subjects.PartyDeleted;
    data: {
        id: string;
        name: string;
        gstNo?: string;
        category?: string;
        deletedAt: string;
        deletedBy: string;
        hasOutstandingInvoices?: boolean;
        finalBalance?: number;
        reason?: string;
    };
}

export interface PartyActivatedEvent extends BaseEvent {
    subject: Subjects.PartyActivated;
    data: {
        id: string;
        name: string;
        activatedBy: string;
        activatedAt: string;
        reason?: string;
        previousStatus?: string;
    };
}

export interface PartyDeactivatedEvent extends BaseEvent {
    subject: Subjects.PartyDeactivated;
    data: {
        id: string;
        name: string;
        deactivatedBy: string;
        deactivatedAt: string;
        reason?: string;
        hasOutstandingInvoices?: boolean;
        outstandingAmount?: number;
    };
}

// ========================================
// PARTY CONTACT & INFORMATION EVENTS
// ========================================

export interface PartyContactUpdatedEvent extends BaseEvent {
    subject: Subjects.PartyContactUpdated;
    data: {
        id: string;
        name: string;
        contactChanges: {
            phone?: {
                oldValue?: string;
                newValue?: string;
            };
            email?: {
                oldValue?: string;
                newValue?: string;
            };
            address?: {
                oldValue?: string;
                newValue?: string;
            };
            contactPerson?: {
                oldValue?: string;
                newValue?: string;
            };
        };
        updatedBy: string;
        updatedAt: string;
        notificationsSent?: string[];
    };
}

export interface PartyGSTUpdatedEvent extends BaseEvent {
    subject: Subjects.PartyGSTUpdated;
    data: {
        partyId: string;
        partyName: string;
        oldGSTNo?: string;
        newGSTNo?: string;
        gstStatus?: "ACTIVE" | "CANCELLED" | "SUSPENDED";
        updatedBy: string;
        updatedAt: string;
        verificationStatus?: "PENDING" | "VERIFIED" | "FAILED";
        complianceImpact?: boolean;
    };
}

export interface PartyBankDetailsUpdatedEvent extends BaseEvent {
    subject: Subjects.PartyBankDetailsUpdated;
    data: {
        partyId: string;
        partyName: string;
        bankDetailsChanges: {
            bankName?: {
                oldValue?: string;
                newValue?: string;
            };
            accountNo?: {
                oldValue?: string;
                newValue?: string;
            };
            ifsc?: {
                oldValue?: string;
                newValue?: string;
            };
            branch?: {
                oldValue?: string;
                newValue?: string;
            };
        };
        updatedBy: string;
        updatedAt: string;
        verificationRequired?: boolean;
        paymentMethodsAffected?: string[];
    };
}

export interface PartyPaymentTermsUpdatedEvent extends BaseEvent {
    subject: Subjects.PartyPaymentTermsUpdated;
    data: {
        partyId: string;
        partyName: string;
        oldPaymentTerms?: number;
        newPaymentTerms?: number;
        reason?: string;
        updatedBy: string;
        updatedAt: string;
        affectsExistingInvoices?: boolean;
        pendingInvoicesCount?: number;
    };
}

// ========================================
// PARTY BUSINESS RELATIONSHIP EVENTS
// ========================================

// export interface PartyPerformanceEvaluatedEvent extends BaseEvent {
//     subject: Subjects.PartyPerformanceEvaluated;
//     data: {
//         partyId: string;
//         partyName: string;
//         evaluationPeriod: {
//             startDate: string;
//             endDate: string;
//         };
//         metrics: {
//             totalInvoices: number;
//             totalAmount: number;
//             averageInvoiceValue: number;
//             paymentTimeliness: number; // percentage
//             qualityRating?: number; // 1-5 scale
//             deliveryPerformance?: number; // percentage
//             responseTime?: number; // hours
//         };
//         rating: "EXCELLENT" | "GOOD" | "AVERAGE" | "POOR" | "CRITICAL";
//         recommendations?: string[];
//         evaluatedBy: string;
//         evaluatedAt: string;
//         nextEvaluationDate?: string;
//     };
// }

// export interface PartyContractRenewedEvent extends BaseEvent {
//     subject: Subjects.PartyContractRenewed;
//     data: {
//         partyId: string;
//         partyName: string;
//         contractId: string;
//         contractType: "SUPPLY" | "SERVICE" | "EXCLUSIVE" | "GENERAL";
//         oldContractExpiry?: string;
//         newContractExpiry: string;
//         termsChanged?: boolean;
//         rateChanges?: {
//             item: string;
//             oldRate: number;
//             newRate: number;
//         }[];
//         renewedBy: string;
//         renewedAt: string;
//         autoRenewal?: boolean;
//     };
// }

// export interface PartyRiskAssessmentUpdatedEvent extends BaseEvent {
//     subject: Subjects.PartyRiskAssessmentUpdated;
//     data: {
//         partyId: string;
//         partyName: string;
//         oldRiskLevel?: "LOW" | "MEDIUM" | "HIGH" | "CRITICAL";
//         newRiskLevel: "LOW" | "MEDIUM" | "HIGH" | "CRITICAL";
//         riskFactors: {
//             paymentHistory: "EXCELLENT" | "GOOD" | "AVERAGE" | "POOR";
//             financialStability: "STABLE" | "MODERATE" | "UNSTABLE";
//             marketReputation: "EXCELLENT" | "GOOD" | "AVERAGE" | "POOR";
//             businessContinuity: "SECURE" | "STABLE" | "UNCERTAIN" | "RISKY";
//         };
//         actions: string[];
//         assessedBy: string;
//         assessedAt: string;
//         nextAssessmentDate?: string;
//         creditLimitRecommendation?: number;
//     };
// }

// ========================================
// PARTY TRANSACTION RELATED EVENTS
// ========================================

// export interface PartyFirstTransactionEvent extends BaseEvent {
//     subject: Subjects.PartyFirstTransaction;
//     data: {
//         partyId: string;
//         partyName: string;
//         transactionType: "INVOICE" | "PAYMENT";
//         transactionId: string;
//         transactionNumber: string;
//         amount: number;
//         transactionDate: string;
//         onboardingCompleted: boolean;
//         relationshipManager?: string;
//         welcomePackageSent?: boolean;
//     };
// }

// export interface PartyLargeTransactionEvent extends BaseEvent {
//     subject: Subjects.PartyLargeTransaction;
//     data: {
//         partyId: string;
//         partyName: string;
//         transactionType: "INVOICE" | "PAYMENT";
//         transactionId: string;
//         transactionNumber: string;
//         amount: number;
//         threshold: number;
//         percentageAboveAverage: number;
//         transactionDate: string;
//         requiresApproval?: boolean;
//         approvedBy?: string;
//         flaggedForReview?: boolean;
//     };
// }

// export interface PartyPaymentDelayedEvent extends BaseEvent {
//     subject: Subjects.PartyPaymentDelayed;
//     data: {
//         partyId: string;
//         partyName: string;
//         invoiceId: string;
//         invoiceNumber: string;
//         invoiceAmount: number;
//         dueDate: string;
//         daysPastDue: number;
//         totalOutstanding: number;
//         paymentTerms: number;
//         remindersSent: number;
//         lastReminderDate?: string;
//         escalationLevel:
//             | "FIRST_NOTICE"
//             | "SECOND_NOTICE"
//             | "FINAL_NOTICE"
//             | "LEGAL_ACTION";
//         contactAttempts?: {
//             method: "EMAIL" | "PHONE" | "WHATSAPP" | "LETTER";
//             date: string;
//             success: boolean;
//         }[];
//     };
// }

// export interface PartyComplianceIssueEvent extends BaseEvent {
//     subject: Subjects.PartyComplianceIssue;
//     data: {
//         partyId: string;
//         partyName: string;
//         issueType:
//             | "GST_MISMATCH"
//             | "INVALID_PAN"
//             | "MISSING_DOCUMENTS"
//             | "REGULATORY_VIOLATION"
//             | "TAX_DEFAULT";
//         severity: "LOW" | "MEDIUM" | "HIGH" | "CRITICAL";
//         description: string;
//         affectedTransactions?: {
//             transactionId: string;
//             transactionNumber: string;
//             amount: number;
//         }[];
//         detectAt: string;
//         actionRequired: string[];
//         deadline?: string;
//         regulatoryBody?: string;
//         penaltyRisk?: boolean;
//         estimatedPenalty?: number;
//     };
// }

// ========================================
// PARTY COMMUNICATION EVENTS
// ========================================

export interface PartyStatementSentEvent extends BaseEvent {
    subject: Subjects.PartyStatementSent;
    data: {
        partyId: string;
        partyName: string;
        statementPeriod: {
            startDate: string;
            endDate: string;
        };
        statementType: "MONTHLY" | "QUARTERLY" | "ANNUAL" | "ON_DEMAND";
        totalTransactions: number;
        totalInvoiced: number;
        totalPaid: number;
        outstandingBalance: number;
        sentVia: "EMAIL" | "WHATSAPP" | "POST" | "HAND_DELIVERY";
        sentTo: string;
        sentBy: string;
        sentAt: string;
        deliveryConfirmed?: boolean;
        readConfirmed?: boolean;
    };
}

// export interface PartyNewsletterSentEvent extends BaseEvent {
//     subject: Subjects.PartyNewsletterSent;
//     data: {
//         partyId: string;
//         partyName: string;
//         newsletterType:
//             | "PRODUCT_UPDATES"
//             | "PRICE_CHANGES"
//             | "POLICY_UPDATES"
//             | "SEASONAL_OFFERS"
//             | "COMPANY_NEWS";
//         subject: string;
//         sentVia: "EMAIL" | "WHATSAPP" | "POST";
//         sentTo: string;
//         sentAt: string;
//         deliveryStatus: "SENT" | "DELIVERED" | "READ" | "FAILED";
//         engagementMetrics?: {
//             opened?: boolean;
//             clicked?: boolean;
//             replied?: boolean;
//         };
//     };
// }

// ========================================
// PARTY CATEGORY & CLASSIFICATION EVENTS
// ========================================

// export interface PartyCategoryChangedEvent extends BaseEvent {
//     subject: Subjects.PartyCategoryChanged;
//     data: {
//         partyId: string;
//         partyName: string;
//         oldCategory?: string;
//         newCategory: string;
//         reason: string;
//         changedBy: string;
//         changedAt: string;
//         impactOnTerms: {
//             paymentTermsChanged?: boolean;
//             creditLimitChanged?: boolean;
//             discountRatesChanged?: boolean;
//             priorityChanged?: boolean;
//         };
//         autoClassification?: boolean;
//         classificationCriteria?: {
//             annualVolume?: number;
//             transactionFrequency?: number;
//             paymentReliability?: number;
//         };
//     };
// }

// export interface PartyTierUpgradedEvent extends BaseEvent {
//     subject: Subjects.PartyTierUpgraded;
//     data: {
//         partyId: string;
//         partyName: string;
//         oldTier?: "BRONZE" | "SILVER" | "GOLD" | "PLATINUM";
//         newTier: "BRONZE" | "SILVER" | "GOLD" | "PLATINUM";
//         upgradeCriteria: {
//             annualVolume?: number;
//             relationshipPeriod?: number;
//             paymentRecord?: number;
//             exclusiveDeals?: number;
//         };
//         benefits: string[];
//         upgradedAt: string;
//         notificationSent?: boolean;
//         celebrationRequired?: boolean;
//     };
// }

// ========================================
// PARTY SEASONAL & BUSINESS EVENTS
// ========================================

// export interface PartySeasonalOrderEvent extends BaseEvent {
//     subject: Subjects.PartySeasonalOrder;
//     data: {
//         partyId: string;
//         partyName: string;
//         season: "SUMMER" | "WINTER" | "MONSOON" | "FESTIVAL" | "WEDDING";
//         orderType:
//             | "ADVANCE_BOOKING"
//             | "SEASONAL_STOCK"
//             | "FESTIVAL_SPECIAL"
//             | "BULK_ORDER";
//         orderValue: number;
//         expectedDeliveryPeriod: {
//             startDate: string;
//             endDate: string;
//         };
//         specialTerms?: {
//             advancePayment?: number;
//             seasonalDiscount?: number;
//             earlyBirdBonus?: number;
//         };
//         products: {
//             category: string;
//             quantity: number;
//             estimatedValue: number;
//         }[];
//         orderDate: string;
//         expectedCompletion: string;
//     };
// }

// export interface PartyExclusiveDealEvent extends BaseEvent {
//     subject: Subjects.PartyExclusiveDeal;
//     data: {
//         partyId: string;
//         partyName: string;
//         dealType:
//             | "EXCLUSIVE_PRODUCT"
//             | "TERRITORY_EXCLUSIVE"
//             | "VOLUME_COMMITMENT"
//             | "SEASONAL_EXCLUSIVE";
//         dealValue: number;
//         exclusivityPeriod: {
//             startDate: string;
//             endDate: string;
//         };
//         terms: {
//             minimumVolume?: number;
//             exclusiveTerritory?: string[];
//             exclusiveProducts?: string[];
//             specialPricing?: boolean;
//             marketingSupport?: boolean;
//         };
//         dealManager: string;
//         approvedBy: string;
//         signedAt: string;
//         complianceRequirements?: string[];
//     };
// }

// ========================================
// EXPORT ALL PARTY EVENT TYPES
// ========================================

export type PartyEventTypes =
    | PartyCreatedEvent
    | PartyUpdatedEvent
    | PartyDeletedEvent
    | PartyActivatedEvent
    | PartyDeactivatedEvent
    | PartyContactUpdatedEvent
    | PartyGSTUpdatedEvent
    | PartyBankDetailsUpdatedEvent
    | PartyPaymentTermsUpdatedEvent
    // | PartyPerformanceEvaluatedEvent
    // | PartyContractRenewedEvent
    // | PartyRiskAssessmentUpdatedEvent
    // | PartyFirstTransactionEvent
    // | PartyLargeTransactionEvent
    // | PartyPaymentDelayedEvent
    // | PartyComplianceIssueEvent
    | PartyStatementSentEvent;
// | PartyNewsletterSentEvent
// | PartyCategoryChangedEvent
// | PartyTierUpgradedEvent
// | PartySeasonalOrderEvent
// | PartyExclusiveDealEvent;

// packages/common-backend/src/events/interfaces/invoicePaymentInterfaces.ts

import { BaseEvent } from "./base-interfaces";
import { Subjects } from "@repo/common/subjects";

// ========================================
// INVOICE PAYMENT LIFECYCLE EVENTS
// ========================================

export interface InvoicePaymentCreatedEvent extends BaseEvent {
    subject: Subjects.InvoicePaymentCreated;
    data: {
        id: string;
        voucherId: string;
        amount: number;
        date: string;
        method:
            | "CASH"
            | "BANK_TRANSFER"
            | "CHEQUE"
            | "UPI"
            | "CARD"
            | "ONLINE"
            | "OTHER";
        status: "PENDING" | "COMPLETED" | "FAILED" | "CANCELLED" | "REFUNDED";
        reference?: string;
        description?: string;

        // Relations
        partyId: string;
        partyName: string;
        invoiceId?: string;
        invoiceNumber?: string;

        // Payment allocation details
        appliedToInvoices?: Array<{
            invoiceId: string;
            invoiceNumber: string;
            amountApplied: number;
            remainingAmount: number;
        }>;

        // Advanced payment handling
        unappliedAmount?: number;
        prepayment?: boolean;

        // Method-specific details stored as discriminated union
        methodDetails:
            | {
                  method: "CASH";
                  denomination?: {
                      notes: Record<string, number>;
                      coins: Record<string, number>;
                  };
                  totalCounted: number;
                  variance?: number;
                  cashierName?: string;
                  registerNumber?: string;
                  securityLevel: "NORMAL" | "HIGH_VALUE" | "SUSPICIOUS";
              }
            | {
                  method: "UPI";
                  upiTransactionId: string;
                  upiReference: string;
                  payerVPA: string;
                  payeeVPA: string;
                  upiApp?: string;
                  bankReferenceNo?: string;
                  instantSettlement: boolean;
              }
            | {
                  method: "BANK_TRANSFER";
                  bankReference: string;
                  transferMode: "NEFT" | "RTGS" | "IMPS" | "WIRE_TRANSFER";
                  payerBankName: string;
                  payeeBankName: string;
                  ifscCode: string;
                  transferDate: string;
                  valueDate: string;
                  charges?: number;
                  narration?: string;
              }
            | {
                  method: "CHEQUE";
                  chequeNo: string;
                  chequeDate: string;
                  bankName: string;
                  branchName?: string;
                  ifscCode?: string;
                  clearanceStatus:
                      | "ISSUED"
                      | "HANDED_OVER"
                      | "DEPOSITED"
                      | "IN_CLEARING"
                      | "CLEARED"
                      | "BOUNCED";
                  postDated: boolean;
                  micr?: string;
              }
            | {
                  method: "CARD";
                  cardType: "CREDIT" | "DEBIT" | "PREPAID";
                  cardScheme:
                      | "VISA"
                      | "MASTERCARD"
                      | "RUPAY"
                      | "AMEX"
                      | "OTHER";
                  maskedCardNo: string;
                  authCode?: string;
                  rrn?: string;
                  emvChip: boolean;
                  contactless: boolean;
                  mdr?: number;
              }
            | {
                  method: "ONLINE";
                  gatewayName: string;
                  gatewayOrderId?: string;
                  gatewayPaymentId?: string;
                  transactionId?: string;
                  processingFees?: number;
              }
            | {
                  method: "OTHER";
                  description: string;
                  additionalDetails?: Record<string, any>;
              };

        createdBy: string;
        createdAt: string;
    };
}

export interface InvoicePaymentUpdatedEvent extends BaseEvent {
    subject: Subjects.InvoicePaymentUpdated;
    data: {
        id: string;
        voucherId: string;
        updatedAt: string;
        changes: Record<
            string,
            {
                oldValue: any;
                newValue: any;
            }
        >;
        updatedBy: string;

        // Specific change flags for event handling
        statusChanged?: boolean;
        amountChanged?: boolean;
        methodChanged?: boolean;
        allocationChanged?: boolean; // Invoice allocation changed
        bankDetailsChanged?: boolean;

        // Additional context
        reason?: string; // Reason for update
        autoUpdated?: boolean; // System vs manual update
    };
}

export interface InvoicePaymentDeletedEvent extends BaseEvent {
    subject: Subjects.InvoicePaymentDeleted;
    data: {
        id: string;
        voucherId: string;
        amount: number;
        method: string;
        date: string;
        partyId: string;
        partyName: string;
        invoiceId?: string;
        invoiceNumber?: string;

        deletedAt: string;
        deletedBy: string;
        reason?: string;

        // Impact assessment
        ledgerAdjustmentRequired: boolean;
        invoiceStatusReverted?: boolean; // If invoice status needs to revert
        outstandingAmountIncreased?: number;

        // Backup data for potential restore
        backupData: any;
    };
}

export interface InvoicePaymentVoidedEvent extends BaseEvent {
    subject: Subjects.InvoicePaymentVoided;
    data: {
        id: string;
        voucherId: string;
        amount: number;
        originalStatus: string;
        voidedAt: string;
        voidedBy: string;
        reason:
            | "DUPLICATE"
            | "ERROR"
            | "FRAUDULENT"
            | "DISPUTE"
            | "BANK_REVERSAL"
            | "CANCELLED_ORDER"
            | "SUPPLIER_REQUEST"
            | "OTHER";

        // Reversal details
        reversalPaymentId?: string;
        bankCharges?: number;
        netReversalAmount?: number;

        // Impact on related entities
        invoiceStatusReverted?: boolean;
        partyLedgerAdjusted?: boolean;

        // Compliance and audit
        auditTrailMaintained: boolean;
        approvalRequired?: boolean;
        approvedBy?: string;
    };
}

// ========================================
// INVOICE PAYMENT PROCESSING EVENTS
// ========================================

export interface InvoicePaymentProcessedEvent extends BaseEvent {
    subject: Subjects.InvoicePaymentProcessed;
    data: {
        id: string;
        voucherId: string;
        amount: number;
        method: string;
        processingStatus: "INITIATED" | "IN_PROGRESS" | "COMPLETED" | "FAILED";

        // Gateway processing details
        gatewayOrderId?: string;
        gatewayPaymentId?: string;
        gatewayTransactionId?: string;
        gatewayStatus?: string;
        processingTime?: number; // milliseconds
        gatewayCharges?: number;
        netAmount: number;

        processedAt: string;

        // Gateway response details
        gatewayResponse?: {
            code: string;
            message: string;
            additionalInfo?: any;
        };

        // Next action required
        nextAction?:
            | "NONE"
            | "MANUAL_VERIFICATION"
            | "RETRY"
            | "CONTACT_GATEWAY"
            | "UPDATE_INVOICE_STATUS";

        // Relations
        partyId: string;
        invoiceId?: string;
    };
}

export interface InvoicePaymentFailedEvent extends BaseEvent {
    subject: Subjects.InvoicePaymentFailed;
    data: {
        paymentId: string;
        voucherId: string;
        amount: number;
        method: string;
        reason:
            | "INSUFFICIENT_FUNDS"
            | "INVALID_ACCOUNT"
            | "NETWORK_ERROR"
            | "GATEWAY_ERROR"
            | "BANK_REJECTION"
            | "FRAUD_DETECTED"
            | "LIMIT_EXCEEDED"
            | "CHEQUE_BOUNCED"
            | "SIGNATURE_MISMATCH"
            | "OTHER";

        failureCode?: string;
        failureMessage: string;

        // Entity details
        partyId: string;
        partyName: string;
        invoiceId?: string;
        invoiceNumber?: string;

        // Gateway details for online payments
        gatewayOrderId?: string;
        gatewayResponse?: any;

        // Retry mechanism
        attemptNumber: number;
        maxRetries: number;
        canRetry: boolean;

        suggestedAction:
            | "RETRY"
            | "CHANGE_METHOD"
            | "CONTACT_BANK"
            | "MANUAL_PAYMENT"
            | "CONTACT_SUPPLIER";

        failedAt: string;

        // Communication
        supplierNotified: boolean;
        internalTeamNotified: boolean;
        alternativeMethodsAvailable?: string[];
    };
}

export interface InvoicePaymentPendingEvent extends BaseEvent {
    subject: Subjects.InvoicePaymentPending;
    data: {
        id: string;
        voucherId: string;
        amount: number;
        method: string;
        pendingReason:
            | "BANK_PROCESSING"
            | "GATEWAY_DELAY"
            | "MANUAL_VERIFICATION"
            | "COMPLIANCE_CHECK"
            | "CHEQUE_CLEARANCE"
            | "SUPPLIER_CONFIRMATION";

        estimatedCompletionTime?: string;
        maxWaitTime?: string;

        // Entity relations
        partyId: string;
        partyName: string;
        invoiceId?: string;
        invoiceNumber?: string;

        pendingSince: string;
        monitoringRequired: boolean;
        escalationLevel: "NONE" | "LOW" | "MEDIUM" | "HIGH";
        statusCheckInterval?: number; // minutes

        // Communication status
        supplierNotified: boolean;
        lastStatusUpdate?: string;
    };
}

export interface InvoicePaymentConfirmedEvent extends BaseEvent {
    subject: Subjects.InvoicePaymentConfirmed;
    data: {
        id: string;
        voucherId: string;
        amount: number;
        method: string;
        confirmationSource:
            | "GATEWAY"
            | "BANK_STATEMENT"
            | "MANUAL_VERIFICATION"
            | "SUPPLIER_ACKNOWLEDGMENT"
            | "CHEQUE_CLEARANCE";

        confirmationReference: string;
        confirmedAt: string;
        confirmedBy?: string;

        // Final amounts after charges
        finalAmount: number;
        bankCharges?: number;
        processingFees?: number;

        // Timing details
        timeTakenToConfirm: number; // hours
        autoConfirmed: boolean;
        confidenceLevel: "HIGH" | "MEDIUM" | "LOW";

        // Relations
        partyId: string;
        invoiceId?: string;

        // Post-confirmation actions
        invoiceStatusUpdated: boolean;
        ledgerEntryCreated: boolean;
        supplierNotified: boolean;

        additionalVerificationRequired?: boolean;
    };
}

export interface InvoicePaymentReconciledEvent extends BaseEvent {
    subject: Subjects.InvoicePaymentReconciled;
    data: {
        id: string;
        voucherId: string;
        amount: number;

        // Bank statement matching
        bankStatementEntry: {
            date: string;
            amount: number;
            reference: string;
            description: string;
            transactionId?: string;
        };

        matchType:
            | "EXACT_MATCH"
            | "AMOUNT_MATCH"
            | "REFERENCE_MATCH"
            | "MANUAL_MATCH"
            | "PARTIAL_MATCH";

        matchConfidence: number; // percentage 0-100
        variance?: number;
        varianceReason?: string;

        reconciledAt: string;
        reconciledBy: string;
        autoReconciled: boolean;

        // Reconciliation rules applied
        reconciliationRules?: string[];
        exceptions?: string[];

        // Relations
        partyId: string;
        invoiceId?: string;

        // Post-reconciliation status
        discrepancyResolved: boolean;
        adjustmentRequired?: boolean;
        adjustmentAmount?: number;
    };
}

export interface InvoicePaymentRefundedEvent extends BaseEvent {
    subject: Subjects.InvoicePaymentRefunded;
    data: {
        originalPaymentId: string;
        refundId: string;
        originalVoucherId: string;
        refundVoucherId: string;

        originalAmount: number;
        refundAmount: number;

        refundReason:
            | "OVERPAYMENT"
            | "CANCELLED_INVOICE"
            | "SUPPLIER_CREDIT"
            | "DUPLICATE_PAYMENT"
            | "BUSINESS_ERROR"
            | "QUALITY_ISSUE"
            | "RETURN_OF_GOODS"
            | "SETTLEMENT_ADJUSTMENT"
            | "OTHER";

        refundMethod:
            | "ORIGINAL_SOURCE"
            | "BANK_TRANSFER"
            | "CASH"
            | "ADJUSTMENT_NOTE"
            | "CREDIT_NOTE"
            | "OTHER";

        refundReference?: string;
        processingFee?: number;
        netRefundAmount: number;

        // Parties involved
        partyId: string;
        partyName: string;
        invoiceId?: string;
        invoiceNumber?: string;

        // Approval workflow
        initiatedBy: string;
        approvedBy?: string;
        approvalRequired: boolean;

        processedAt: string;
        estimatedSettlement?: string;
        refundStatus: "INITIATED" | "PROCESSING" | "COMPLETED" | "FAILED";

        // Impact on related entities
        invoiceStatusUpdated?: boolean;
        ledgerAdjustmentMade?: boolean;
        partyBalanceUpdated?: boolean;
    };
}

// ========================================
// PAYMENT METHOD SPECIFIC STATUS EVENTS
// ========================================
// These events track status changes specific to payment methods
// that occur after the initial payment creation

export interface ChequeStatusUpdatedEvent extends BaseEvent {
    subject: Subjects.ChequeStatusUpdated;
    data: {
        paymentId: string;
        voucherId: string;
        chequeNo: string;
        oldStatus: string;
        newStatus:
            | "ISSUED"
            | "HANDED_OVER"
            | "DEPOSITED"
            | "IN_CLEARING"
            | "CLEARED"
            | "BOUNCED"
            | "CANCELLED";
        statusDate: string;

        // Bounce specific details
        bounceReason?: string;
        bounceCharges?: number;

        // Clearance details
        clearanceDate?: string;
        bankReference?: string;

        partyId: string;
        partyName: string;
        invoiceId?: string;

        updatedBy: string;
        updatedAt: string;
    };
}

export interface BankTransferStatusUpdatedEvent extends BaseEvent {
    subject: Subjects.BankTransferStatusUpdated;
    data: {
        paymentId: string;
        voucherId: string;
        bankReference: string;
        oldStatus: string;
        newStatus:
            | "INITIATED"
            | "IN_TRANSIT"
            | "SETTLED"
            | "FAILED"
            | "RETURNED";
        statusDate: string;

        // Settlement details
        actualSettlementDate?: string;
        settlementReference?: string;

        // Failure details
        failureReason?: string;
        returnReason?: string;

        partyId: string;
        partyName: string;

        updatedAt: string;
    };
}

// ========================================
// INVOICE PAYMENT ALLOCATION EVENTS
// ========================================

export interface InvoicePaymentAllocatedEvent extends BaseEvent {
    subject: Subjects.InvoicePaymentAllocated;
    data: {
        paymentId: string;
        voucherId: string;
        totalAmount: number;

        // Allocation details
        allocations: Array<{
            invoiceId: string;
            invoiceNumber: string;
            invoiceDueDate: string;
            invoiceAmount: number;
            previousPaidAmount: number;
            allocationAmount: number;
            newPaidAmount: number;
            remainingAmount: number;
            fullyPaid: boolean;
        }>;

        totalAllocated: number;
        unappliedAmount: number;

        // Party information
        partyId: string;
        partyName: string;

        allocatedBy: string;
        allocatedAt: string;

        // Auto allocation details
        autoAllocated: boolean;
        allocationRules?: string[]; // FIFO, specific invoice, etc.

        // Impact summary
        invoicesFullyPaid: number;
        invoicesPartiallyPaid: number;
        overdueReduced: number;

        notes?: string;
    };
}

// ========================================
// INVOICE PAYMENT ANALYTICS EVENTS
// ========================================

export interface InvoicePaymentTrendAnalyzedEvent extends BaseEvent {
    subject: Subjects.InvoicePaymentTrendAnalyzed;
    data: {
        analysisId: string;
        period: {
            startDate: string;
            endDate: string;
        };

        // Overall metrics
        metrics: {
            totalPaymentsMade: number;
            totalAmountPaid: number;
            averagePaymentAmount: number;
            averagePaymentTime: number; // days from invoice to payment

            // Payment method breakdown
            paymentMethodDistribution: {
                cash: number;
                upi: number;
                bankTransfer: number;
                cheque: number;
                card: number;
                other: number;
            };

            // Timeliness metrics
            earlyPaymentRate: number; // percentage
            onTimePaymentRate: number;
            latePaymentRate: number;
            averageDaysEarly: number;
            averageDaysLate: number;

            // Efficiency metrics
            paymentFailureRate: number;
            averageProcessingTime: number; // hours
            reconciliationRate: number;
        };

        // Trends analysis
        trends: {
            dailyVolume: Array<{
                date: string;
                count: number;
                amount: number;
            }>;

            methodPreferences: Array<{
                method: string;
                percentage: number;
                growth: number; // month-over-month growth
            }>;

            supplierPaymentPatterns: Array<{
                partyId: string;
                partyName: string;
                averagePaymentTime: number;
                preferredMethod: string;
                totalPaid: number;
                paymentFrequency: number;
            }>;
        };

        // Insights and recommendations
        insights: string[];
        recommendations: string[];
        cashFlowOptimization: string[];

        analyzedAt: string;
        analyzedBy: string;

        // Context
        businessMetrics: {
            totalPurchases: number;
            averageCreditPeriod: number;
            cashFlowImpact: number;
            workingCapitalDays: number;
        };
    };
}

// ========================================
// EXPORT ALL INVOICE PAYMENT EVENT TYPES
// ========================================

export type InvoicePaymentEventTypes =
    | InvoicePaymentCreatedEvent
    | InvoicePaymentUpdatedEvent
    | InvoicePaymentDeletedEvent
    | InvoicePaymentVoidedEvent
    | InvoicePaymentProcessedEvent
    | InvoicePaymentFailedEvent
    | InvoicePaymentPendingEvent
    | InvoicePaymentConfirmedEvent
    | InvoicePaymentReconciledEvent
    | InvoicePaymentRefundedEvent
    | ChequeStatusUpdatedEvent
    | BankTransferStatusUpdatedEvent
    | InvoicePaymentAllocatedEvent
    | InvoicePaymentTrendAnalyzedEvent;

// apps/accounts/src/services/ledger.service.ts
import { prisma } from "@repo/db/prisma";
import {
    getStartOfDay,
    getEndOfDay,
    getStartOfMonth,
    getEndOfMonth,
} from "@repo/common-backend/utils";
import { logger, LogCategory } from "@repo/common-backend/logger";

export interface LedgerBalance {
    balance: number;
    totalSales?: number;
    totalPayments?: number;
    totalInvoices?: number;
    lastEntryDate?: Date;
}

export interface LedgerQuery {
    dateRange?: { gte?: Date; lte?: Date };
    limit?: number;
    offset?: number;
}

export interface LedgerStatement {
    entries: any[];
    openingBalance: number;
    closingBalance: number;
    totalDebit: number;
    totalCredit: number;
    entryCount: number;
}

export class LedgerService {
    /**
     * Create opening balance entry for customer or party
     */
    static async createOpeningBalance(data: {
        customerId?: string;
        partyId?: string;
        amount: number;
        creditLimit?: number;
        userId: string;
        description: string;
        date?: Date;
    }): Promise<void> {
        const entryDate = data.date || new Date();

        await prisma.ledgerEntry.create({
            data: {
                date: entryDate,
                description: data.description,
                debit: data.amount > 0 ? data.amount : 0,
                credit: data.amount < 0 ? Math.abs(data.amount) : 0,
                balance: data.amount,
                type: "OPENING_BALANCE",
                reference: "OPENING",
                customerId: data.customerId,
                partyId: data.partyId,
                userId: data.userId,
            },
        });

        logger.info("Opening balance created", LogCategory.LEDGER, {
            customerId: data.customerId,
            partyId: data.partyId,
            amount: data.amount,
            userId: data.userId,
        });
    }

    /**
     * Create ledger entry for sale
     */
    static async createSaleEntry(data: {
        saleId: string;
        customerId: string;
        amount: number;
        description: string;
        userId: string;
        date?: Date;
    }): Promise<void> {
        const entryDate = data.date || new Date();
        const currentBalance = await this.getCustomerBalance(data.customerId);

        // Sale increases customer's debt (debit to customer)
        const newBalance = currentBalance.balance + data.amount;

        await prisma.ledgerEntry.create({
            data: {
                date: entryDate,
                description: data.description,
                debit: data.amount,
                credit: 0,
                balance: newBalance,
                type: "SALE",
                reference: data.saleId,
                customerId: data.customerId,
                saleId: data.saleId,
                userId: data.userId,
            },
        });

        logger.info("Sale ledger entry created", LogCategory.LEDGER, {
            saleId: data.saleId,
            customerId: data.customerId,
            amount: data.amount,
            newBalance,
            userId: data.userId,
        });
    }

    /**
     * Create ledger entry for invoice
     */
    static async createInvoiceEntry(data: {
        invoiceId: string;
        partyId: string;
        amount: number;
        description: string;
        userId: string;
        date?: Date;
    }): Promise<void> {
        const entryDate = data.date || new Date();
        const currentBalance = await this.getPartyBalance(data.partyId);

        // Invoice increases what we owe to party (credit to party)
        const newBalance = currentBalance.balance + data.amount;

        await prisma.ledgerEntry.create({
            data: {
                date: entryDate,
                description: data.description,
                debit: 0,
                credit: data.amount,
                balance: newBalance,
                type: "INVOICE",
                reference: data.invoiceId,
                partyId: data.partyId,
                invoiceId: data.invoiceId,
                userId: data.userId,
            },
        });

        logger.info("Invoice ledger entry created", LogCategory.LEDGER, {
            invoiceId: data.invoiceId,
            partyId: data.partyId,
            amount: data.amount,
            newBalance,
            userId: data.userId,
        });
    }

    /**
     * Create ledger entry for payment received from customer
     */
    static async createPaymentReceivedEntry(data: {
        paymentId: string;
        customerId: string;
        amount: number;
        description: string;
        userId: string;
        date?: Date;
    }): Promise<void> {
        const entryDate = data.date || new Date();
        const currentBalance = await this.getCustomerBalance(data.customerId);

        // Payment received reduces customer's debt (credit to customer)
        const newBalance = currentBalance.balance - data.amount;

        await prisma.ledgerEntry.create({
            data: {
                date: entryDate,
                description: data.description,
                debit: 0,
                credit: data.amount,
                balance: newBalance,
                type: "PAYMENT",
                reference: data.paymentId,
                customerId: data.customerId,
                paymentId: data.paymentId,
                userId: data.userId,
            },
        });

        logger.info(
            "Payment received ledger entry created",
            LogCategory.LEDGER,
            {
                paymentId: data.paymentId,
                customerId: data.customerId,
                amount: data.amount,
                newBalance,
                userId: data.userId,
            }
        );
    }

    /**
     * Create ledger entry for payment made to party
     */
    static async createPaymentMadeEntry(data: {
        paymentId: string;
        partyId: string;
        amount: number;
        description: string;
        userId: string;
        date?: Date;
    }): Promise<void> {
        const entryDate = data.date || new Date();
        const currentBalance = await this.getPartyBalance(data.partyId);

        // Payment made reduces what we owe to party (debit to party)
        const newBalance = currentBalance.balance - data.amount;

        await prisma.ledgerEntry.create({
            data: {
                date: entryDate,
                description: data.description,
                debit: data.amount,
                credit: 0,
                balance: newBalance,
                type: "PAYMENT",
                reference: data.paymentId,
                partyId: data.partyId,
                paymentId: data.paymentId,
                userId: data.userId,
            },
        });

        logger.info("Payment made ledger entry created", LogCategory.LEDGER, {
            paymentId: data.paymentId,
            partyId: data.partyId,
            amount: data.amount,
            newBalance,
            userId: data.userId,
        });
    }

    /**
     * Create adjustment entry
     */
    static async createAdjustmentEntry(data: {
        customerId?: string;
        partyId?: string;
        amount: number;
        description: string;
        reason: string;
        userId: string;
        date?: Date;
    }): Promise<void> {
        const entryDate = data.date || new Date();

        let currentBalance = 0;
        if (data.customerId) {
            const balance = await this.getCustomerBalance(data.customerId);
            currentBalance = balance.balance;
        } else if (data.partyId) {
            const balance = await this.getPartyBalance(data.partyId);
            currentBalance = balance.balance;
        }

        const newBalance = currentBalance + data.amount;

        await prisma.ledgerEntry.create({
            data: {
                date: entryDate,
                description: `${data.description} - ${data.reason}`,
                debit: data.amount > 0 ? data.amount : 0,
                credit: data.amount < 0 ? Math.abs(data.amount) : 0,
                balance: newBalance,
                type: "ADJUSTMENT",
                reference: `ADJ-${Date.now()}`,
                customerId: data.customerId,
                partyId: data.partyId,
                userId: data.userId,
            },
        });

        logger.info("Adjustment ledger entry created", LogCategory.LEDGER, {
            customerId: data.customerId,
            partyId: data.partyId,
            amount: data.amount,
            reason: data.reason,
            newBalance,
            userId: data.userId,
        });
    }

    /**
     * Get customer balance
     */
    static async getCustomerBalance(
        customerId: string
    ): Promise<LedgerBalance> {
        const lastEntry = await prisma.ledgerEntry.findFirst({
            where: { customerId },
            orderBy: { createdAt: "desc" },
            select: {
                balance: true,
                createdAt: true,
            },
        });

        // Get totals
        const aggregates = await prisma.ledgerEntry.aggregate({
            where: { customerId },
            _sum: {
                debit: true,
                credit: true,
            },
        });

        // Get total sales amount
        const salesTotal = await prisma.sale.aggregate({
            where: { customerId },
            _sum: {
                amount: true,
            },
        });

        // Get total payments received
        const paymentsTotal = await prisma.payment.aggregate({
            where: {
                customerId,
                type: "RECEIVED",
            },
            _sum: {
                amount: true,
            },
        });

        return {
            balance: Number(lastEntry?.balance) || 0,
            totalSales: Number(salesTotal._sum.amount) || 0,
            totalPayments: Number(paymentsTotal._sum.amount) || 0,
            lastEntryDate: lastEntry?.createdAt,
        };
    }

    /**
     * Get party balance
     */
    static async getPartyBalance(partyId: string): Promise<LedgerBalance> {
        const lastEntry = await prisma.ledgerEntry.findFirst({
            where: { partyId },
            orderBy: { createdAt: "desc" },
            select: {
                balance: true,
                createdAt: true,
            },
        });

        // Get total invoices amount
        const invoicesTotal = await prisma.invoice.aggregate({
            where: { partyId },
            _sum: {
                amount: true,
            },
        });

        // Get total payments made
        const paymentsTotal = await prisma.payment.aggregate({
            where: {
                partyId,
                type: "PAID",
            },
            _sum: {
                amount: true,
            },
        });

        return {
            balance: Number(lastEntry?.balance) || 0,
            totalInvoices: Number(invoicesTotal._sum.amount) || 0,
            totalPayments: Number(paymentsTotal._sum.amount) || 0,
            lastEntryDate: lastEntry?.createdAt,
        };
    }

    /**
     * Get customer ledger statement
     */
    static async getCustomerLedger(
        customerId: string,
        query: LedgerQuery = {}
    ): Promise<LedgerStatement> {
        const whereClause: any = { customerId };

        if (query.dateRange) {
            whereClause.date = query.dateRange;
        }

        // Get opening balance (balance before date range)
        let openingBalance = 0;
        if (query.dateRange?.gte) {
            const openingEntry = await prisma.ledgerEntry.findFirst({
                where: {
                    customerId,
                    date: { lt: query.dateRange.gte },
                },
                orderBy: { createdAt: "desc" },
                select: { balance: true },
            });
            openingBalance = Number(openingEntry?.balance) || 0;
        }

        // Get entries for the period
        const entries = await prisma.ledgerEntry.findMany({
            where: whereClause,
            orderBy: { createdAt: "asc" },
            take: query.limit || 100,
            skip: query.offset || 0,
            include: {
                sale: {
                    select: { saleNo: true, voucherId: true },
                },
                payment: {
                    select: { voucherId: true, method: true },
                },
            },
        });

        // Calculate totals
        const totals = await prisma.ledgerEntry.aggregate({
            where: whereClause,
            _sum: {
                debit: true,
                credit: true,
            },
            _count: true,
        });

        const closingBalance =
            entries.length > 0
                ? entries[entries.length - 1].balance
                : openingBalance;

        return {
            entries,
            openingBalance,
            closingBalance,
            totalDebit: totals._sum.debit || 0,
            totalCredit: totals._sum.credit || 0,
            entryCount: totals._count,
        };
    }

    /**
     * Get party ledger statement
     */
    static async getPartyLedger(
        partyId: string,
        query: LedgerQuery = {}
    ): Promise<LedgerStatement> {
        const whereClause: any = { partyId };

        if (query.dateRange) {
            whereClause.date = query.dateRange;
        }

        // Get opening balance
        let openingBalance = 0;
        if (query.dateRange?.gte) {
            const openingEntry = await prisma.ledgerEntry.findFirst({
                where: {
                    partyId,
                    date: { lt: query.dateRange.gte },
                },
                orderBy: { createdAt: "desc" },
                select: { balance: true },
            });
            openingBalance = openingEntry?.balance || 0;
        }

        // Get entries for the period
        const entries = await prisma.ledgerEntry.findMany({
            where: whereClause,
            orderBy: { createdAt: "asc" },
            take: query.limit || 100,
            skip: query.offset || 0,
            include: {
                invoice: {
                    select: { invoiceNo: true, voucherId: true },
                },
                payment: {
                    select: { voucherId: true, method: true },
                },
            },
        });

        // Calculate totals
        const totals = await prisma.ledgerEntry.aggregate({
            where: whereClause,
            _sum: {
                debit: true,
                credit: true,
            },
            _count: true,
        });

        const closingBalance =
            entries.length > 0
                ? entries[entries.length - 1].balance
                : openingBalance;

        return {
            entries,
            openingBalance,
            closingBalance,
            totalDebit: totals._sum.debit || 0,
            totalCredit: totals._sum.credit || 0,
            entryCount: totals._count,
        };
    }

    /**
     * Get trial balance
     */
    static async getTrialBalance(
        userId: string,
        date?: Date
    ): Promise<{
        customers: Array<{
            id: string;
            name: string;
            debitBalance: number;
            creditBalance: number;
        }>;
        parties: Array<{
            id: string;
            name: string;
            debitBalance: number;
            creditBalance: number;
        }>;
        totals: {
            totalDebit: number;
            totalCredit: number;
            difference: number;
        };
    }> {
        const endDate = date || new Date();

        // Get customer balances
        const customers = await prisma.customer.findMany({
            where: { userId, isActive: true },
            select: { id: true, name: true },
        });

        const customerBalances = await Promise.all(
            customers.map(async (customer) => {
                const balance = await this.getCustomerBalance(customer.id);
                return {
                    ...customer,
                    debitBalance: balance.balance > 0 ? balance.balance : 0,
                    creditBalance:
                        balance.balance < 0 ? Math.abs(balance.balance) : 0,
                };
            })
        );

        // Get party balances
        const parties = await prisma.party.findMany({
            where: { userId, isActive: true },
            select: { id: true, name: true },
        });

        const partyBalances = await Promise.all(
            parties.map(async (party) => {
                const balance = await this.getPartyBalance(party.id);
                return {
                    ...party,
                    debitBalance: 0,
                    // balance.balance < 0 ? Math.abs(balance.balance) : 0,
                    creditBalance: balance.balance > 0 ? balance.balance : 0,
                };
            })
        );

        // Calculate totals
        const totalDebit =
            customerBalances.reduce((sum, c) => sum + c.debitBalance, 0) +
            partyBalances.reduce((sum, p) => sum + p.debitBalance, 0);

        const totalCredit =
            customerBalances.reduce((sum, c) => sum + c.creditBalance, 0) +
            partyBalances.reduce((sum, p) => sum + p.creditBalance, 0);

        return {
            customers: customerBalances,
            parties: partyBalances,
            totals: {
                totalDebit,
                totalCredit,
                difference: totalDebit - totalCredit,
            },
        };
    }

    /**
     * Get aged receivables (customer outstanding by age)
     */
    static async getAgedReceivables(userId: string): Promise<{
        summary: {
            current: number;
            days30: number;
            days60: number;
            days90: number;
            above90: number;
            total: number;
        };
        details: Array<{
            customerId: string;
            customerName: string;
            current: number;
            days30: number;
            days60: number;
            days90: number;
            above90: number;
            total: number;
        }>;
    }> {
        const now = new Date();
        const days30 = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        const days60 = new Date(now.getTime() - 60 * 24 * 60 * 60 * 1000);
        const days90 = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);

        const customers = await prisma.customer.findMany({
            where: { userId, isActive: true },
            select: { id: true, name: true },
        });

        const details = await Promise.all(
            customers.map(async (customer) => {
                // Get outstanding sales by age
                const [
                    current,
                    days30Amount,
                    days60Amount,
                    days90Amount,
                    above90Amount,
                ] = await Promise.all([
                    // Current (0-30 days)
                    prisma.sale.aggregate({
                        where: {
                            customerId: customer.id,
                            status: {
                                in: ["PENDING", "PARTIALLY_PAID", "OVERDUE"],
                            },
                            date: { gte: days30 },
                        },
                        _sum: { remainingAmount: true },
                    }),
                    // 30-60 days
                    prisma.sale.aggregate({
                        where: {
                            customerId: customer.id,
                            status: {
                                in: ["PENDING", "PARTIALLY_PAID", "OVERDUE"],
                            },
                            date: { gte: days60, lt: days30 },
                        },
                        _sum: { remainingAmount: true },
                    }),
                    // 60-90 days
                    prisma.sale.aggregate({
                        where: {
                            customerId: customer.id,
                            status: {
                                in: ["PENDING", "PARTIALLY_PAID", "OVERDUE"],
                            },
                            date: { gte: days90, lt: days60 },
                        },
                        _sum: { remainingAmount: true },
                    }),
                    // Above 90 days
                    prisma.sale.aggregate({
                        where: {
                            customerId: customer.id,
                            status: {
                                in: ["PENDING", "PARTIALLY_PAID", "OVERDUE"],
                            },
                            date: { lt: days90 },
                        },
                        _sum: { remainingAmount: true },
                    }),
                ]);

                const customerAging = {
                    customerId: customer.id,
                    customerName: customer.name,
                    current: current._sum.remainingAmount || 0,
                    days30: days30Amount._sum.remainingAmount || 0,
                    days60: days60Amount._sum.remainingAmount || 0,
                    days90: days90Amount._sum.remainingAmount || 0,
                    above90: above90Amount._sum.remainingAmount || 0,
                };

                customerAging.total =
                    customerAging.current +
                    customerAging.days30 +
                    customerAging.days60 +
                    customerAging.days90 +
                    customerAging.above90;

                return customerAging;
            })
        );

        // Calculate summary
        const summary = details.reduce(
            (acc, customer) => ({
                current: acc.current + customer.current,
                days30: acc.days30 + customer.days30,
                days60: acc.days60 + customer.days60,
                days90: acc.days90 + customer.days90,
                above90: acc.above90 + customer.above90,
                total: acc.total + customer.total,
            }),
            {
                current: 0,
                days30: 0,
                days60: 0,
                days90: 0,
                above90: 0,
                total: 0,
            }
        );

        return {
            summary,
            details: details.filter((d) => d.total > 0), // Only show customers with outstanding
        };
    }

    /**
     * Get aged payables (party outstanding by age)
     */
    static async getAgedPayables(userId: string): Promise<{
        summary: {
            current: number;
            days30: number;
            days60: number;
            days90: number;
            above90: number;
            total: number;
        };
        details: Array<{
            partyId: string;
            partyName: string;
            current: number;
            days30: number;
            days60: number;
            days90: number;
            above90: number;
            total: number;
        }>;
    }> {
        const now = new Date();
        const days30 = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        const days60 = new Date(now.getTime() - 60 * 24 * 60 * 60 * 1000);
        const days90 = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);

        const parties = await prisma.party.findMany({
            where: { userId, isActive: true },
            select: { id: true, name: true },
        });

        const details = await Promise.all(
            parties.map(async (party) => {
                // Get outstanding invoices by age
                const [
                    current,
                    days30Amount,
                    days60Amount,
                    days90Amount,
                    above90Amount,
                ] = await Promise.all([
                    // Current (0-30 days)
                    prisma.invoice.aggregate({
                        where: {
                            partyId: party.id,
                            status: {
                                in: ["PENDING", "PARTIALLY_PAID", "OVERDUE"],
                            },
                            date: { gte: days30 },
                        },
                        _sum: { remainingAmount: true },
                    }),
                    // 30-60 days
                    prisma.invoice.aggregate({
                        where: {
                            partyId: party.id,
                            status: {
                                in: ["PENDING", "PARTIALLY_PAID", "OVERDUE"],
                            },
                            date: { gte: days60, lt: days30 },
                        },
                        _sum: { remainingAmount: true },
                    }),
                    // 60-90 days
                    prisma.invoice.aggregate({
                        where: {
                            partyId: party.id,
                            status: {
                                in: ["PENDING", "PARTIALLY_PAID", "OVERDUE"],
                            },
                            date: { gte: days90, lt: days60 },
                        },
                        _sum: { remainingAmount: true },
                    }),
                    // Above 90 days
                    prisma.invoice.aggregate({
                        where: {
                            partyId: party.id,
                            status: {
                                in: ["PENDING", "PARTIALLY_PAID", "OVERDUE"],
                            },
                            date: { lt: days90 },
                        },
                        _sum: { remainingAmount: true },
                    }),
                ]);

                const partyAging = {
                    partyId: party.id,
                    partyName: party.name,
                    current: current._sum.remainingAmount || 0,
                    days30: days30Amount._sum.remainingAmount || 0,
                    days60: days60Amount._sum.remainingAmount || 0,
                    days90: days90Amount._sum.remainingAmount || 0,
                    above90: above90Amount._sum.remainingAmount || 0,
                };

                partyAging.total =
                    partyAging.current +
                    partyAging.days30 +
                    partyAging.days60 +
                    partyAging.days90 +
                    partyAging.above90;

                return partyAging;
            })
        );

        // Calculate summary
        const summary = details.reduce(
            (acc, party) => ({
                current: acc.current + party.current,
                days30: acc.days30 + party.days30,
                days60: acc.days60 + party.days60,
                days90: acc.days90 + party.days90,
                above90: acc.above90 + party.above90,
                total: acc.total + party.total,
            }),
            {
                current: 0,
                days30: 0,
                days60: 0,
                days90: 0,
                above90: 0,
                total: 0,
            }
        );

        return {
            summary,
            details: details.filter((d) => d.total > 0), // Only show parties with outstanding
        };
    }

    /**
     * Log credit limit change
     */
    static async logCreditLimitChange(data: {
        customerId?: string;
        partyId?: string;
        oldLimit: number;
        newLimit: number;
        userId: string;
        reason: string;
    }): Promise<void> {
        const difference = data.newLimit - data.oldLimit;
        const description = `Credit limit changed from ‚Çπ${data.oldLimit} to ‚Çπ${data.newLimit} - ${data.reason}`;

        // This doesn't affect balance, just log the change
        await prisma.ledgerEntry.create({
            data: {
                date: new Date(),
                description,
                debit: 0,
                credit: 0,
                balance: data.customerId
                    ? (await this.getCustomerBalance(data.customerId)).balance
                    : (await this.getPartyBalance(data.partyId!)).balance,
                type: "ADJUSTMENT",
                reference: `CREDIT-LIMIT-${Date.now()}`,
                customerId: data.customerId,
                partyId: data.partyId,
                userId: data.userId,
            },
        });

        logger.info("Credit limit change logged", LogCategory.LEDGER, {
            customerId: data.customerId,
            partyId: data.partyId,
            oldLimit: data.oldLimit,
            newLimit: data.newLimit,
            difference,
            userId: data.userId,
        });
    }

    /**
     * Get cash flow statement
     */
    static async getCashFlow(
        userId: string,
        startDate: Date,
        endDate: Date
    ): Promise<{
        receipts: {
            customerPayments: number;
            otherReceipts: number;
            total: number;
        };
        payments: {
            partyPayments: number;
            otherPayments: number;
            total: number;
        };
        netCashFlow: number;
    }> {
        const dateFilter = { gte: startDate, lte: endDate };

        // Get receipts (money coming in)
        const customerPayments = await prisma.payment.aggregate({
            where: {
                userId,
                type: "RECEIVED",
                customerId: { not: null },
                date: dateFilter,
            },
            _sum: { amount: true },
        });

        const otherReceipts = await prisma.payment.aggregate({
            where: {
                userId,
                type: "RECEIVED",
                customerId: null,
                partyId: null,
                date: dateFilter,
            },
            _sum: { amount: true },
        });

        // Get payments (money going out)
        const partyPayments = await prisma.payment.aggregate({
            where: {
                userId,
                type: "PAID",
                partyId: { not: null },
                date: dateFilter,
            },
            _sum: { amount: true },
        });

        const otherPayments = await prisma.payment.aggregate({
            where: {
                userId,
                type: "PAID",
                partyId: null,
                customerId: null,
                date: dateFilter,
            },
            _sum: { amount: true },
        });

        const receipts = {
            customerPayments: customerPayments._sum.amount || 0,
            otherReceipts: otherReceipts._sum.amount || 0,
            total:
                (customerPayments._sum.amount || 0) +
                (otherReceipts._sum.amount || 0),
        };

        const payments = {
            partyPayments: partyPayments._sum.amount || 0,
            otherPayments: otherPayments._sum.amount || 0,
            total:
                (partyPayments._sum.amount || 0) +
                (otherPayments._sum.amount || 0),
        };

        return {
            receipts,
            payments,
            netCashFlow: receipts.total - payments.total,
        };
    }

    /**
     * Get profit & loss summary
     */
    static async getProfitLoss(
        userId: string,
        startDate: Date,
        endDate: Date
    ): Promise<{
        revenue: {
            sales: number;
            otherIncome: number;
            total: number;
        };
        expenses: {
            purchases: number;
            otherExpenses: number;
            total: number;
        };
        grossProfit: number;
        netProfit: number;
    }> {
        const dateFilter = { gte: startDate, lte: endDate };

        // Revenue
        const sales = await prisma.sale.aggregate({
            where: {
                userId,
                date: dateFilter,
                status: { not: "CANCELLED" },
            },
            _sum: { amount: true },
        });

        // Purchases (invoices from parties)
        const purchases = await prisma.invoice.aggregate({
            where: {
                userId,
                date: dateFilter,
                status: { not: "CANCELLED" },
            },
            _sum: { amount: true },
        });

        // This is a simplified P&L - you might want to add more categories
        const revenue = {
            sales: sales._sum.amount || 0,
            otherIncome: 0, // You can add other income sources
            total: sales._sum.amount || 0,
        };

        const expenses = {
            purchases: purchases._sum.amount || 0,
            otherExpenses: 0, // You can add other expense categories
            total: purchases._sum.amount || 0,
        };

        const grossProfit = revenue.total - expenses.purchases;
        const netProfit = grossProfit - expenses.otherExpenses;

        return {
            revenue,
            expenses,
            grossProfit,
            netProfit,
        };
    }

    /**
     * Get daily balances for customers and parties
     */
    static async getDailyBalanceSummary(
        userId: string,
        date?: Date
    ): Promise<{
        totalReceivables: number;
        totalPayables: number;
        netPosition: number;
        customerCount: number;
        partyCount: number;
        overdueReceivables: number;
        overduePayables: number;
    }> {
        const targetDate = date || new Date();

        // Get all active customers
        const customers = await prisma.customer.findMany({
            where: { userId, isActive: true },
            select: { id: true },
        });

        // Get all active parties
        const parties = await prisma.party.findMany({
            where: { userId, isActive: true },
            select: { id: true },
        });

        // Calculate total receivables
        let totalReceivables = 0;
        let overdueReceivables = 0;
        for (const customer of customers) {
            const balance = await this.getCustomerBalance(customer.id);
            if (balance.balance > 0) {
                totalReceivables += balance.balance;

                // Check for overdue sales
                const overdueSales = await prisma.sale.aggregate({
                    where: {
                        customerId: customer.id,
                        status: "OVERDUE",
                        remainingAmount: { gt: 0 },
                    },
                    _sum: { remainingAmount: true },
                });
                overdueReceivables += overdueSales._sum.remainingAmount || 0;
            }
        }

        // Calculate total payables
        let totalPayables = 0;
        let overduePayables = 0;
        for (const party of parties) {
            const balance = await this.getPartyBalance(party.id);
            if (balance.balance > 0) {
                totalPayables += balance.balance;

                // Check for overdue invoices
                const overdueInvoices = await prisma.invoice.aggregate({
                    where: {
                        partyId: party.id,
                        status: "OVERDUE",
                        remainingAmount: { gt: 0 },
                    },
                    _sum: { remainingAmount: true },
                });
                overduePayables += overdueInvoices._sum.remainingAmount || 0;
            }
        }

        return {
            totalReceivables,
            totalPayables,
            netPosition: totalReceivables - totalPayables,
            customerCount: customers.length,
            partyCount: parties.length,
            overdueReceivables,
            overduePayables,
        };
    }

    /**
     * Close period and calculate closing balances
     */
    static async closePeriod(
        userId: string,
        date: Date,
        description: string = "Period Closing"
    ): Promise<{
        customersProcessed: number;
        partiesProcessed: number;
        totalReceivables: number;
        totalPayables: number;
    }> {
        let customersProcessed = 0;
        let partiesProcessed = 0;
        let totalReceivables = 0;
        let totalPayables = 0;

        // Get all active customers and create closing balance entries
        const customers = await prisma.customer.findMany({
            where: { userId, isActive: true },
        });

        for (const customer of customers) {
            const balance = await this.getCustomerBalance(customer.id);

            if (balance.balance !== 0) {
                await prisma.ledgerEntry.create({
                    data: {
                        date,
                        description: `${description} - ${customer.name}`,
                        debit: 0,
                        credit: 0,
                        balance: balance.balance,
                        type: "CLOSING_BALANCE",
                        reference: `CLOSING-${date.toISOString().split("T")[0]}`,
                        customerId: customer.id,
                        userId,
                    },
                });

                if (balance.balance > 0) {
                    totalReceivables += balance.balance;
                }
                customersProcessed++;
            }
        }

        // Get all active parties and create closing balance entries
        const parties = await prisma.party.findMany({
            where: { userId, isActive: true },
        });

        for (const party of parties) {
            const balance = await this.getPartyBalance(party.id);

            if (balance.balance !== 0) {
                await prisma.ledgerEntry.create({
                    data: {
                        date,
                        description: `${description} - ${party.name}`,
                        debit: 0,
                        credit: 0,
                        balance: balance.balance,
                        type: "CLOSING_BALANCE",
                        reference: `CLOSING-${date.toISOString().split("T")[0]}`,
                        partyId: party.id,
                        userId,
                    },
                });

                if (balance.balance > 0) {
                    totalPayables += balance.balance;
                }
                partiesProcessed++;
            }
        }

        logger.info("Period closed", LogCategory.LEDGER, {
            userId,
            date: date.toISOString(),
            customersProcessed,
            partiesProcessed,
            totalReceivables,
            totalPayables,
        });

        return {
            customersProcessed,
            partiesProcessed,
            totalReceivables,
            totalPayables,
        };
    }

    /**
     * Validate ledger integrity
     */
    static async validateLedgerIntegrity(userId: string): Promise<{
        isValid: boolean;
        errors: string[];
        warnings: string[];
        summary: {
            totalCustomers: number;
            totalParties: number;
            totalReceivables: number;
            totalPayables: number;
            unbalancedEntries: number;
        };
    }> {
        const errors: string[] = [];
        const warnings: string[] = [];

        // Get all customers and validate their balances
        const customers = await prisma.customer.findMany({
            where: { userId, isActive: true },
        });

        let totalReceivables = 0;
        let unbalancedEntries = 0;

        for (const customer of customers) {
            const balance = await this.getCustomerBalance(customer.id);

            // Check if calculated balance matches last ledger entry
            const lastEntry = await prisma.ledgerEntry.findFirst({
                where: { customerId: customer.id },
                orderBy: { createdAt: "desc" },
            });

            if (
                lastEntry &&
                Math.abs(lastEntry.balance - balance.balance) > 0.01
            ) {
                errors.push(
                    `Customer ${customer.name} balance mismatch: Ledger shows ${lastEntry.balance}, calculated ${balance.balance}`
                );
                unbalancedEntries++;
            }

            if (balance.balance > 0) {
                totalReceivables += balance.balance;
            }

            // Check for negative balance exceeding credit limit
            if (
                balance.balance < 0 &&
                Math.abs(balance.balance) > customer.creditLimit
            ) {
                warnings.push(
                    `Customer ${customer.name} exceeded credit limit: Balance ${balance.balance}, Limit ${customer.creditLimit}`
                );
            }
        }

        // Get all parties and validate their balances
        const parties = await prisma.party.findMany({
            where: { userId, isActive: true },
        });

        let totalPayables = 0;

        for (const party of parties) {
            const balance = await this.getPartyBalance(party.id);

            // Check if calculated balance matches last ledger entry
            const lastEntry = await prisma.ledgerEntry.findFirst({
                where: { partyId: party.id },
                orderBy: { createdAt: "desc" },
            });

            if (
                lastEntry &&
                Math.abs(lastEntry.balance - balance.balance) > 0.01
            ) {
                errors.push(
                    `Party ${party.name} balance mismatch: Ledger shows ${lastEntry.balance}, calculated ${balance.balance}`
                );
                unbalancedEntries++;
            }

            if (balance.balance > 0) {
                totalPayables += balance.balance;
            }

            // Check for negative balance exceeding credit limit
            if (
                balance.balance < 0 &&
                Math.abs(balance.balance) > party.creditLimit
            ) {
                warnings.push(
                    `Party ${party.name} exceeded credit limit: Balance ${balance.balance}, Limit ${party.creditLimit}`
                );
            }
        }

        // Check for orphaned ledger entries
        const orphanedEntries = await prisma.ledgerEntry.count({
            where: {
                userId,
                AND: [{ customerId: null }, { partyId: null }],
            },
        });

        if (orphanedEntries > 0) {
            warnings.push(`Found ${orphanedEntries} orphaned ledger entries`);
        }

        return {
            isValid: errors.length === 0,
            errors,
            warnings,
            summary: {
                totalCustomers: customers.length,
                totalParties: parties.length,
                totalReceivables,
                totalPayables,
                unbalancedEntries,
            },
        };
    }
}

// sample controller file
import { prisma } from "@repo/db/prisma";
import {
    asyncHandler,
    comparePassword,
    CustomError,
    CustomResponse,
    hashPassword,
} from "@repo/common-backend/utils";
import jwt from "jsonwebtoken";
import {
    ChangePasswordSchema,
    ChangePasswordType,
    LoginSchema,
    LoginType,
    RegisterSchema,
    RegisterType,
    UpdateProfileSchema,
    UpdateProfileType,
} from "@repo/common/schemas";
import { logger, LogCategory } from "@repo/common-backend/logger";
import { generateTokens } from "../helpers/authHelpers";
import {
    UserCreatedPublisher,
    UserLoggedInPublisher,
} from "../events/publishers/authPublishers";
import { kafkaWrapper } from "@repo/common-backend/kafka";

export const register = asyncHandler(async (req, res) => {
    const validatedData: RegisterType = RegisterSchema.parse(req.body);

    logger.info("User registration attempt", LogCategory.AUTH, {
        email: validatedData.email,
        role: validatedData.role,
        ipAddress: req.ip,
    });

    // Check if user already exists
    const existingUser = await prisma.user.findUnique({
        where: { email: validatedData.email },
    });

    if (existingUser) {
        logger.warn(
            "Registration failed - email already exists",
            LogCategory.AUTH,
            {
                email: validatedData.email,
                ipAddress: req.ip,
            }
        );
        throw new CustomError(409, "User with this email already exists");
    }

    // Hash password
    const hashedPassword = await hashPassword(validatedData.password);

    // Create user
    const user = await prisma.user.create({
        data: {
            email: validatedData.email,
            name: validatedData.name,
            phone: validatedData.phone,
            password: hashedPassword,
            role: validatedData.role,
        },
        select: {
            id: true,
            email: true,
            name: true,
            phone: true,
            role: true,
            isActive: true,
            createdAt: true,
        },
    });

    logger.logAuth("User Registered", user.id, {
        email: user.email,
        name: user.name,
        role: user.role,
        ipAddress: req.ip,
    });

    // Audit log
    logger.audit(
        "CREATE",
        "User",
        user.id,
        user.id,
        null,
        {
            email: user.email,
            name: user.name,
            role: user.role,
        },
        {
            ipAddress: req.ip,
            userAgent: req.headers["user-agent"],
        }
    );

    // Publish user created event
    const userCreatedPublisher = new UserCreatedPublisher(
        kafkaWrapper.producer
    );
    await userCreatedPublisher.publish({
        id: user.id,
        email: user.email,
        name: user.name,
        phone: user.phone || undefined,
        role: user.role,
        isActive: user.isActive,
        createdAt: user.createdAt.toISOString(),
    });

    logger.info("User registration successful", LogCategory.AUTH, {
        userId: user.id,
        email: user.email,
    });

    const response = new CustomResponse(
        201,
        "User registered successfully. Please login.",
        {
            user,
        }
    );

    res.status(response.statusCode).json(response);
});

// sample rourer
import express from "express";
import {
    changePassword,
    getProfile,
    login,
    logout,
    register,
    updateProfile,
} from "../controllers/authController";
import { authenticate } from "@repo/common-backend/middleware";
import {
    validateLogin,
    validateRegister,
    validateUpdateProfile,
} from "@repo/common-backend/validators";

const router = express.Router();

router.route("/login").post(validateLogin, login);
router.route("/register").post(validateRegister, register);
router.route("/logout").post(authenticate, logout);
router.route("/getProfile").get(authenticate, getProfile);
router
    .route("/updateProfile")
    .post(authenticate, validateUpdateProfile, updateProfile);
router.route("/changePassword").post(authenticate, changePassword);

export default router;

import { KafkaPublisher } from "../../kafka/index";
import { Subjects } from "@repo/common/subjects";
import { SendEmailRequestEvent } from "../interfaces/index";
import { TopicNames } from "@repo/common/topics";

export class SendEmailRequestPublisher extends KafkaPublisher<SendEmailRequestEvent> {
    subject = Subjects.SendEmailRequested as const;
    topic = TopicNames.NOTIFICATION_EMAIL_REQUESTS;
    protected generateMessageKey(data: SendEmailRequestEvent["data"]): string {
        return `${data.recipientId}_${data.recipient.email.split("@")[1]}`;
    }
}
export class SendSMSRequestPublisher extends KafkaPublisher<SendSMSRequestEvent> {
    subject = Subjects.SendSMSRequested as const;
    topic = TopicNames.NOTIFICATION_SMS_REQUESTS;
    protected generateMessageKey(data: SendSMSRequestEvent["data"]): string {
        return `${data.recipientId}_${data.recipient.phone}`;
    }
}
export class SendWhatsAppRequestPublisher extends KafkaPublisher<SendWhatsAppRequestEvent> {
    subject = Subjects.SendWhatsAppRequested as const;
    topic = TopicNames.NOTIFICATION_WHATSAPP_REQUESTS;
    protected generateMessageKey(
        data: SendWhatsAppRequestEvent["data"]
    ): string {
        return `${data.recipientId}_${data.recipient.phone}`;
    }
}
```
````
