// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}


// ========================================
// USER MANAGEMENT
// ========================================

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String
  phone     String?
  password  String
  role      UserRole @default(OWNER)
  isActive  Boolean  @default(true)
  
  // Security fields
  twoFactorSecret     String?
  twoFactorEnabled    Boolean   @default(false)
  ipWhitelist         Json?     // Array of allowed IP addresses
  failedLoginAttempts Int       @default(0)
  lockedUntil         DateTime?
  lastLoginAt         DateTime?
  lastLoginIP         String?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  parties          Party[]
  customers        Customer[]
  invoices         Invoice[]
  invoicePayments  InvoicePayment[]
  saleReceipts     SaleReceipt[]
  sales            Sale[]
  ledgerEntries    LedgerEntry[]
  ocrData          OCRData[]
  reminders        Reminder[]
  notifications    Notification[]
  inventoryItems   InventoryItem[]
  orders           Order[]
  userSessions     UserSession[]
  backups          Backup[]
  restores         Restore[]
  backupSchedule   BackupSchedule?
  auditLogs        AuditLog[]
  stockMovements   StockMovement[]

  @@map("users")
}

model UserSession {
  id           String   @id @default(cuid())
  userId       String
  sessionToken String   @unique
  refreshToken String   @unique
  expiresAt    DateTime
  deviceInfo   Json?    // Device information
  ipAddress    String?
  userAgent    String?
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_sessions")
}

// ========================================
// ECOMMERCE USERS (Public App Users)
// ========================================

model EcommerceUser {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String
  phone     String?
  password  String?  // Nullable for social login users
  
  // Profile information
  dateOfBirth DateTime?
  gender      Gender?  // MALE, FEMALE, OTHER
  avatar      String?  // Profile picture URL
  
  
  // Authentication & Security
  emailVerified     Boolean   @default(false)
  phoneVerified     Boolean   @default(false)
  emailVerificationToken String?
  phoneVerificationToken String?
  passwordResetToken     String?
  passwordResetExpiry    DateTime?
  
  // Social login
  googleId          String?
  facebookId        String?
  
  // Account status
  isActive          Boolean   @default(true)
  isBlocked         Boolean   @default(false)
  blockedReason     String?
  blockedAt         DateTime?
  
  // Preferences
  preferences       Json      @default("{}") // {newsletter: true, sms: true, whatsapp: true, language: 'en'}
  
  // Marketing
  referralCode      String?   @unique
  referredBy        String?
  
  // Metadata
  lastLoginAt       DateTime?
  lastLoginIP       String?
  signupSource      String?   // WEBSITE, MOBILE_APP, SOCIAL, REFERRAL
  
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  orders            Order[]
  ecommerceUserSessions EcommerceUserSession[]
  reviews           Review[]
  wishlistItems     WishlistItem[]
  cartItems         CartItem[]
  address           Address[]

  @@index([email])
  @@index([phone])
  @@index([referralCode])
  @@index([isActive])
  @@map("ecommerce_users")
}

// Address Management
model Address {
  id                String    @id @default(cuid())
  ecommerceUserId            String
  user              EcommerceUser @relation(fields: [ecommerceUserId], references: [id], onDelete: Cascade)
  
  type              AddressType
  name              String
  phone             String
  address           String
  city              String
  state             String
  pincode           String
  landmark          String?
  instructions      String?
  isDefault         Boolean   @default(false)
  
  // Relations
  ordersShipping    Order[]   @relation("ShippingAddress")
  ordersBilling     Order[]   @relation("BillingAddress")
  
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt
  
  @@index([ecommerceUserId])
  @@map("addresses")
}


model EcommerceUserSession {
  id           String   @id @default(cuid())
  userId       String
  sessionToken String   @unique
  refreshToken String   @unique
  expiresAt    DateTime
  deviceInfo   Json?    // {type: 'mobile|desktop', os, browser, version}
  ipAddress    String?
  userAgent    String?
  isActive     Boolean  @default(true)
  
  ecommerceUser EcommerceUser @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@index([userId])
  @@index([sessionToken])
  @@map("ecommerce_user_sessions")
}

// ========================================
// BUSINESS ENTITIES
// ========================================

model Customer {
  id          String  @id @default(cuid())
  name        String
  phone       String?
  email       String?
  address     String?
  city        String?
  state       String?
  pincode     String?
  gstNumber   String?
  creditLimit Decimal @default(0) @db.Decimal(12, 2)
  
  // Additional fields
  dateOfBirth      DateTime?
  anniversary      DateTime?
  preferredContact String?    // email, phone, whatsapp
  tags             String[]   // VIP, Regular, New, etc.
  notes            String?
  isActive         Boolean    @default(true)
  
  userId      String
  user        User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  sales         Sale[]
  saleReceipts  SaleReceipt[]
  ledger        LedgerEntry[]
  reminders     Reminder[]
  notifications Notification[]
  orders        Order[]

  @@index([userId])
  @@index([name])
  @@index([phone])
  @@index([email])
  @@map("customers")
}

model Party {
  id            String  @id @default(cuid())
  name          String
  gstNo         String?
  panNo         String?
  phone         String?
  email         String?
  address       String?
  city          String?
  state         String?
  pincode       String?
  contactPerson String?
  bankDetails   Json?   // {bankName, accountNo, ifsc, branch}
  
  // Additional fields
  category      String?  // Manufacturer, Distributor, Wholesaler
  paymentTerms  Int?     // Payment terms in days
  creditLimit   Decimal  @default(0) @db.Decimal(12, 2)
  taxId         String?
  website       String?
  notes         String?
  isActive      Boolean  @default(true)
  
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  invoices         Invoice[]
  invoicePayments  InvoicePayment[]
  ledger           LedgerEntry[]
  notifications    Notification[]

  @@unique([gstNo, userId], name: "unique_gst_per_user")
  @@index([userId])
  @@index([name])
  @@index([gstNo])
  @@map("parties")
}

// ========================================
// INVENTORY MANAGEMENT
// ========================================

model InventoryItem {
  id          String   @id @default(cuid())
  name        String
  description String?
  sku         String?  @unique
  barcode     String?  @unique
  category    String
  subCategory String?
  brand       String?
  
  // Pricing
  sellingPrice Decimal  @db.Decimal(10, 2)
  costPrice    Decimal? @db.Decimal(10, 2)
  mrp          Decimal? @db.Decimal(10, 2)
  
  // Stock management
  currentStock    Int      @default(0)
  minimumStock    Int      @default(0)
  maximumStock    Int?
  reorderLevel    Int?
  unit            String   @default("PCS") // PCS, MTR, KG, etc.
  
  // Textile specific fields
  fabric          String?  // Cotton, Silk, Polyester, etc.
  gsm             Int?     // Grams per square meter
  width           Decimal? @db.Decimal(8, 2) // Width in inches/cm
  color           String?
  design          String?
  pattern         String?
  weaveType       String?  // Plain, Twill, Satin, etc.
  
  // Product details
  images          Json     @default("[]")
  attributes      Json     @default("{}")
  
  // Tax and compliance
  hsnCode         String?
  taxRate         Decimal? @db.Decimal(5, 2)
  
  // Storage and supplier info
  location        String?  // Storage location in shop
  supplier        String?
  leadTime        Int?     // Days
  lastPurchaseDate DateTime?
  lastPurchasePrice Decimal? @db.Decimal(10, 2)
  
  isActive        Boolean  @default(true)
  
  userId          String
  user            User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  orderItems      OrderItem[]
  stockMovements  StockMovement[]
  reviews         Review[]
  wishlistItems   WishlistItem[]
  cartItems       CartItem[]
  
  @@index([userId])
  @@index([category])
  @@index([isActive])
  @@index([sku])
  @@index([barcode])
  @@index([currentStock])
  @@map("inventory_items")
}

model StockMovement {
  id            String       @id @default(cuid())
  inventoryItemId String
  inventoryItem   InventoryItem @relation(fields: [inventoryItemId], references: [id], onDelete: Cascade)
  
  type          MovementType // IN, OUT, ADJUSTMENT, TRANSFER
  quantity      Int
  previousStock Int
  newStock      Int
  reason        String?
  reference     String?      // Sale ID, Purchase ID, etc.
  batchNumber   String?      // For textile rolls/batches
  
  // Additional details
  unitPrice     Decimal?     @db.Decimal(10, 2)
  totalValue    Decimal?     @db.Decimal(12, 2)
  notes         String?
  
  userId        String
  user          User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt     DateTime     @default(now())
  
  @@index([inventoryItemId])
  @@index([userId])
  @@index([type])
  @@index([createdAt])
  @@map("stock_movements")
}

// ========================================
// SALES TRANSACTIONS
// ========================================

model Sale {
  id              String     @id @default(cuid())
  voucherId       String     @unique
  saleNo          String
  date            DateTime
  amount          Decimal    @db.Decimal(12, 2)
  paidAmount      Decimal    @default(0) @db.Decimal(12, 2)
  remainingAmount Decimal    @db.Decimal(12, 2)
  status          SaleStatus @default(PENDING)
  
  // Sale items - storing as JSON for flexibility in textile business
  items           Json       // [{itemName, itemType, design, color, price, quantity, total, hsnCode, unit}]
  
  // Financial details
  taxAmount       Decimal?   @db.Decimal(12, 2)
  discountAmount  Decimal?   @default(0) @db.Decimal(12, 2)
  roundOffAmount  Decimal?   @default(0) @db.Decimal(12, 2)
  
  // Additional sale details
  salesPerson     String?
  deliveryDate    DateTime?
  deliveryAddress String?
  transportation  String?
  vehicleNo       String?
  reference       String?    // Customer's reference
  terms           String?    // Payment terms
  notes           String?
  
  customerId      String
  customer        Customer   @relation(fields: [customerId], references: [id], onDelete: Cascade)
  
  userId          String
  user            User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt       DateTime   @default(now())
  updatedAt       DateTime   @updatedAt

  // Relations
  saleReceipts    SaleReceipt[]
  ledger          LedgerEntry[]
  notifications   Notification[]

  @@unique([saleNo, customerId, userId], name: "unique_sale_per_customer")
  @@index([userId])
  @@index([customerId])
  @@index([status])
  @@index([date])
  @@map("sales")
}

// ========================================
// PURCHASE TRANSACTIONS
// ========================================

model Invoice {
  id              String        @id @default(cuid())
  voucherId       String        @unique
  invoiceNo       String
  date            DateTime
  dueDate         DateTime?
  amount          Decimal       @db.Decimal(12, 2)
  paidAmount      Decimal       @default(0) @db.Decimal(12, 2)
  remainingAmount Decimal       @db.Decimal(12, 2)
  status          InvoiceStatus @default(PENDING)
  
  // Invoice line items - flexible JSON structure for textile purchases
  items           Json?         // [{description, quantity, rate, amount, hsnCode, taxRate}]
  
  description     String?
  taxAmount       Decimal?      @db.Decimal(12, 2)
  discountAmount  Decimal?      @default(0) @db.Decimal(12, 2)
  roundOffAmount  Decimal?      @default(0) @db.Decimal(12, 2)
  notes           String?
  
  // Additional invoice fields
  poNumber        String?       // Purchase Order Number
  transportMode   String?
  vehicleNo       String?
  deliveryNote    String?
  supplierRef     String?
  otherRef        String?
  buyersOrderNo   String?
  dispatchedThrough String?
  destination     String?
  
  partyId         String
  party           Party         @relation(fields: [partyId], references: [id], onDelete: Cascade)
  
  userId          String
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // Relations
  invoicePayments InvoicePayment[]
  ledger          LedgerEntry[]
  ocrData         OCRData?
  notifications   Notification[]

  @@unique([invoiceNo, partyId, userId], name: "unique_invoice_per_party")
  @@index([userId])
  @@index([partyId])
  @@index([status])
  @@index([date])
  @@index([dueDate])
  @@map("invoices")
}

// ========================================
// PAYMENT TRANSACTIONS
// ========================================

model InvoicePayment {
  id          String        @id @default(cuid())
  voucherId   String        @unique
  amount      Decimal       @db.Decimal(12, 2)
  sequenceNo  String
  date        DateTime
  method      PaymentMethod
  reference   String?       // Bank ref, cheque no, UPI transaction ID
  description String?
  status      PaymentStatus @default(COMPLETED)
  
  // Gateway fields for online payments
  gatewayOrderId   String?
  gatewayPaymentId String?
  transactionId    String?
  failureReason    String?
  
  // Banking details
  bankName        String?
  chequeNo        String?
  chequeDate      DateTime?
  clearanceDate   DateTime?
  charges         Decimal? @db.Decimal(8, 2)
  
  // Relations
  partyId     String
  party       Party        @relation(fields: [partyId], references: [id], onDelete: Cascade)
  
  invoiceId   String?
  invoice     Invoice?     @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  
  userId      String
  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt

  // Relations
  ledger        LedgerEntry[]
  ocrData       OCRData?
  notifications Notification[]

  @@index([userId])
  @@index([method])
  @@index([date])
  @@index([partyId])
  @@index([invoiceId])
  @@map("invoice_payments")
}

model SaleReceipt {
  id          String   @id @default(cuid())
  voucherId   String   @unique
  receiptNo   String
  date        DateTime
  amount      Decimal  @db.Decimal(12, 2)
  method      PaymentMethod
  description String?
  reference   String?  // Transaction reference
  imageUrl    String?  // Photo of physical receipt
  
  // Banking details
  bankName        String?
  chequeNo        String?
  chequeDate      DateTime?
  clearanceDate   DateTime?
  charges         Decimal? @db.Decimal(8, 2)
  
  // Relations
  customerId  String
  customer    Customer @relation(fields: [customerId], references: [id], onDelete: Cascade)
  
  saleId      String?
  sale        Sale?    @relation(fields: [saleId], references: [id], onDelete: Cascade)
  
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  ledger        LedgerEntry[]
  ocrData       OCRData?
  notifications Notification[]

  @@unique([receiptNo, customerId, userId], name: "unique_receipt_per_customer")
  @@index([userId])
  @@index([customerId])
  @@index([date])
  @@index([method])
  @@map("sale_receipts")
}

// ========================================
// E-COMMERCE FEATURES
// ========================================

model Review {
  id        String   @id @default(cuid())
  rating    Int      // 1-5 stars
  title     String?
  comment   String?
  images    Json     @default("[]") // Array of image URLs
  
  helpfulVotes      Int       @default(0)
  
  shopResponse      String?
  shopResponseAt    DateTime?
  // Status
  isVerified Boolean @default(false) // Verified purchase review
  isApproved Boolean @default(false) // Admin approved
  
  // Relations
  inventoryItemId String
  inventoryItem   InventoryItem @relation(fields: [inventoryItemId], references: [id], onDelete: Cascade)
  
  ecommerceUserId String
  ecommerceUser   EcommerceUser @relation(fields: [ecommerceUserId], references: [id], onDelete: Cascade)
  
  orderId     String? // Link to purchase for verified reviews
  order       Order?  @relation(fields: [orderId], references: [id], onDelete: SetNull)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([inventoryItemId])
  @@index([ecommerceUserId])
  @@index([rating])
  @@index([isApproved])
  @@map("reviews")
}

model WishlistItem {
  id        String   @id @default(cuid())
  
  inventoryItemId String
  inventoryItem   InventoryItem @relation(fields: [inventoryItemId], references: [id], onDelete: Cascade)
  
  ecommerceUserId String
  ecommerceUser   EcommerceUser @relation(fields: [ecommerceUserId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime @default(now())

  @@unique([inventoryItemId, ecommerceUserId])
  @@index([ecommerceUserId])
  @@map("wishlist_items")
}

model CartItem {
  id        String   @id @default(cuid())
  quantity  Int      @default(1)
  
  inventoryItemId String
  inventoryItem   InventoryItem @relation(fields: [inventoryItemId], references: [id], onDelete: Cascade)
  
  ecommerceUserId String
  ecommerceUser   EcommerceUser @relation(fields: [ecommerceUserId], references: [id], onDelete: Cascade)
  
  price             Decimal   @db.Decimal(10, 2)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([inventoryItemId, ecommerceUserId])
  @@index([ecommerceUserId])
  @@map("cart_items")
}

model Order {
  id             String      @id @default(cuid())
  orderNo        String      @unique
  date           DateTime    @default(now())
  status         OrderStatus @default(PENDING)
  totalAmount    Decimal     @db.Decimal(12, 2)
  paidAmount     Decimal     @default(0) @db.Decimal(12, 2)
  shippingAmount Decimal     @default(0) @db.Decimal(12, 2)
  taxAmount      Decimal     @default(0) @db.Decimal(12, 2)
  discountAmount Decimal     @default(0) @db.Decimal(12, 2)
  
  notes          String?
  
  // Additional fields
  source            String?     // ONLINE, PHONE, WALK_IN, ECOMMERCE
  priority          String?     // HIGH, NORMAL, LOW
  expectedDelivery  DateTime?
  actualDelivery    DateTime?
  trackingNumber    String?

  // Delivery
  courierService    String?
  deliveredAt       DateTime?

  giftMessage       String?
  deliveryInstructions String?
  couponCode        String?
  // Staff (if order processed by shop staff)
  processedBy       String?
  
  // Relations - Can be either internal customer or ecommerce user
  customerId      String?
  customer        Customer?     @relation(fields: [customerId], references: [id], onDelete: Cascade)
  
  ecommerceUserId String?
  ecommerceUser   EcommerceUser? @relation(fields: [ecommerceUserId], references: [id], onDelete: Cascade)
  
  userId         String
  user           User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  shippingAddressId String
  shippingAddress   Address   @relation("ShippingAddress", fields: [shippingAddressId], references: [id])
  
  billingAddressId  String?
  billingAddress    Address?  @relation("BillingAddress", fields: [billingAddressId], references: [id])
  

  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt

  // Relations
  items          OrderItem[]
  payments       OrderPayment[]
  notifications  Notification[]
  reviews        Review[]

  @@index([userId])
  @@index([customerId])
  @@index([ecommerceUserId])
  @@index([status])
  @@index([date])
  @@map("orders")
}

model OrderItem {
  id        String  @id @default(cuid())
  quantity  Int
  price     Decimal @db.Decimal(10, 2)
  total     Decimal @db.Decimal(12, 2)
  discount  Decimal @default(0) @db.Decimal(8, 2)
  
  inventoryItemId String
  inventoryItem   InventoryItem @relation(fields: [inventoryItemId], references: [id], onDelete: Cascade)
  
  orderId   String
  order     Order   @relation(fields: [orderId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([orderId])
  @@index([inventoryItemId])
  @@map("order_items")
}



model OrderPayment {
  id               String        @id @default(cuid())
  amount           Decimal       @db.Decimal(12, 2)
  method           PaymentMethod
  status           String        // pending, completed, failed, refunded
  gatewayOrderId   String?       // Razorpay/Stripe order ID
  gatewayPaymentId String?       // Razorpay/Stripe payment ID
  transactionId    String?
  failureReason    String?
  
  orderId          String
  order            Order         @relation(fields: [orderId], references: [id], onDelete: Cascade)
  
  createdAt        DateTime      @default(now())
  updatedAt        DateTime      @updatedAt

  @@index([orderId])
  @@index([status])
  @@map("order_payments")
}

// ========================================
// LEDGER & ACCOUNTING
// ========================================

model LedgerEntry {
  id          String     @id @default(cuid())
  date        DateTime
  description String
  debit       Decimal    @default(0) @db.Decimal(12, 2)
  credit      Decimal    @default(0) @db.Decimal(12, 2)
  balance     Decimal    @db.Decimal(12, 2)
  type        LedgerType
  reference   String?    // Reference to source document
  
  // Relations (nullable for flexibility)
  partyId     String?
  party       Party?     @relation(fields: [partyId], references: [id], onDelete: Cascade)
  
  customerId  String?
  customer    Customer?  @relation(fields: [customerId], references: [id], onDelete: Cascade)
  
  invoiceId   String?
  invoice     Invoice?   @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  
  saleId      String?
  sale        Sale?      @relation(fields: [saleId], references: [id], onDelete: Cascade)
  
  invoicePaymentId String?
  invoicePayment   InvoicePayment? @relation(fields: [invoicePaymentId], references: [id], onDelete: Cascade)
  
  saleReceiptId    String?
  saleReceipt      SaleReceipt?    @relation(fields: [saleReceiptId], references: [id], onDelete: Cascade)
  
  userId      String
  user        User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  @@index([userId])
  @@index([partyId])
  @@index([customerId])
  @@index([date])
  @@index([type])
  @@map("ledger_entries")
}

// ========================================
// COMMUNICATION & NOTIFICATIONS
// ========================================

model Notification {
  id        String             @id @default(cuid())
  title     String
  message   String
  type      NotificationType
  channel   NotificationChannel
  status    NotificationStatus @default(PENDING)
  
  // Recipient details
  recipientType String           // CUSTOMER, PARTY, USER
  recipientId   String
  recipientName String
  recipientContact String?
  
  // Message details
  templateName String?
  templateData Json?
  
  // Delivery details
  sentAt       DateTime?
  deliveredAt  DateTime?
  readAt       DateTime?
  failureReason String?
  retryCount   Int              @default(0)
  maxRetries   Int              @default(3)
  
  // External service details
  externalId   String?
  externalData Json?
  
  // Relations (nullable - notification can be related to any entity)
  partyId    String?
  party      Party?    @relation(fields: [partyId], references: [id], onDelete: Cascade)
  
  customerId String?
  customer   Customer? @relation(fields: [customerId], references: [id], onDelete: Cascade)
  
  invoiceId  String?
  invoice    Invoice?  @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  
  saleId     String?
  sale       Sale?     @relation(fields: [saleId], references: [id], onDelete: Cascade)
  
  invoicePaymentId String?
  invoicePayment   InvoicePayment? @relation(fields: [invoicePaymentId], references: [id], onDelete: Cascade)
  
  saleReceiptId    String?
  saleReceipt      SaleReceipt?    @relation(fields: [saleReceiptId], references: [id], onDelete: Cascade)
  
  orderId    String?
  order      Order?    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  
  userId     String
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  @@index([userId])
  @@index([status])
  @@index([type])
  @@index([channel])
  @@index([recipientType, recipientId])
  @@index([createdAt])
  @@index([sentAt])
  @@map("notifications")
}


model NotificationTemplate {
  id          String   @id @default(cuid())
  name        String   @unique
  channel     NotificationChannel
  type        NotificationType
  subject     String?  // For email templates
  content     String   // Template content with placeholders
  variables   Json     // Expected variables and their types
  metadata    Json?    // Additional template metadata
  isActive    Boolean  @default(true)
  category    String?
  description String?
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([channel, type])
  @@index([isActive])
  @@map("notification_templates")
}

model Reminder {
  id          String         @id @default(cuid())
  message     String
  type        ReminderType
  status      ReminderStatus @default(PENDING)
  scheduledAt DateTime
  sentAt      DateTime?
  channel     String         // whatsapp, sms, email
  metadata    Json?          // Additional data like template variables
  
  customerId  String
  customer    Customer       @relation(fields: [customerId], references: [id], onDelete: Cascade)
  
  userId      String
  user        User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  @@index([userId])
  @@index([customerId])
  @@index([status])
  @@index([scheduledAt])
  @@map("reminders")
}

// ========================================
// OCR & DOCUMENT PROCESSING
// ========================================

model OCRData {
  id            String    @id @default(cuid())
  imageUrl      String
  originalName  String?   // Original filename
  fileSize      Int?      // File size in bytes
  extractedData Json      @default("{}") // Raw extracted data from OCR
  processedData Json?     // Cleaned and structured data
  confidence    Float?
  status        OCRStatus @default(PROCESSING)
  errorMessage  String?   // Error details if failed
  documentType  String?

  // Relations (nullable - one OCR can be linked to any document)
  invoiceId     String?   @unique
  invoice       Invoice?  @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
  
  invoicePaymentId String? @unique
  invoicePayment   InvoicePayment? @relation(fields: [invoicePaymentId], references: [id], onDelete: Cascade)
  
  saleReceiptId    String? @unique
  saleReceipt      SaleReceipt? @relation(fields: [saleReceiptId], references: [id], onDelete: Cascade)
  
  userId        String
  user          User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@index([userId])
  @@index([status])
  @@map("ocr_data")
}

// ========================================
// BACKUP & SYSTEM MANAGEMENT
// ========================================

model Backup {
  id          String    @id @default(cuid())
  type        String    // FULL, INCREMENTAL, SCHEMA
  description String?
  status      String    // IN_PROGRESS, COMPLETED, FAILED
  filePath    String?
  cloudPath   String?
  fileSize    BigInt?
  startedAt   DateTime
  completedAt DateTime?
  errorMessage String?
  
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([userId])
  @@index([status])
  @@map("backups")
}

model Restore {
  id          String    @id @default(cuid())
  backupId    String
  status      String    // IN_PROGRESS, COMPLETED, FAILED
  startedAt   DateTime
  completedAt DateTime?
  errorMessage String?
  
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([userId])
  @@index([status])
  @@map("restores")
}

model BackupSchedule {
  id        String   @id @default(cuid())
  frequency String   // DAILY, WEEKLY, MONTHLY
  time      String   // HH:MM format
  type      String   // FULL, INCREMENTAL
  enabled   Boolean  @default(true)
  
  userId    String   @unique
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("backup_schedules")
}

// ========================================
// AUDIT & COMPLIANCE
// ========================================

model AuditLog {
  id        String   @id @default(cuid())
  userId    String?
  user      User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  action    String   // CREATE, UPDATE, DELETE, LOGIN, etc.
  entity    String   // Table name or resource
  entityId  String   // Record ID
  oldData   Json?    // Previous data
  newData   Json?    // New data
  metadata  Json?    // Additional context
  ipAddress String?
  userAgent String?
  
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([entity])
  @@index([action])
  @@index([createdAt])
  @@map("audit_logs")
}

model SystemConfig {
  id    String @id @default(cuid())
  key   String @unique
  value Json
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("system_config")
}

// ========================================
// ENUMS
// ========================================

enum UserRole {
  OWNER
  MANAGER
  STAFF
  VIEWER
  ACCOUNTANT
}

enum InvoiceStatus {
  PENDING
  PARTIALLY_PAID
  PAID
  OVERDUE
  CANCELLED
}

enum SaleStatus {
  PENDING
  PARTIALLY_PAID
  PAID
  OVERDUE
  CANCELLED
  RETURNED
}

enum PaymentMethod {
  CASH
  BANK_TRANSFER
  CHEQUE
  UPI
  CARD
  ONLINE
  OTHER
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  CANCELLED
  REFUNDED
}

enum LedgerType {
  // Document creation entries
  INVOICE_CREATED           // When invoice is received from supplier
  SALE_CREATED             // When sale is made to customer
  
  // Payment entries
  INVOICE_PAYMENT          // Payment made to supplier
  SALE_RECEIPT             // Receipt from customer
  EXPENSE_PAYMENT          // General business expenses
  ADVANCE_PAYMENT_MADE     // Advance paid to supplier
  ADVANCE_PAYMENT_RECEIVED // Advance received from customer
  
  // Adjustments
  ADJUSTMENT
  OPENING_BALANCE
  CLOSING_BALANCE
  
  // Additional specific types
  DISCOUNT_ALLOWED         // Discount given to customer
  DISCOUNT_RECEIVED        // Discount from supplier
  BAD_DEBT_WRITEOFF       // Uncollectable customer debt
  BANK_CHARGES            // Bank transaction charges
  INTEREST_EARNED         // Interest income
  INTEREST_PAID           // Interest expense
  CREDIT_LIMIT_CHANGE
}

enum ReminderType {
  PAYMENT_DUE
  OVERDUE_PAYMENT
  FOLLOW_UP
  CUSTOM
  BIRTHDAY
  ANNIVERSARY
  STOCK_REORDER
  TAX_FILING
}

enum ReminderStatus {
  PENDING
  SENT
  DELIVERED
  FAILED
  CANCELLED
}

enum OCRStatus {
  PROCESSING
  COMPLETED
  FAILED
  MANUAL_REVIEW
  CANCELLED
}

enum OrderStatus {
  PENDING
  CONFIRMED
  PROCESSING
  SHIPPED
  DELIVERED
  CANCELLED
  RETURNED
  REFUNDED
}

enum NotificationType {
  PAYMENT_REMINDER
  PAYMENT_CONFIRMATION
  INVOICE_CREATED
  INVOICE_OVERDUE
  SALE_CREATED
  ORDER_CONFIRMATION
  ORDER_STATUS_UPDATE
  STOCK_ALERT
  LOW_STOCK_ALERT
  REORDER_ALERT
  CUSTOM
  WELCOME
  BIRTHDAY
  ANNIVERSARY
  PROMOTIONAL
  SYSTEM_ALERT
  BACKUP_COMPLETED
  BACKUP_FAILED
}

enum NotificationChannel {
  WHATSAPP
  SMS
  EMAIL
  PUSH
  IN_APP
}

enum NotificationStatus {
  PENDING
  SENT
  DELIVERED
  READ
  FAILED
  CANCELLED
}

enum MovementType {
  IN          // Stock received
  OUT         // Stock sold/dispatched
  ADJUSTMENT  // Manual stock correction
  TRANSFER    // Transfer between locations
  RETURN      // Customer/supplier returns
  DAMAGE      // Damaged goods writeoff
  SAMPLE      // Sample given to customer
  WASTAGE     // Production wastage
}

enum AddressType {
  HOME
  OFFICE
  OTHER
}

enum SignupSource {
  WEBSITE
  MOBILE_APP
  SOCIAL
  REFERRAL
}

enum Gender {
  MALE
  FEMALE
  OTHER
}